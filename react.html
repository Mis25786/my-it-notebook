<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script
      src="https://kit.fontawesome.com/7f832f4aea.js"
      crossorigin="anonymous"
    ></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Kaushan+Script&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Tilt+Prism&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="./style.css" />
    <title>Конспект-ІТ</title>
  </head>

  <body>
    <div class="wrapper">
      <header class="header">
        <a class="logo" href="./index.html">Конспект-ІТ</a>
        <nav class="header-nav">
          <a class="header-page" href="./html.html">html/css</a>
          <a class="header-page" href="./image.html">Зображення</a>
          <a class="header-page" href="./animations.html">Анімації/Ефекти</a>
          <a class="header-page" href="./js.html">JavaScript</a>
          <a class="header-page" href="./react.html">React</a>
          <a class="header-page" href="./node.html">Node</a>
          <a class="header-page" href="./commponents.html">Компоненти</a>
          <a class="header-page" href="./resources.html">Ресурси/Бібліотеки</a>
          <a class="header-page" href="./terminal.html">Термінал</a>
        </nav>
        <div class="header-search">
          <i class="fa-solid fa-magnifying-glass"></i>
          <input
            class="header-search__input"
            type="text"
            name="text"
            placeholder="site search"
          />
        </div>
      </header>
    </div>

    <main class="main">
      <!-- React -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">React</h3>
          <h3>Модуль 1_1</h3>
          <h4>файли мають закінчення jsx вмісто js</h4>
          <ul>
            <li>
              <a
                href="https://create-react-app.dev/"
                target="_blank"
                rel="noopener noreferrer"
                >Create React App</a
              >
            </li>
            <li><a href="https://uk.legacy.reactjs.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">React документація на українській</a></li>
          </ul>
          <div>
            <h3>React</h3>
            <p>
              – це бібліотека для створення елементів інтерфейсу користувача. У
              React немає вбудованої маршрутизації, HTTP-модуля тощо. Проте є
              багата екосистема, яка дозволить вирішити будь-яке завдання.
              <br />
              <br />
              При створенні застосунку з використанням React розробник не
              взаємодіє безпосередньо з DOM-деревом. Його завдання – описати
              інтерфейс за допомогою компонентів (шаблон) та керувати зміною
              даних (модель). React, при зміні даних моделі, сам оновить
              інтерфейс за шаблоном.
            </p>
            <br />
            <div>
              <h3>React – мультиплатформний</h3>
              розмітку можна рендерити на сервері (
              <a
                href="https://nextjs.org/"
                target="_blank"
                rel="noopener noreferrer"
                >Next.js</a
              >
              ), писати нативні (
              <a
                href="https://reactnative.dev/"
                target="_blank"
                rel="noopener noreferrer"
                >React Native</a
              >
              ) або десктопні (
              <a
                href="https://www.electronjs.org/"
                target="_blank"
                rel="noopener noreferrer"
                >Electron</a
              >
              ) застосунки.
            </div>
            <p>
              Для створення React-застосунку необхідні Node.js, Webpack, Babel,
              React і DevTools. Можна написати свою Webpack-збірку або взяти
              будь-яку хорошу з GitHub.
            </p>
          </div>

          <ul>
            <!-- створення React-застосунку -->
            <li>
              <h4 class="section-title__name">створення React-застосунку</h4>
              <p>
                Для навчання та маленьких/середніх проектів рекомендується
                використовувати утиліту від авторів React.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    npx create-react-app ім'я_папки_проекту
                  </h5>
                  <p>
                    Щоб створити застосунок у поточній папці, замість імені
                    проекту ставиться крапка. Наприклад npx create-react-app .
                  </p>

                  <h5 class="section-title__value">React DevTools</h5>
                  <p>
                    В інструментах розробника можна подивитися на дерево
                    компонентів, їх стан та пропси. Профайлер корисний під час
                    оптимізації застосунку.
                  </p>
                  <ul>
                    <li>
                      <a
                        href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                        target="_blank"
                        rel="noopener noreferrer"
                        >Devtools в Chrome Web Store</a
                      >
                    </li>
                    <li>
                      <a
                        href="https://legacy.reactjs.org/blog/2019/08/15/new-react-devtools.html"
                        target="_blank"
                        rel="noopener noreferrer"
                        >Introducing the New React DevTools</a
                      >
                    </li>
                  </ul>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- JSX (JavaScript Syntax Extension) -->
            <li>
              <h4 class="section-title__name">
                JSX (JavaScript Syntax Extension)
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    JSX створює елементи – найменші будівельні блоки React.
                    Елементи Virtual DOM це звичайні JavaScript об'єкти, тому
                    створювати їх дуже швидко. <br />
                    <br />
                    Використовуючи JSX, розмітка стає схожою на звичні
                    HTML-шаблони. <br />
                  </p>
                  <ul>
                    <li>
                      <p>
                        Усередині JSX можна використовувати будь-який валідний
                        вираз, обертаючи його в фігурні дужки.
                      </p>
                    </li>
                    <li>
                      <p>
                        Значення атрибутів вказуються в подвійних лапках, якщо
                        це звичайний рядок, та у фігурних дужках, якщо значення
                        обчислюється, або тип відрізняється від рядка.
                      </p>
                    </li>
                    <li>
                      <p>
                        Всі атрибути React-елементів іменуються в camelCase
                        нотації.
                      </p>
                    </li>
                    <li>
                      <p>
                        JSX-теги можуть бути батьками інших JSX-тегів. Якщо тег
                        порожній або самозакривається, його обов'язково
                        необхідно закрити використовуючи />.
                      </p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    const imageUrl = <br />
                    "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";
                    <br />
                    const productPrice = 10.99; <br />
                    <br />
                    const product = ( <br />
                    < div> <br />
                    < img src={imageUrl} alt="Tacos With Lime" width="640" />
                    <br />
                    < h2>Tacos With Lime< /h2> <br />
                    < p>Price: {productPrice}$< /p> <br />
                    < button type="button">Add to cart< /button> <br />
                    < /div> <br />
                    ); <br />
                  </p>

                  <h5 class="section-title__value">
                    Рендер елементів у DOM-дерево
                  </h5>
                  <p>
                    Для того, щоб відрендерувати елемент у DOM-дерево, у пакеті
                    react-dom є методи createRoot(container) та render(element),
                    які працюють разом.
                  </p>
                  <p>
                    Перший приймає посилання на існуючий DOM-елемент, наприклад
                    div#root з index.html і створює корінь, в який буде
                    рендеруватись вся програма. <br />
                    Другий чекає на посилання на React-елемент або компонент (що
                    рендерити). <br />
                  </p>
                  <h4>
                    ReactDOM.createRoot(document.getElementById("root")).render(product);
                  </h4>

                  <h5 class="section-title__value">Правило спільного батька</h5>
                  <p>
                    Якщо в розмітці зайвий тег-обгортка не потрібний,
                    використовуються фрагменти, схожі на DocumentFragment. Цей
                    вбудований компонент при рендері розчиняється, підставляючи
                    свій вміст.
                  </p>
                  <p class="exemplar">
                    import { Fragment } from "react"; <br />
                    <br />
                    const post = ( <br />
                    < Fragment> <br />
                    < h2>Post Header< /h2> <br />
                    < p>Post text< /p> <br />
                    < /Fragment> <br />
                    ); <br />
                  </p>
                  <p>
                    Синтаксис фрагментів можна скоротити та не додавати імпорт
                    Fragment. Babel зробить всі необхідні трансформації,
                    замінивши порожні JSX-теги на React.Fragment.
                  </p>
                  <p class="exemplar">
                    const post = ( <br />
                    < > <br />
                    < h2>Post Header< /h2> <br />
                    < p>Post text< /p> <br />
                    < /> <br />
                    ); <br />
                  </p>

                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Компоненти -->
            <li>
              <h4 class="section-title__name">Компоненти</h4>
              <p>
                – основні будівельні блоки React-застосунків, за допомогою яких
                інтерфейс розділяється на незалежні частини. <br />
                <br />
                Розробник створює невеликі компоненти, які можна поєднувати, щоб
                сформувати більші, або використовувати їх як самостійні елементи
                інтерфейсу. Найголовніше в цій концепції те, що і великі, і
                маленькі компоненти можна використовувати повторно і в
                поточному, і в новому проекті. <br />
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Компонент це окремо створений файл, в якому створена
                    розмітка будьякого елемента (картки товару, лоадер, модалка
                    і т д) який ми потім можемо підключити в будь-якому іншому
                    компоненті (файлі) і перевикористовувати. <br />
                    Також можна вставляти один компонент в інший при рендері.
                    <br />
                    В компонент не імпортуеться масив з елементами, всі данні
                    передаються пропсами з основного файлу (App.js) де буде
                    рендиритись компонент. <br />
                    Пропси мають ключ="значення", зазвичай пропси називають так
                    само як в ключі в об'єктах які передаємо. Пропси значення в
                    пропсах передаємо в фігурних дужках price={product.price},
                    рядок (текст) в лапках.
                  </p>
                  <div class="exemplar">
                    <h4>КОМПОНЕНТ</h4>
                    <p>
                      const Product = ({ imgUrl, name, price }) => ( <br />
                      < div> <br />
                      < img src={imgUrl} alt={name} width="640" /> <br />
                      < h2>{name}< /h2> <br />
                      < p>Price: {price}$< /p> <br />
                      < button type="button" >Add to cart< /button> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                  </div>
                  <p>
                    Тут ми імпортуемо компонент ProductList і в ньому рендиремо
                    компонент Product
                  </p>
                  <div class="exemplar">
                    <h4>ФАЙЛ ОСНОВНИЙ З ЯКОГО РЕНДЕРИТЬСЯ ВЕСЬ ПРОЕКТ</h4>
                    <p>
                      import ProductList from "productList.js"; <br />
                      import Product from "product.js"; <br />
                      <br />
                      import products from "products.json"; // файл з масивом
                      об'єктів продуктів <br />
                      <br />
                      <br />
                      const App = () => ( <br />
                      < div> <br />
                      < h1>Best selling products< /h1> <br />
                      < ProductList > <br />
                      < Product <br />
                      imgUrl={products.imgUrl} <br />
                      name="Tacos With Lime" <br />
                      price={products.price} <br />
                      /> <br />
                      < /ProductList> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                  </div>

                  <h5 class="section-title__value">
                    Значення пропсів за замовчуванням
                  </h5>
                  <p>
                    Що якщо компонент очікує якесь значення, а його не передали?
                    - під час звернення до властивості об'єкта props отримаємо
                    undefined. <br />
                    <br />
                    Для того щоб вказати значення властивостей за замовчуванням,
                    використовується синтаксис значень за замовчуванням під час
                    деструктуризації пропсів. <br />
                  </p>
                  <p class="exemplar">
                    import imageDefault from "../images/image.jpg"; <br />
                    <br />
                    const Product = ({ <br />
                    imgUrl = imageDefault, <br />
                    name = "no name", <br />
                    price = "please call at", <br />
                    }) => ( <br />
                    - || - <br />
                    ); <br />
                  </p>

                  <h5 class="section-title__value">
                    Властивість props.children
                  </h5>
                  <p>
                    Концепція дочірніх елементів дозволяє дуже просто робити
                    композицію компонентів. У вигляді дітей можна передавати
                    компоненти як вбудовані, так і кастомні. Це дуже зручно під
                    час роботи зі складними складеними компонентами. <br />
                    <br />
                    Властивість children автоматично доступна в кожному
                    компоненті, її вмістом є те, що знаходиться між відкриваючим
                    та закриваючим JSX-тегом. <br />
                    У функціональних компонентах звертаємось як props.children.
                    <br />
                    Значенням props.children може бути практично все, що
                    завгодно. <br />
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      const Profile = ({ name, email }) => ( <br />
                      < div> <br />
                      < p>Name: {name}< /p> <br />
                      < p>Email: {email}< /p> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                    <p>
                      const Panel = ({ title, children }) => ( <br />
                      < section> <br />
                      < h2>{title}< /h2> <br />
                      {children} <br />
                      < /section> <br />
                      ); <br />
                    </p>
                    <p>
                      const App = () => ( <br />
                      < div> <br />
                      < Panel title="User profile"> <br />
                      < Profile name="Mango" email="mango@mail.com" /> <br />
                      < /Panel> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                  </div>

                  <h5 class="section-title__value">
                    Перевірка типів одержуваних пропсів Властивість propTypes
                  </h5>
                  <div>
                    Пакет
                    <a
                      href="https://www.npmjs.com/package/prop-types"
                      target="_blank"
                      rel="noopener noreferrer"
                      >prop-types</a
                    >
                    надає ряд валідаторів для перевірки коректності отриманих
                    типів даних під час виконання коду, повідомляючи про
                    невідповідності в консолі.
                  </div>
                  <h3>npm install --save-dev prop-types</h3>
                  <p class="exemplar">
                    import PropTypes from "prop-types"; <br />
                    <br />
                    const Product = ({ <br />
                    imgUrl =
                    "https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder",
                    <br />
                    name, <br />
                    price, <br />
                    }) => ( <br />
                    < div> <br />
                    < img src={imgUrl} alt={name} width="640" /> <br />
                    < h2>{name}< /h2> <br />
                    < p>Price: {price}$< /p> <br />
                    < button type="button">Add to cart< /button> <br />
                    < /div> <br />
                    ); <br />
                    <br />
                    Product.propTypes = { <br />
                    imgUrl: PropTypes.string, <br />
                    name: PropTypes.string.isRequired, <br />
                    price: PropTypes.number.isRequired, <br />
                    }; <br />
                  </p>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Рендер за умовою -->
            <li>
              <h4 class="section-title__name">Рендер за умовою</h4>
              <ul>
                <li>
                  <a
                    href="https://react.dev/learn/conditional-rendering"
                    target="_blank"
                    rel="noopener noreferrer"
                    >Умовний рендеринг</a
                  >
                </li>
                <li>
                  <a
                    href="https://www.robinwieruch.de/conditional-rendering-react/"
                    target="_blank"
                    rel="noopener noreferrer"
                    >All the Conditional Renderings in React</a
                  >
                </li>
              </ul>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    if за допомогою логічного оператора &&
                  </h5>
                  <p class="exemplar">
                    Читається як: якщо умова приводиться до true, то рендерим
                    розмітку. <br />
                    <br />
                    const Mailbox = ({ unreadMessages }) => { <br />
                    return ( <br />
                    < div> <br />
                    < h1>Hello!< /h1> <br />
                    {unreadMessages.length > 0 && ( <br />
                    < p>You have {unreadMessages.length} unread messages.< /p>
                    <br />
                    )} <br />
                    < /div> <br />
                    ); <br />
                    }; <br />
                  </p>

                  <h5 class="section-title__value">
                    if...else за допомогою тернарного оператора
                  </h5>
                  <p class="exemplar">
                    const Mailbox = ({ name, unreadMessages }) => { <br />
                    return ( <br />
                    < div> <br />
                    < h1>Hello {name}< /h1> <br />
                    < p> <br />
                    {unreadMessages.length > 0 <br />
                    ? `You have ${unreadMessages.length} unread messages.`
                    <br />
                    : "No unread messages."} <br />
                    < /p> <br />
                    < /div> <br />
                    ); <br />
                    }; <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Рендер колекції однотипних елементів
              </h4>
              <a
                href="https://react.dev/learn/rendering-lists"
                target="_blank"
                rel="noopener noreferrer"
                >Списки і ключі</a
              >
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Для того щоб відрендерити колекцію однотипних елементів,
                    використовується метод Array.prototype.map(),
                    callback-функція якого, для кожного елемента колекції
                    повертає JSX-розмітку. Отже, отримуємо масив
                    React-елементів, який можна рендерити. <br />
                    <br />
                    Під час виконання коду з прикладу вище спливе попередження
                    про те, що для елементів списку потрібен ключ. React не може
                    відрізнити елементи в колекції, таким чином, перемальовуючи
                    всю колекцію повністю у разі будь-яких змін. <br />
                    <br />
                    <span class="selection">Ключ (key)</span> — це спеціальний
                    рядковий проп, який потрібно задати під час створення
                    елементів колекції. <br />
                    <br />
                    Елементи всередині колекції повинні бути забезпечені
                    ключами, щоб мати стабільну ідентичність. React використовує
                    ключі, щоб визначити, які з елементів в колекції необхідно
                    створити і відрендерити знову, а не використовувати елементи
                    з попереднього рендеру. Таким чином ми уникаємо
                    перестворення всіх елементів колекції щоразу, коли щось
                    змінюється. <br />
                    <br />
                  </p>
                  <p class="exemplar">
                    const favouriteBooks = [ <br />
                    { id: "id-1", name: "JS for beginners" }, <br />
                    { id: "id-2", name: "React basics" }, <br />
                    { id: "id-3", name: "React Router overview" }, <br />
                    { id: "id-4", name: "Redux in depth" }, <br />
                    ]; <br />
                    <br />
                    const BookList = ({ books }) => ( <br />
                    < ul> <br />
                    {books.map(book => ( <br />
                    < li key={book.id}>{book.name}< /li> <br />
                    ))} <br />
                    < /ul> <br />
                    ); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Стилізація (SCSS, CSS) -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Стилізація (SCSS, CSS)</h3>
          <h3></h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- CSS-модулі (основний метод для стилізації) -->
            <li>
              <h4 class="section-title__name">CSS-модулі (основний метод для стилізації)</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Create React App за замовчуванням підтримує CSS-модулі, все, що необхідно зробити це створювати файли стилів з розширенням .module.css, наприклад Alert.module.css. Всередині модуля CSS можна використовувати будь-який валідний CSS.
                  </p>
                  <p class="exemplar">
                    src/components/Alert.module.css <br>
                    .alert { <br>
                      margin: 8px; <br>
                      padding: 12px 16px; <br>
                      border-radius: 4px; <br>
                      background-color: gray; <br>
                      color: white; <br>
                    } <br>
                  </p>
                  <p>
                    Синтаксис імпорту CSS-модуля нагадує імпорт файлу JavaScript модуля. У CSS-модулі є експорт за замовчуванням - об'єкт відповідності оригінального та згенерованих імен класів. У фінальному файлі стилів буде унікальне ім'я класу у форматі [filename]_[classname]__[hash].
                  </p>
                  <p class="exemplar">
                    src/components/Alert.js <br>
                    // Синтаксис імпорту CSS-модуля <br>
                    import css from "./Alert.module.css"; <br>
                    // Отримуємо об'єкт відповідності імен класів <br>
                    console.log(css); // { alert: "Alert_alert_ax7yz" } <br>
                    const Alert = ({ children }) => { <br>
                      // Звертаємось до властивості об'єкта на ім'я класу з файлу модуля <br>
                      return < p className={css.alert}>{children}< /p>; <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Властивість composes</h5>
                  <p>
                    Композиція селекторів це одна з ключових можливостей CSS-модулів, яка дозволяє створювати клас, наслідуючи стилі іншого класу, але не дублюючи їх.
                    Наслідуємо стилі базового класу .alert у всіх класах варіантів. Властивість composes має передувати іншим правилам, щоб можна було перевизначити стилі, якщо це необхідно.
                  </p>
                  <p class="exemplar">
                    src/components/Alert.module.css <br>
                    .alert { <br>
                      margin: 8px; <br>
                      padding: 12px 16px; <br>
                      border-radius: 4px; <br>
                      background-color: gray; <br>
                      color: white; <br>
                    } <br>
                    .info { <br>
                      composes: alert; <br>
                      background-color: blue; <br>
                    } <br>
                    .success { <br>
                      composes: alert; <br>
                      background-color: green; <br>
                    } <br>
                    .error { <br>
                      composes: alert; <br>
                      background-color: red; <br>
                    } <br>
                    .warning { <br>
                      composes: alert; <br>
                      background-color: orange; <br>
                    } <br>
                  </p>
                  <p>
                    При композиції у простих випадках можна обійтися без бібліотеки clsx. Не задаємо базовий клас alert, тому що від нього виконано композицію класів варіантів. В результаті на елементі <p> будуть два класи, базовий alert і клас варіанта, у якому перевизначається значення кольору фону.
                  </p>
                  <p class="exemplar">
                    src/components/Alert.js <br>
                    import css from "./Alert.module.css"; <br>
                    const Alert = ({ variant, children }) => { <br>
                      return < p className={css[variant]}>{children}< /p>; <br>
                    }; <br>
                  </p>
                  <h3>До властивостей об'єкта зазвичай звертаються як css.alert, але можна використовувати квадратні дужки, наприклад css["alert"]. Це корисно у випадку коли ім'я властивості зберігається у змінній, як у нас у пропсі variant.</h3>
                  
                  <h5 class="section-title__value">Бібліотека <a href="https://www.npmjs.com/package/clsx" target="_blank" rel="noopener noreferrer">clsx</a></h5>
                  <p>
                    Додамо CSS класи для вже знайомих нам пропсів outlined та elevated. Імена класи, що складаються з декількох слів записують у верблюжій нотації. В протилежному випадку, оскільки вони стають властивостями об'єкта, звертатися до них доведеться через квадратні дужки, наприклад css["is-outlined"], що менш зручно.
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      src/components/Alert.module.css <br>
                      .alert { <br>
                        margin: 8px; <br>
                        padding: 12px 16px; <br>
                        border-radius: 4px; <br>
                        background-color: gray; <br>
                        color: white; <br>
                      } <br>
                        <br>
                      .info { <br>
                        composes: alert; <br>
                        background-color: blue; <br>
                      } <br>
                        <br>
                      .success { <br>
                        composes: alert; <br>
                        background-color: green; <br>
                      } <br>
                        <br>
                      .error { <br>
                        composes: alert; <br>
                        background-color: red; <br>
                      } <br>
                        <br>
                      .warning { <br>
                        composes: alert; <br>
                        background-color: orange; <br>
                      } <br>
                        <br>
                      .alert.isOutlined { <br>
                        outline: 1px solid black; <br>
                      } <br>
                        <br>
                      .alert.isElevated { <br>
                        box-shadow: rgb(0 0 0 / 20%) 0px 3px 3px -2px, <br>
                          rgb(0 0 0 / 14%) 0px 3px 4px 0px, rgb(0 0 0 / 12%) 0px 1px 8px 0px; <br>
                      } <br>
                    </p>
                    <p>
                      src/components/Alert.js <br>
                      import clsx from "clsx"; <br>
                      import css from "./Alert.module.css"; <br>
                      const Alert = ({ variant, outlined, elevated, children }) => { <br>
                        return ( <br>
                          < p <br>
                            className={clsx(css[variant], { <br>
                              [css.isOutlined]: outlined, <br>
                              [css.isElevated]: elevated, <br>
                            })} <br>
                          > <br>
                            {children} <br>
                          < /p> <br>
                        ); <br>
                      }; <br>
                    </p>
                  </div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Вбудовані стилі -->
            <li>
              <h4 class="section-title__name">Вбудовані стилі</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <h3>
                    Існує кілька способів стилізації компонентів, найпростіший,
                    але в той же час найбільш обмежений – це вбудовані стилі.
                    Для цього використовується атрибут style, який у React
                    приймає не рядок, а об'єкт стилів.
                  </h3>
                  <p></p>
                  <div class="section-box">
                    <p class="exemplar">
                      Створимо компонент Alert який буде рендерувати абзац
                      тексту та приховає у собі майбутню логіку вибору кольору
                      фону. <br />
                      <br />
                      src/components/Alert.js <br />
                      const alertStyles = { <br />
                      margin: 8, <br />
                      padding: "12px 16px", <br />
                      borderRadius: 4, <br />
                      backgroundColor: "gray", <br />
                      color: "white", <br />
                      }; <br />
                      export const Alert = ({ children }) => { <br />
                      return < p style={alertStyles}>{children}< /p>; <br />
                      }; <br />
                    </p>
                    <p class="exemplar">
                      Зробимо так, щоб залежно від типу оповіщення, у компоненті Alert змінювався колір фону абзацу. Для цього додамо йому обов'язковий пропс variant з кількома можливими значеннями. <br>
                      <br>
                      src/components/App.js <br>
                      import { Alert } from "./Alert"; <br>
                      const App = () => { <br>
                        return ( <br>
                          <> <br>
                            < Alert variant="info"> <br>
                              Would you like to browse our recommended products? <br>
                            < /Alert> <br>
                            < Alert variant="error"> <br>
                              There was an error during your last transaction <br>
                            < /Alert> <br>
                            < Alert variant="success"> <br>
                              Payment received, thank you for your purchase <br>
                            < /Alert> <br>
                            < Alert variant="warning"> <br>
                              Please update your profile contact information <br>
                            < /Alert> <br>
                          </> <br>
                        ); <br>
                      }; <br>
                    </p>
                    <p class="exemplar">
                      Логіку вибору кольору винесемо у функцію getBgColor(variant), яка буде повертати рядок із назвою кольору залежно від значення параметра variant. <br>
                                           <br>
                      src/components/Alert.js <br>
                      const alertStyles = { <br>
                        margin: 8, <br>
                        padding: "12px 16px", <br>
                        borderRadius: 4, <br>
                        color: "white", <br>
                      }; <br>
                      const getBgColor = variant => { <br>
                        switch (variant) { <br>
                          case "info": <br>
                            return "blue"; <br>
                          case "success": <br>
                            return "green"; <br>
                          case "error": <br>
                            return "red"; <br>
                          case "warning": <br>
                            return "orange"; <br>
                          default: <br>
                            throw new Error(`Unsupported variant prop value - ${variant}`); <br>
                        } <br>
                      }; <br>
                      export const Alert = ({ variant, children }) => { <br>
                        return ( <br>
                          < p style={{ ...alertStyles, backgroundColor: getBgColor(variant) }}> <br>
                            {children} <br>
                          < /p> <br>
                        ); <br>
                      }; <br>
                    </p>
                  </div>
                  <h3 class="selection">На практиці вбудовані стилі використовуються тільки для динамічно обчислюваних значень властивостей, у парі із зовнішніми таблицями стилів. В якості основного способу стилізації компонентів вбудовані стилі не використовуються в проектах та тому не рекомендуються.</h3>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Ванільний CSS -->
            <li>
              <h4 class="section-title__name">Ванільний CSS</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Оформлення компонента можна винести до таблиці стилів. У цьому випадку стилі кожного компонента оголошуються в окремому CSS-файлі з розширенням .css. Ім'я файлу складається з імені компонента та розширення. Наприклад, для компонента Alert, файл стилів буде називатися Alert.css.
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      src/components/Alert.css <br>
                      .alert { <br>
                        margin: 8px; <br>
                        padding: 12px 16px; <br>
                        border-radius: 4px; <br>
                        background-color: gray; <br>
                        color: white; <br>
                      } <br>
                    </p>
                    <p>
                      src/components/Alert.js <br>
                      import "./Alert.css"; <br>
                      const Alert = ({ children }) => { <br>
                        return < p className="alert">{children}< /p>; <br>
                      }; <br>
                    </p>
                  </div>
                  <h5 class="section-title__value">Бібліотека <a href="https://www.npmjs.com/package/clsx" target="_blank" rel="noopener noreferrer">clsx</a> </h5>
                  <p>
                    Для вирішення більшості завдань, пов'язаних з безліччю класів, що задаються згідно з певними умовами, використовують бібліотеку clsx. Звичайно, JavaScript надає багатий синтаксис, але здебільшого пишуться непродуктивні рішення або код, що погано читається. Бібліотека стандартизує цей процес і робить його більш зручним за рахунок продуманого синтаксису.
                  </p>
                  <h3>npm install clsx</h3>
                  <p>
                    Функції clsx можна передати список виразів як набір аргументів. Вирази що приводяться до true, результат яких це рядок або число, буде додано у фінальний рядок класів.
                  </p>
                  <p class="exemplar">
                    import clsx from "clsx"; <br>
                    <br>
                    const className = clsx( <br>
                      "first", <br>
                      10, <br>
                      undefined && "second", <br>
                      true && "third", <br>
                      false ? "fourth" : "fifth" <br>
                    ); <br>
                    console.log(className); // "first 10 third fifth" <br>
                  </p>
                  <p>Ось як виглядатиме код компонента Alert використовуючи бібліотеку clsx.</p>
                  <p class="exemplar">
                    src/components/Alert.js <br>
                    import clsx from "clsx"; <br>
                    import "./Alert.css"; <br>
                    const Alert = ({ variant, outlined, elevated, children }) => { <br>
                      return ( <br>
                        < p <br>
                          className={clsx( <br>
                            "alert", <br>
                            variant, <br>
                            outlined && "is-outlined", <br>
                            elevated && "is-elevated" <br>
                          )} <br>
                        > <br>
                          {children} <br>
                        < /p> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Препроцесори</h5>
                  <h3>npm install sass</h3>
                  <p>
                    Використовувати препроцесори можна, але можливість композиції компонентів робить їх менш корисними, оскільки замінює такі концепції як домішки, функції, вкладеність та інші. Не рекомендується використовувати одні й ті самі CSS-класи в різних компонентах, для цього є композиція компонентів. <br>
                     <br>
                    Наприклад, замість використання базового CSS-класу .button у компонентах < LoginButton> та < FollowButton>, краще створити компонент < Button> зі своїми власними стилями, які можуть відображатись у кількох варіантах. Тоді компоненти < LoginButton> та < FollowButton> можуть використовувати компонент < Button>, а не просто CSS-клас. <br>
                  </p>
                  <p class="exemplar">
                    // Button.js <br>
                    const Button = ({ variant, children }) => { <br>
                      // Базові стилі кнопки з кількома варіантами відображення <br>
                      return < button className={clsx("button", variant)}>{children}< /button>; <br>
                    }; <br>
                     <br>
                    // LoginButton.js <br>
                    const LoginButton = () => { <br>
                      // Унікальна логіка кнопки логіна <br>
                      return < Button variant="primary">Login< /Button>; <br>
                    }; <br>
                     <br>
                    // FollowButton.js <br>
                    const FollowButton = () => { <br>
                      // Унікальна логіка кнопки підписки <br>
                      return < Button variant="secondary">Follow< /Button>; <br>
                    }; <br>
                  </p>
                  <p>Правила іменування файлів такі ж, як і для ванільного CSS, відрізняється тільки розширення, наприклад .scss для SASS. В іншому у препроцесорів ті ж можливості, концепції та недоліки, що і у ванільного CSS. Для того щоб додати можливість використання SASS, встановіть його компілятор у проект.</p>
                  <h3>
                    Використання ванільного CSS теж не найкращий підхід і має ряд недоліків, особливо у великих проектах. <br>
                                       <br>
                    Слабка масштабованість <br>
                    Обмежене повторне використання стилів <br>
                    Для динамічних значень необхідно використовувати вбудовані стилі <br>
                    Проблема глобального простору імен <br>
                    Необхідність використовувати якусь конвенцію іменування селекторів класу <br>
                    Відсутність автоматичного видалення коду, що не використовується. <br>
                  </h3>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            
            <!-- Нормалізація стилів -->
            <li>
              <h4 class="section-title__name">Нормалізація стилів</h4>
              <ul>
                <li><a href="https://github.com/csstools/normalize.css" target="_blank" rel="noopener noreferrer">normalize.css</a></li>
                <li><a href="https://github.com/csstools/sanitize.css" target="_blank" rel="noopener noreferrer"> sanitize.css</a></li>
              </ul>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Стилі елементів можуть відрізнятись між браузерами. Для того, щоб привести їх до стандартного вигляду, необхідно додати набір правил, що виправляє відмінності у стилях елементів між браузерами, наскільки це можливо. <br>
                                       <br>
                    У Create React App вбудована можливість використовувати PostCSS Normalize - суміш кількох популярних таблиць стилів (normalize.css та sanitize.css) з найкращими практиками нормалізації. Все, що необхідно зробити - це додати директиву @import-normalize; у будь-якому місці файлу стилів або CSS-модуля. Повторюючі імпорти будуть автоматично видалені, тому достатньо додати директиву до одного файлу стилів, наприклад index.css. <br>
                  </p>
                  <p class="exemplar">
                    src/index.css <br>
                    @import-normalize; <br>
                    body { <br>
                      font-family: sans-serif; <br>
                      line-height: 1.5; <br>
                    } <br>
                    h1, <br>
                    h2, <br>
                    h3, <br>
                    h4, <br>
                    h5, <br>
                    h6, <br>
                    p { <br>
                      margin: 0; <br>
                    } <br>
                    ul, <br>
                    ol { <br>
                      margin: 0; <br>
                      padding: 0; <br>
                    } <br>
                    img { <br>
                      display: block; <br>
                      max-width: 100%; <br>
                      height: auto; <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            

            <!--  -->
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

          </ul>
        </div>
      </div>

      <!-- Компоненти-класи -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Компоненти-класи</h3>
          <h3>Модуль 2_1</h3>
          <h4>Назви компонентів пишуться з великої букви</h4>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Компоненти-класи -->
            <li>
              <h4 class="section-title__name">Компоненти-класи</h4>
              <img src="./img/js/component-class.jpg" width="400" alt="" />
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Якщо необхідно додати динаміки, компоненти створюються як класи, тому що компоненти-функції (до хуків) обмежені можливістю створення розмітки за отриманими пропсами.
                  </p>
                  <ul>
                    <li>
                      <p>Звичайний ES6 клас, тому застосовуються правила: конструктор, методи, контекст (this).</p>
                    </li>
                    <li>
                      <p>Обов'язково розширює базовий клас React.Component.</p>
                    </li>
                    <li>
                      <p>Діє як функція, яка отримує props, але також реалізує приватний внутрішній стан.</p>
                    </li>
                    <li>
                      <p>Необхідно оголосити обов'язковий метод render(), який викликається за замовчуванням і повертає JSX-розмітку.</p>
                    </li>
                    <li>
                      <p>Щоразу під час використання компонента-класу, React буде створювати екземпляр компонента (класу), тому доступ до пропсів відбувається через this.props.</p>
                    </li>
                    <li>
                      <p>Можна визначити кастомні методи класу і використовувати їх в будь-якому місці, зокрема всередині JSX, викликати або передавати дітям як пропси.</p>
                    </li>
                    <li>
                      <p>Коли змінюється стан або пропcи компонента, відбувається його ререндер.</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    // Відокремлюйте іменовані імпорти, це підвищує читабельність коду <br>
                    import React, { Component } from "react"; <br>
                    <br>
                    class MyClassComponent extends Component { <br>
                      static defaultProps = {}; <br>
                    <br>
                      static propTypes = {}; <br>
                    <br>
                      render() { <br>
                        return < div>Class Component< /div>; <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Події -->
            <li>
              <h4 class="section-title__name">Події</h4>
              <a href="https://uk.legacy.reactjs.org/docs/handling-events.html" target="_blank" rel="noopener noreferrer">Обробка подій</a>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">< button onClick={event => console.log(event)}>Click me!< /button></h5>
                  <p>
                    Для нативної події браузера в React створюється об'єкт-обгортка SyntheticEvent Object з ідентичним інтерфейсом. Це необхідно, щоб забезпечити крос-браузерність та оптимізувати продуктивність.
                  </p>
                  <ul>
                    <li>
                      <p>Додавання обробника подій з EventTarget.addEventListener() майже не використовується, за рідкісним винятком.</p>
                    </li>
                    <li>
                      <p>Пропси подій – не виняток та іменуються за допомогою camelCase. Наприклад onClick, onChange, onSubmit, onMouseEnter.</p>
                    </li>
                    <li>
                      <p>У проп події передається посилання на callback-функцію, яка буде викликана під час настання події.</p>
                    </li>
                    <li>
                      <p>Обробники подій отримують екземпляр SyntheticEvent Object.</p>
                    </li>
                  </ul>
                  <p>В React "під капотом" реалізовано делегування подій. Слухачі не додаються безпосередньо до DOM-елементів. Передача колбека – це просто реєстрація функції, яка буде викликана внутрішніми механізмами реакта під час настання події.</p>
                  <p class="exemplar">
                    return (
                    < div> <br>
                      < span>0< /span> <br>
                      < button type="button" onClick={this.handleIncrement.bind(this)}> <br>
                        Increment by {step} <br>
                      < /button> <br>
                      < button type="button" onClick={this.handleDecrement.bind(this)}> <br>
                        Decrement by {step} <br>
                      < /button> <br>
                    < /div> <br>
                  ); <br>
                  </p>
                  <h5 class="section-title__value">Прив'язка контексту (використовуємо такий спосіб)</h5>
                  <p>
                    Потрібно завжди пам'ятати про значення this у методах, що використовуються як callback-функції. В JavaScript контекст у методах класу не прив'язується за замовчуванням. Якщо забути прив'язати контекст, і передати метод як callback-функцію обробнику події, під час виклику функції this буде невизначений (undefined).
                  </p>
                  <p>
                    Тобто, коли передаємо колбек функції для обробки подій то потрібно передавати не як звичайний метод класу <br>
                    <br>
                    // ❌ Погано <br>
                    class Counter extends Component { <br>
                      /* ... */ <br>
                     <br>
                      handleIncrement(evt) { <br>
                        // ... <br>
                      } <br>
                      <br>
                      а передаємо як стрілочну функцію щоб привязало контекст <br>
                      <br>
                      // ✅ Добре <br>
                      class Counter extends Component { <br>
                        /* ... */ <br>
                       <br>
                        handleIncrement = evt => { <br>
                          /* ... */<br>
                        }; <br>
                  </p>
                  <h5 class="section-title__value">Прив'язка в конструкторі</h5>
                  <p>
                    Ще один спосіб прив'язати контекст – зробити це у конструкторі класу. Якщо callback-функцій багато, можете уявити, наскільки великий може вийти конструктор. <br>
                                       <br>
                    Конструктор виконується один раз, тому bind викликається один раз <br>
                    Методи класу записуються у властивість prototype функції-конструктора <br>
                    <br>
                    // ✅ Непогано <br>
                    class Counter extends Component { <br>
                      /* ... */ <br>
                     <br>
                      constructor() { <br>
                        super(); <br>
                        this.handleIncrement = this.handleIncrement.bind(this); <br>
                        this.handleDecrement = this.handleDecrement.bind(this); <br>
                      } <br>
                  </p>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Внутрішній стан компонента</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Об'єкт-стану state – це властивість класу, яка не повинна безпосередньо змінюватися розробником.
                  </p>
                  <ul>
                    <li>
                      <p>Дані в state контролюють те, що відображається в інтерфейсі.</p>
                    </li>
                    <li>
                      <p>Дані, що зберігаються у стані, повинні бути інформацією, яка буде оновлюватися методами компонента.</p>
                    </li>
                    <li>
                      <p>Не потрібно дублювати дані з props у стані.</p>
                    </li>
                    <li>
                      <p>Щоразу, коли змінюється стан компонента (або пропси), викликається метод render().</p>
                    </li>
                    <li>
                      <p>Інтерфейс залежить від стану компонента.</p>
                    </li>
                    <li>
                      <p>Стан може змінитися як реакція на дії користувача.</p>
                    </li>
                    <li>
                      <p>Під час зміни стану дані передаються вниз по дереву компонентів.</p>
                    </li>
                    <li>
                      <p>Компоненти повертають оновлену розмітку і змінюється інтерфейс.</p>
                    </li>
                  </ul>
                  <p>
                    Стан належить компоненту і змінюється тільки його методами. <br>
                    Стан оголошується в конструкторі, оскільки це перше, що відбувається, коли створюється екземпляр класу.
                  </p>
                  <p class="exemplar">
                    class Counter extends Component { <br>
                      constructor() { <br>
                        super(); <br>
                       <br>
                        this.state = { <br>
                          value: 0, <br>
                        }; <br>
                      } <br>
                     <br>
                      render() { <br>
                        return ( <br>
                          < div> <br>
                            < span>{this.state.value}< /span> <br>
                            {/* ... */} <br>
                          < /div> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>

                    <h5 class="section-title__value">Початковий стан від props (як задати дефолтні значення в класах)</h5>
                  <p class="exemplar">
                    class Counter extends Component { <br>
                    static defaultProps = { <br>
                      step: 1, <br>
                      initialValue: 0, <br>
                    }; <br>
                   <br>
                    constructor(props) { <br>
                      super(props); <br>
                     <br>
                      this.state = { <br>
                        value: this.props.initialValue, <br>
                      }; <br>
                    } <br>
                  </p>
                  <h3>В реакті не потрібно створювати конструктор а вказуємо стан як публічну властивість, все інше за нас зробить Babel</h3>
                 <div class="exemplar section-box">
                   <p >
                    В МІСТО ЦЬОГО constructor() <br>
                    class Counter extends Component {                     <br>
                      constructor(props) { <br>
                        super(props); <br>
                        <br>
                        this.state = {value: this.props.initialValue, }} <br>
                    } <br>
                  </p>
                  <p class="selection">
                     СТВОРЮЄМО state = {} <br>
                    class Counter extends Component {                      <br>
                      state = {value: this.props.initialValue,};                     <br>
                    // ... // <br>
                    } <br>
                  </p>
                 </div>

                    <h5 class="section-title__value">Зміна стану компонента</h5>
                    <h3>Для оновлення стану використовується вбудований метод setState().</h3>
                    <p class="selection">setState(updater, callback)</p>
                    <ul>
                      <li><p>Першим, обов'язковим аргументом, передається об'єкт з полями, які вказують, яку частину стану необхідно змінити.</p></li>
                      <li><p>Другим, необов'язковим аргументом, можна передати callback-функцію, яка виконається після зміни стану.</p></li>
                    </ul>
                    <p>
                      class Toggle extends Component { <br>
                        state = { isOpen: false }; <br>
                                             <br>
                        show = () => this.setState({ isOpen: true }); <br>
                                             <br>
                        hide = () => this.setState({ isOpen: false }); <br>
                                             <br>
                        render() { <br>
                          const { isOpen } = this.state; <br>
                          const { children } = this.props; <br>
                         <br>
                          return ( <br>
                            <> <br>
                              < button onClick={this.show}>Show< /button> <br>
                              < button onClick={this.hide}>Hide< /button> <br>
                              {isOpen && children} <br>
                            </> <br>
                          ); <br>
                        } <br>
                      } <br>
                    </p>
                    <p>
                      Під час виклику setState() не потрібно передавати всі властивості, що зберігаються у стані. Достатньо вказати лише ту частину (зріз) стану, яку ми хочемо змінити у цій операції.
                    </p>
                    <p>
                      Актуальний стан і пропси на момент асинхронного виконання функції, переданої в setState(), будуть передані в неї аргументами state і props. Таким чином, можна бути впевненими у коректному значенні попереднього стану під час створення наступного.
                    </p>
                    

                    <h5 class="section-title__value">setState з функцією нове значення обчислюється на підставі попереднього стану (prevState -попередній стан)</h5>
                  <p></p>
                  <div class="section-box exemplar">

                      <p >
                        // Припустимо, що є такий стан <br>
                        state = { value: 0 }; <br>
                        <br>
                        // Запустимо цикл і створимо 3 операції оновлення <br>
                        for (let i = 0; i < 3; i += 1) { <br>
                          // Якщо переглянути стан, на всіх ітераціях буде 0 <br>
                          // Тому що це синхронний код та оновлення стану ще не відбулося <br>
                          console.log(this.state.value); // 0 <br>
                        <br>
                          this.setState(prevState => { <br>
                            // Якщо переглянути стан, переданий callback-функції під час її виклику, <br>
                            // отримаємо актуальний стан на момент оновлення. <br>
                            console.log(prevState.value); // буде різний на кожній ітерації <br>
                          <br>
                            return { value: prevState.value + 1 }; <br>
                          }); <br>
                        } <br>
                      </p>
                      <p>
                        Тепер можемо замінити функціонал відкрити/закрити у компоненті <Toggle>. <br>
                        <br>
                        class Toggle extends Component { <br>
                          state = { isOpen: false }; <br>
                          <br>
                          toggle = () => { <br>
                            this.setState(state => ({ isOpen: !state.isOpen })); <br>
                          }; <br>
                          <br>
                          render() { <br>
                            const { isOpen } = this.state; <br>
                            const { children } = this.props; <br>
                          <br>
                            return ( <br>
                              < div> <br>
                                < button onClick={this.toggle}>{isOpen ? "Hide" : "Show"}< /button> <br>
                                {isOpen && children} <br>
                              < /div> <br>
                            ); <br>
                          } <br>
                        } <br>
                      </p>
                    </div>

                    <h5 class="section-title__value">Підіймання стану (зміна стану батька під час події в дитині)</h5>
                  <p>
                    Оскільки React використовує односпрямований потік даних зверху вниз, для того щоб змінити стан батька під час події в дитині, використовується наступний патерн з callback-функцією.
                  </p>
                  <ul>
                    <li>
                      <p>У батька є стан і метод, який його змінює.</p>
                    </li>
                    <li>

                      <p>Дочірньому елементу у формі пропу передається метод батька, що змінює стан батька.</p>
                    </li>
                    <li>

                      <p>У дочірньому елементі відбувається виклик переданого йому методу. – Під час виклику цього методу змінюється стан батька.</p>
                    </li>
                    <li>

                      <p>Відбувається рендер піддерева компонентів батька.</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    // Button отримує функцію changeMessage (ім'я пропа), <br>
                    // яка викликається під час події onClick <br>
                    const Button = ({ changeMessage, label }) => ( <br>
                      < button type="button" onClick={changeMessage}> <br>
                        {label} <br>
                      < /button> <br>
                    ); <br>
                     <br>
                    class App extends Component { <br>
                      state = { <br>
                        message: new Date().toLocaleTimeString(), <br>
                      }; <br>
                     <br>
                      // Метод, який будемо передавати в Button для виклику під час кліку <br>
                      updateMessage = evt => { <br>
                        console.log(evt); // Доступний об'єкт події <br>
                        this.setState({ <br>
                          message: new Date().toLocaleTimeString(), <br>
                        }); <br>
                      }; <br>
                     <br>
                      render() { <br>
                        return ( <br>
                          <> <br>
                            < span>{this.state.message}< /span> <br>
                            < Button label="Change message" changeMessage={this.updateMessage} /> <br>
                          </> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>

                  <h5 class="section-title__value">Типи внутрішніх даних компонента-класу</h5>
                  <ul>
                    <li>
                      <h3>static data</h3> – статичні властивості і методи, до яких необхідно отримувати доступ без екземпляра.
                    </li>
                    <li>
                      <h3>this.state.data</h3> – динамічні дані, що змінюються методами компонента, стан.
                    </li>
                    <li>
                      <h3>this.data</h3> – дані, які будуть різні для кожного екземпляра.
                    </li>
                    <li>
                      <h3>const DATA</h3> – константи, дані, які не змінюються, та однакові для всіх екземплярів.
                    </li>
                  </ul>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Форми -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Форми</h3>
          <h3>Модуль 2_2</h3>
          <h3>Модуль 2_3 Formik</h3>
          <a href="https://formik.org/" target="_blank" rel="noopener noreferrer">Formik Створюйте форми в React</a>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Неконтрольовані елементи -->
            <li>
              <h4 class="section-title__name">Неконтрольовані елементи</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Такий прийом доречно використовувати, коли дані полів форми потрібні тільки під час її сабміту.</h5>
                  <p>отримати дані користувача</p>
                  <p class="exemplar">
                    class LoginForm extends Component { <br>
                      handleSubmit = evt => { <br>
                        evt.preventDefault(); <br>
                        const form = evt.currentTarget; <br>
                        const login = form.elements.login.value; <br>
                        const password = form.elements.password.value; <br>
                        console.log(login, password); <br>
                        this.props.onSubmit({ login, password }); <br>
                        form.reset(); <br>
                      }; <br>
                      <br>
                      render() { <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            < input type="text" name="login" /> <br>
                            < input type="password" name="password" /> <br>
                            < button type="submit">Login< /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                    <br>
                    ReactDOM.render( <br>
                      < LoginForm onSubmit={values => console.log(values)} />, <br>
                      document.getElementById("root") <br>
                    ); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Контрольовані елементи -->
            <li>
              <h4 class="section-title__name">Контрольовані елементи</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Якщо значення елементів форм необхідно отримати в момент зміни поля і зробити щось динамічно</h5>
                  <p>Якщо значення елементів форм необхідно отримати в момент зміни поля і зробити щось динамічно, вони повинні бути контрольовані. Тобто значення всіх полів повинні бути в state. Цей прийом роботи з елементами форм – досить простий.</p>
                  <p>
                    Поле в state визначає значення атрибуту value поля <br>
                    Події onChange передається метод, що змінює поле в стані <br>
                    Отримуємо замкнене коло. <br>
                                       <br>
                    Під час події onChange метод класу оновлює поле в стані <br>
                    Під час зміни стану відбувається ререндер <br>
                    Інпут відображається з оновленими даними <br>
                    Недолік у тому, що вся форма буде повторно рендеритися під час кожної зміни будь-якого поля, але для невеликих форм – це не проблема. <br>
                  </p>
                  <p class="exemplar">
                    class App extends Component { <br>
                      state = { <br>
                        inputValue: "", <br>
                      }; <br>
                     <br>
                      handleChange = evt => { <br>
                        this.setState({ inputValue: evt.target.value }); <br>
                      }; <br>
                     <br>
                      render() { <br>
                        const { inputValue } = this.state; <br>
                        return ( <br>
                          < input type="text" value={inputValue} onChange={this.handleChange} /> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Складні форми -->
            <li>
              <h4 class="section-title__name">Складні форми</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Створимо форму реєстрації.</h5>
                  <p class="exemplar">
                    // Виносимо об'єкт із примітивами в константу, щоб було зручно скидати. <br>
                    // Не можна використовувати, якщо в якійсь властивості стану зберігається складний тип. <br>
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                    }; <br>
                     <br>
                    class SignUpForm extends React.Component { <br>
                      state = { ...INITIAL_STATE }; <br>
                     <br>
                      // Для всіх інпутів створюємо один обробник <br>
                      // Розрізняти інпути будемо за атрибутом name <br>
                      handleChange = evt => { <br>
                        const { name, value } = evt.target; <br>
                        this.setState({ [name]: value }); <br>
                      }; <br>
                     <br>
                      handleSubmit = evt => { <br>
                        evt.preventDefault(); <br>
                        const { login, email, password } = this.state; <br>
                        console.log(`Login: ${login}, Email: ${email}, Password: ${password}`); <br>
                        this.props.onSubmit({ ...this.state }); <br>
                        this.reset(); <br>
                      }; <br>
                     <br>
                      reset = () => { <br>
                        this.setState({ ...INITIAL_STATE }); <br>
                      }; <br>
                     <br>
                      render() { <br>
                        const { login, email, password } = this.state; <br>
                       <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            < label> <br>
                              Name <br>
                              < input <br>
                                type="text" <br>
                                placeholder="Enter login" <br>
                                name="login" <br>
                                value={login} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                            < label> <br>
                              Email <br>
                              < input <br>
                                type="email" <br>
                                placeholder="Enter email" <br>
                                name="email" <br>
                                value={email} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                            < label> <br>
                              Password <br>
                              < input <br>
                                type="password" <br>
                                placeholder="Enter password" <br>
                                name="password" <br>
                                value={password} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                              <br>
                            < button type="submit">Sign up as {login}< /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Генерація Id елементів форми -->
            <li>
              <h4 class="section-title__name">Генерація Id елементів форми</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">label  та input кожної форми повинні мати одинаковий ІД</h5>
                  <p>
                    Доступність (accessibility, a11y) – дуже важлива тема в сучасному вебі. HTML-атрибут for тегу label допомагає асистивним технологіям та іншим допоміжним інструментам. В React він представлений jsx-атрибутом htmlFor. <br>
                                       <br>
                    Для генерації унікальних ідентифікаторів елементів форм використовується наступний підхід: для кожного екземпляра компонента, під час його ініціалізації, створюється набір унікальних ідентифікаторів, що зберігаються на екземплярі. Таким чином, між різними формами одержуємо унікальні id. <br>
                  </p>
                  <p class="exemplar">
                    // Можна використовувати будь-який пакет для генерації унікальних рядків <br>
                    import { nanoid } from "nanoid"; <br>
                    <br>
                    class Form extends React.Component { <br>
                      loginInputId = nanoid(); <br>
                      <br>
                      render() { <br>
                        return ( <br>
                          < form> <br>
                            < label htmlFor={this.loginInputId}>Login< /label> <br>
                            < input type="text" name="login" id={this.loginInputId} /> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Чекбокси -->
            <li>
              <h4 class="section-title__name">Чекбокси</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Робота з чекбоксами – проста та зрозуміла. Чекбокс може бути всього у 2-х станах: true або false. <br>
                                       <br>
                    Особливості чекбоксів: <br>
                                       <br>
                    Ім'я атрибута, якому передається поточне значення зі state. Для чекбоксів – це checked, і передаємо туди буль <br>
                    Під час обробки події onChange, для отримання значення, в об'єкті події звертаємось до властивості event.target.checked <br>
                    Якщо чекбокс повинен зберігати значення, його можна повісити на атрибут value і прочитати з об'єкта події <br>

                  </p>
                  <p class="exemplar">
                    Додамо до нашої форми реєстрації чекбокс для підтвердження згоди користувача, і зробимо кнопку сабміту неактивною, доки неактивний чекбокс. <br>
                                      <br>
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                      agreed: false, <br>
                    }; <br>
                    <br>
                    class SignUpForm extends React.Component { <br>
                      state = { <br>
                        ...INITIAL_STATE, <br>
                      }; <br>
                    <br>
                      handleChange = evt => { <br>
                        const { name, value, type, checked } = evt.target; <br>
                        // Якщо тип елемента – checkbox, беремо значення checked, <br>
                        // в іншому випадку – value <br>
                        this.setState({ [name]: type === "checkbox" ? checked : value }); <br>
                      }; <br>
                    <br>
                      handleSubmit = e => { <br>
                        e.preventDefault(); <br>
                        const { login, email, password, agreed } = this.state; <br>
                        console.log( <br>
                          `Login: ${login}, Email: ${email}, Password: ${password}, Agreed: ${agreed}` <br>
                        ); <br>
                      <br>
                        /* ... */ <br>
                      }; <br>
                    <br>
                      render() { <br>
                        const { login, email, password, agreed } = this.state; <br>
                        <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            {/* ... */} <br>
                            < label> <br>
                              Agree to terms <br>
                              < input <br>
                                type="checkbox" <br>
                                checked={agreed} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                              <br>
                            < button type="submit" disabled={!agreed}> <br>
                              Sign up as {login} <br>
                            < /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Радіокнопки -->
            <li>
              <h4 class="section-title__name">Радіокнопки</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    На відміну від звичного групування за значенням атрибуту name, в React радіокнопка – це лише елемент інтерфейсу, який: <br>
                                       <br>
                    Знає, чи він вибраний <br>
                    Може попросити форму змінити виділення <br>
                    Зазвичай у радіокнопок є і атрибут checked і value. Наприклад, радіокнопка, що відповідає за вибір статі користувача. <br>
                                       <br>
                    < input <br>
                      type="radio" <br>
                      checked={this.state.gender === "male"} <br>
                      value="male" <br>
                      onChage={this.handleGenderChage} <br>
                    /> <br>
                  </p>
                  <p class="exemplar">
                    Додамо групу радіокнопок у нашу форму. <br>
                    <br>
                    // Використовуємо Enumerable, щоб не створювати антипатерн "магічні рядки" <br>
                                      <br>
                    const Gender = { <br>
                      MALE: "male", <br>
                      FEMALE: "female", <br>
                    }; <br>
                    <br>
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                      agreed: false, <br>
                      gender: null, <br>
                    }; <br>
                    <br>
                    class SignUpForm extends React.Component { <br>
                      state = { <br>
                        ...INITIAL_STATE, <br>
                      }; <br>
                    <br>
                      /*... */ <br>
                    <br>
                      render() { <br>
                        const { login, email, password, agreed, gender } = this.state; <br>
                      <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            {/* ... */} <br>
                      <br>
                            < section> <br>
                              < h2>Choose your gender< /h2> <br>
                              < label> <br>
                                Male <br>
                                < input <br>
                                  type="radio" <br>
                                  checked={gender === Gender.MALE} <br>
                                  name="gender" <br>
                                  value={Gender.MALE} <br>
                                  onChange={this.handleChange} <br>
                                /> <br>
                              < /label> <br>
                              < label> <br>
                                Female <br>
                                < input <br>
                                  type="radio" <br>
                                  checked={gender === Gender.FEMALE} <br>
                                  name="gender" <br>
                                  value={Gender.FEMALE} <br>
                                  onChange={this.handleChange} <br>
                                /> <br>
                              < /label> <br>
                            < /section> <br>
                      <br>
                            < button type="submit" disabled={!agreed}> <br>
                              Sign up as {login} <br>
                            < /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Селект -->
            <li>
              <h4 class="section-title__name">Селект</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>Все просто – є селект, є опції, у селекта є value та onChange. Додаємо вибір вікової категорії.</p>
                  <p class="exemplar">
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                      agreed: false, <br>
                      gender: null, <br>
                      age: "", <br>
                    }; <br>
                      <br>
                    class SignUpForm extends React.Component { <br>
                      state = { <br>
                        ...INITIAL_STATE, <br>
                      }; <br>
                      <br>
                      /* ... */ <br>
                      <br>
                      render() { <br>
                        const { login, email, password, agreed, gender, age } = this.state; <br>
                          <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            {/* ... */} <br>
                              <br>
                            < label> <br>
                              Choose your age <br>
                              < select name="age" value={age} onChange={this.handleChange}> <br>
                                < option value="" disabled> <br>
                                  ... <br>
                                < /option> <br>
                                < option value="18-25">18-25< /option> <br>
                                < option value="26-35">26-35< /option> <br>
                                < option value="36+">36+< /option> <br>
                              < /select> <br>
                            < /label> <br>
                              <br>
                            < button type="submit" disabled={!agreed}> <br>
                              Sign up as {login} <br>
                            < /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Життєвий цикл -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Життєвий цикл</h3>
          <h3>Модуль 3_1 (+модалка)</h3>
          <p>
            Всього є сім методів життєвого циклу, якщо не рахувати render і constructor. На практиці, в більшості повсякденних завдань використовують три: componentDidMount, componentDidUpdate і componentWillUnmount.
            <br>
            Існує кілька стадій життєвого циклу – монтування, оновлення та розмонтування. Під час кожної з них у компонента-класу викликаються методи, що наслідуються від React.Component. Ми можемо перевизначити їхню поведінку, додавши необхідний функціонал в рамках встановлених правил.
          </p>
          <img src="./img/react/react-life-cycle.jpg" width="600" alt="" />
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Стадія монтування -->
            <li>
              <h4 class="section-title__name">Стадія монтування</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentDidMount() {}</h5>
                  <ul>
                    <li>
                      <p>Викликається відразу після монтування компонента в DOM</p>
                    </li>
                    <li>
                      <p>Робимо HTTP-запити, вішаємо кастомні слухачі подій та виконуємо операції з DOM деревом</p>
                    </li>
                    <li>
                      <p>Виклик setState() у цьому методі викличе повторний рендер – це нормально</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    async componentDidMount() { <br>
                      const response = await axios.get("/search?query=react"); <br>
                      this.setState({ articles: response.data.hits }); <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Стадія оновлення -->
            <li>
              <h4 class="section-title__name">Стадія оновлення</h4>
              <p>Оновлення може бути викликано зміною state самого компонента або props, що йому передаються. Під час оновлення необхідно перерендерити компонент</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentDidUpdate(prevProps, prevState, snapshot) {}</h5>
                  <ul>
                    <li>
                      <p>Викликається відразу після оновлення компонента в DOM</p>
                    </li>
                    <li>
                      <p>Не викликається при початковому рендері компонента</p>
                    </li>
                    <li>
                      <p>Можна викликати setState(), обов'язково обгорнувши його в умову перевірки зміни попередніх і наступних props або state, щоб не виник нескінченний цикл ререндера (вкладка зависне або впаде).</p>
                    </li>
                    <li>
                      <p>Можна робити HTTP-запити</p>
                    </li>
                    <li>
                      <p>Якщо в компоненті є getSnapshotBeforeUpdate(), то значення, що повертається їм, буде передане третім аргументом snapshot, в іншому випадку його значенням буде undefined</p>
                    </li>
                  </ul>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Стадія розмонтування -->
            <li>
              <h4 class="section-title__name">Стадія розмонтування</h4>
              <p>У якийсь момент компонент буде видалений з DOM. При цьому викликається наступний метод.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentWillUnmount() {}</h5>
                  <ul>
                    <li>
                      <p>Викликається перед розмонтуванням та видаленням елемента з DOM</p>
                    </li>
                    <li>
                      <p>Добре підходить для прибирання за собою: слухачі, таймери, HTTP-запити. В іншому випадку будуть витоки пам'яті</p>
                    </li>
                    <li>
                      <p>Викликати setState() немає сенсу, компонент ніколи не перерендериться</p>
                    </li>
                  </ul>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Обробка помилок рендеру -->
             <li>
              <h4 class="section-title__name">Обробка помилок рендеру</h4>
              <p>React дуже любить класти весь застосунок за будь-якої помилки. Метод componentDidCatch спрацьовує у разі помилки у дочірньому компоненті та дозволяє батьківським компонентам відловлювати помилки у дітей, відображаючи запасний інтерфейс. В результаті, у разі помилки, інтерфейс не падає.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentDidCatch(error, info) {}</h5>
                  <ul>
                    <li>
                      <p>Використовується для контролю помилок</p>
                    </li>
                    <li>
                      <p>Ловить помилки лише у дітей, але не в самому батьку</p>
                    </li>
                    <li>
                      <p>error – результат toString() об'єкта помилки</p>
                    </li>
                    <li>
                      <p>info – об'єкт, що описує stack trace</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    class ErrorBoundary extends React.Component { <br>
                      state = { hasError: false }; <br>
                                         <br>
                      componentDidCatch(error, info) { <br>
                        // Якщо метод був викликаний, отже, є помилка! <br>
                        // Встановлюємо стан <br>
                        this.setState({ hasError: true }); <br>
                        // Також можна надіслати звіт про помилку вашому аналітичному сервісу <br>
                        // logErrorToMyService(error, info); <br>
                      } <br>
                     <br>
                      render() { <br>
                        // Якщо є помилка... <br>
                        if (this.state.hasError) { <br>
                          // Рендеримо fallback UI <br>
                          return < h1>Something went wrong, please try again later :(< /h1>; <br>
                        } <br>
                       <br>
                        // Якщо все ок, рендеримо дітей <br>
                        return this.props.children; <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- HTTP-запити -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">HTTP-запити</h3>
          <h3>Модуль 3_2</h3>
       
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!--  -->
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                     <p>
            Який саме компонент в ієрархії повинен відповідати за HTTP-запити і зберігання результату відповіді? Якщо не використовуємо бібліотеку управління станом, то це залежить від трьох критеріїв. <br>
                       <br>
            Яким компонентам будуть необхідні отримані дані? <br>
            Де буде рендеритися індикатор завантаження, доки виконується HTTP-запит? <br>
            Де буде рендеритися повідомлення у разі помилки HTTP-запиту? <br>
            Методи життєвого циклу componentDidMount та componentDidUpdate ідеально підходять для HTTP-запитів. Коли викликається componentDidMount(), компонент вже був відрендерений у DOM і готовий до подальшого оновлення стану. Коли викликається componentDidUpdate(), пропи або стан компонента змінилися, і, можливо, необхідно зробити новий запит, попередньо порівнявши їх, щоб не зациклити рендер компонента. <br>
                       <br>
            Для HTTP-запиту можна використовувати будь-що: XMLHTTPRequest, fetch, axios, superagent тощо. Ми будемо використовувати бібліотеку axios. <br>
          </p>
                  <p>
                    import React, { Component } from "react"; <br>
                    mport axios from "axios"; <br>
                                       <br>
                    xios.defaults.baseURL = "https://hn.algolia.com/api/v1"; <br>
                                       <br>
                    onst ArticleList = ({ articles }) => ( <br>
                     < ul> <br>
                       {articles.map(({ objectID, url, title }) => ( <br>
                         < li key={objectID}> <br>
                           < a href={url} target="_blank" rel="noreferrer noopener"> <br>
                             {title} <br>
                           < /a> <br>
                         < /li> <br>
                       ))} <br>
                     < /ul> <br>
                    ; <br>
                                       <br>
                    lass App extends Component { <br>
                     state = { <br>
                       articles: [], <br>
                     }; <br>
                   <br>
                     async componentDidMount() { <br>
                       const response = await axios.get("/search?query=react"); <br>
                       this.setState({ articles: response.data.hits }); <br>
                     } <br>
                   <br>
                     render() { <br>
                       const { articles } = this.state; <br>
                       return ( <br>
                         < div> <br>
                           articles.length > 0 ? < ArticleList articles={articles} /> : null <br>
                         < /div> <br>
                       ); <br>
                     } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Індикатор завантаження (Спінер, Лоадер) -->
            <li>
              <h4 class="section-title__name">Індикатор завантаження (Спінер, Лоадер)</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Доки чекаємо на відповідь на HTTP-запит, показуємо індикатор завантаження. Щойно надійшла відповідь, ховаємо індикатор. Для цього, на старті запиту ставимо isLoading – true, а у разі успішної відповіді або помилки – false.
                  </p>
                  <p class="exemplar">
                    /* ... */ <br>
                                       <br>
                    class App extends Component { <br>
                      state = { <br>
                        articles: [], <br>
                        isLoading: false, <br>
                      }; <br>
                     <br>
                      async componentDidMount() { <br>
                        this.setState({ isLoading: true }); <br>
                        const response = await axios.get("/search?query=react"); <br>
                        this.setState({ <br>
                          articles: response.data.hits, <br>
                          isLoading: false, <br>
                        }); <br>
                      } <br>                   
                    <br>
                    В методі render за умовою повертаємо розмітку. Якщо дані завантажуються, показуємо лоадер, в іншому випадку – список з результатами. <br>
                    <br>
                    render() { <br>
                      const { articles, isLoading } = this.state; <br>
                      return ( <br>
                        < div> <br>
                          isLoading ? < p>Loading...< /p> : < ArticleList articles={articles} /> <br>
                        < /div> <br>
                      ); <br>
                    } <br>
                  </p>
                  <p>
                    Індикатор завантаження може бути будь-чим: від простого тексту або спінера до кастомного компонента, наприклад react-content-loader.
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Обробка помилки -->
            <li>
              <h4 class="section-title__name">Обробка помилки</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    HTTP-запит не завжди виконується без помилок, тому користувачеві обов'язково потрібно дати зрозуміти, якщо щось пішло не так. Для цього у стан додаємо властивість зберігання помилки. <br>
                                       <br>
                    При використанні промісів для обробки помилок використовується блок catch, якщо він виконається, значить, сталася помилка. Встановлення індикатора завантаження переносимо в блок finally, щоб не дублювати код, який буде виконаний в будь-якому випадку. <br>
                  </p>
                  <p class="exemplar">
                    /* ... */ <br>
                                       <br>
                    class App extends Component { <br>
                      state = { <br>
                        articles: [], <br>
                        isLoading: false, <br>
                        error: null, <br>
                      }; <br>
                     <br>
                      async componentDidMount() { <br>
                        this.setState({ isLoading: true }); <br>
                       <br>
                        try { <br>
                          const response = await axios.get("/search?query=react"); <br>
                          this.setState({ articles: response.data.hits }); <br>
                        } catch (error) { <br>
                          this.setState({ error }); <br>
                        } finally { <br>
                          this.setState({ isLoading: false }); <br>
                        } <br>
                      } <br>
                     <br>
                      render() { <br>
                        const { articles, isLoading, error } = this.state; <br>
                       <br>
                        return ( <br>
                          < div> <br>
                            {error && < p>Whoops, something went wrong: {error.message}< /p>} <br>
                            {isLoading && < p>Loading...< /p>} <br>
                            {articles.length > 0 && < ArticleList articles={articles} />} <br>
                          < /div> <br>
                        ); <br>
                      } <br>
                    } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Поділ відповідальності -->
              <li>
              <h4 class="section-title__name">Поділ відповідальності</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Зберігати код, пов'язаний з HTTP-запитом, безпосередньо в компоненті – не найкраща практика. У застосунку буде багато різних запитів до API і вони будуть використовуватися у різних компонентах. До того ж код HTTP-запитів може бути складним та громіздким. Для зручності рефакторингу будемо все зберігати в одному місці. <br>
                                       <br>
                    Створимо додаткову папку всередині src. Назва папки довільна, але логічна, наприклад helpers, api, services тощо. У цій папці будемо зберігати файл з функціями для HTTP-запитів. <br>
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      // services/api.js <br>
                      import axios from "axios"; <br>
                                           <br>
                      export const fetchArticlesWithQuery = async searchQuery => { <br>
                        const response = axios.get(`/search?query=${searchQuery}`); <br>
                        return response.data.hits; <br>
                      }; <br>
                       <br>
                      export default { <br>
                        fetchArticlesWithQuery, <br>
                      }; <br>
                    </p>
                    <p>
                      /* ... */ <br>
                      import api from "./path/to/services/api"; <br>
                                           <br>
                      class App extends Component { <br>
                        state = { <br>
                          articles: [], <br>
                          isLoading: false, <br>
                          error: null, <br>
                        }; <br>
                       <br>
                        async componentDidMount() { <br>
                          this.setState({ isLoading: true }); <br>
                         <br>
                          try { <br>
                            const articles = api.fetchArticlesWithQuery("react"); <br>
                            this.setState({ articles }); <br>
                          } catch (error) { <br>
                            this.setState({ error }); <br>
                          } finally { <br>
                            this.setState({ isLoading: false }); <br>
                          } <br>
                        } <br>
                       <br>
                        /* ... */ <br>
                      } <br>
                    </p>
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Хуки -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Хуки</h3>
          <h3>Модуль 4_1</h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Хук useState -->
            <li>
              <h4 class="section-title__name">Хук useState</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">const [value, setValue] = useState(defaultne значення наприклад null);</h5>
                  <p>Перший, простий і найважливіший хук. З назви зрозуміло, що він пов'язаний з станом компонента. Саме завдяки йому у функціональних компонентів з'явився внутрішній стан.</p>
                  <h3>value</h3>
                  <p>записується значення в стейт</p>
                  <h3>setValue</h3>
                  <p>функція яка записує значення value</p>
                  <p class="exemplar">
                    import { useState } from "react"; <br>
                                       <br>
                    const App = () => { <br>
                      const [value, setValue] = useState(0); <br>
                     <br>
                      return ( <br>
                        < div> <br>
                          {value} <br>
                          < button type="button" onClick={() => setValue(value + 1)}> <br>
                            Increment value by 1 <br>
                          < /button> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
 </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Хук useEffect -->
            <li>
              <h4 class="section-title__name">Хук useEffect</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"> useEffect(() => { ... }, []);</h5>
                  <h3>useEffect(callback, deps) приймає два аргументи:</h3>
                  <div>
                    <h3>callback</h3>
                    <p>- функція, усередині якої виконується вся логіка ефекту.</p>
                    <h3>deps</h3>
                    <p>- масив змінних, при зміні будь-якого з яких, буде запускатися ефект і виконуватися callback.</p>
                  </div>
                  <p>За допомогою хука useEffect можна змоделювавши роботу трьох методів життєвого циклу - componentDidMount, componentDidUpdate, componentWillUnmount, об'єднавши їх в один API.</p>
                  <p class="exemplar">
                    import { useState, useEffect } from "react"; <br>
                                       <br>
                    const App = () => { <br>
                      const [value, setValue] = useState(0); <br>
                     <br>
                      useEffect(() => { <br>
                        document.title = `You clicked ${value} times`; <br>
                      }); <br>
                     <br>
                      return ( <br>
                        < div> <br>
                          < p>You clicked {value} times< /p> <br>
                          < button onClick={() => setValue(value + 1)}>Click me< /button> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Запускатиметься кожен рас при зміні стейта або пропсів</h5>
                  <h3>  useEffect(() => { ... });</h3>
                  <h5 class="section-title__value">Аналог componentDidMount (запуститься тільки раз)</h5>
                  <h3>  useEffect(() => { ... }, []);</h3>
                  <p></p>
                  <h5 class="section-title__value">Аналог componentDidUpdate (запускатиметься кожен рас при зміні стейту - value)</h5>
                  <h3>  useEffect(() => { ... }, [value]);</h3>
                  <p>У масиві потрібно перерахувати всі залежності ефекту. Так отримуємо більш гнучкий аналог методу componentDidUpdate, який запускається тільки за зміні певних значень. При цьому важливо враховувати, що такий ефект запускається і на стадії монтування, що абсолютно нормально у більшості випадків.</p>
                  <h5 class="section-title__value">Аналог componentWillUnmount </h5>
                  <h3>return () => { ... }</h3>
                  <p>
                    Для того, щоб виконати код при розмонтуванні компонента, або взагалі перед кожним викликом ефекту, повертаємо з useEffect функцію очищення з необхідним кодом. Це і є аналог componentWillUnmount. Так можна знімати обробники подій, зупиняти таймери та скасовувати HTTP-запити.
                  </p>
                  <p class="exemplar">
                    const App = () => { <br>
                      useEffect(() => { <br>
                        console.log("Mounting phase: same when componentDidMount runs"); <br>
                       <br>
                        return () => { <br>
                          console.log("Unmounting phase: same when componentWillUnmount runs"); <br>
                        }; <br>
                      }, []); <br>
                     <br>
                      return null; <br>
                    }; <br>
                  </p>
                  <h4>Хуки дозволяють розділити та згрупувати логіку, створивши useEffect(() => {...}, [value]) під кожну незалежну операцію. Тобто useEffect можна створювати скільки завгодно в компоненті, хоч і під кожен стейт.</h4>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Власні хуки -->
            <li>
              <h4 class="section-title__name">Власні хуки</h4>
              <p>
                Першочергове завдання хуків - спростити повторне використання коду (логіки) для розробників. Створення власних хуків це процес отримання логіки компонентів у повторно використовувані функції. Це зробить код проекту чистішим і легше у підтримці. <br>
                               <br>
                Хук це просто функція, ім'я якої обов'язково починається з приставки use. Саме по ній React визначатиме це звичайна функція чи хук. Наприклад: useState, useEffect, useToggle, useDevice, useImages і так далі. Власні хуки створюються поза тілом компонента, часто навіть в окремих файлах, та можуть викликати інші хуки, так досягається просте повторне використання коду. <br>
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Хук useToggle</h5>
                  <p>Розглянемо приклад де у двох компонентах необхідна логіка відкриття, закриття та перемикання елемента інтерфейсу, наприклад модального вікна.</p>
                  <div class="section-box">
                    <p class="exemplar">
                    // ComponentA.jsx <br>
                    const ComponentA = () => { <br>
                      const [isModalOpen, setIsModalOpen] = useState(false); <br>
                      const openModal = () => setIsModalOpen(true); <br>
                      const closeModal = () => setIsModalOpen(false); <br>
                     <br>
                      return ( <br>
                        <> <br>
                          < button onClick={openModal}>Open modal< /button> <br>
                          < ModalA isOpen={isModalOpen} onClose={closeModal} /> <br>
                        </> <br>
                      ); <br>
                    }; <br>
                    </p>
                    <p class="exemplar">
                    // ComponentB.jsx <br>
                    const ComponentB = () => { <br>
                      const [isModalOpen, setIsModalOpen] = useState(false); <br>
                      const openModal = () => setIsModalOpen(true); <br>
                      const closeModal = () => setIsModalOpen(false); <br>
                     <br>
                      return ( <br>
                        <> <br>
                          < button onClick={openModal}>Open modal</> <br>
                          < ModalB isOpen={isModalOpen} onClose={closeModal} /> <br>
                        </> <br>
                      ); <br>
                    }; <br>
                  </p>
                  </div>
                  <p>
                    Створення стану та методів для відкриття/закриття модального вікна ідентично в кожному компоненті, тобто відбувається дублювання коду. Уявіть, що буде в проекті, де модальні вікна відкриваються десятки чи сотні разів. Створимо власний хук useToggle в якому приховаємо створення стану та методів роботи з ним.
                  </p>
                  <p class="exemplar">
                    src/hooks/useToggle.js <br>
                                       <br>
                    export const useToggle = () => { <br>
                      const [isOpen, setIsOpen] = useState(false); <br>
                      const open = () => setIsOpen(true); <br>
                      const close = () => setIsOpen(false); <br>
                      const toggle = () => setIsOpen(isOpen => !isOpen); <br>
                     <br>
                      return { isOpen, open, close, toggle }; <br>
                    }; <br>
                  </p>
                  <p>Тоді код із попереднього прикладу буде виглядати наступним чином.</p>
                 
                  <div class="section-box">
                     <p class="exemplar">
                    // ComponentA.jsx <br>
                    import { useToggle } from "path/to/hooks/useToggle.js"; <br>
                                       <br>
                    const ComponentA = () => { <br>
                      const { isOpen, open, close } = useToggle(); <br>
                     <br>
                      return ( <br>
                        <> <br>
                          < button onClick={open}>Open modal< /button> <br>
                          < ModalA isOpen={isOpen} onClose={close} /> <br>
                        </> <br>
                      ); <br>
                    }; <br>
                  </p>
                    <p class="exemplar">
                    // ComponentB.jsx <br>
                    import { useToggle } from "path/to/hooks/useToggle.js"; <br>
                     <br>
                    const ComponentB = () => { <br>
                      const { isOpen, open, close } = useToggle(); <br>
                     <br>
                      return ( <br>
                        <> <br>
                          < button onClick={open}>Open modal< /button> <br>
                          < ModalB isOpen={isOpen} onClose={close} /> <br>
                        </> <br>
                      ); <br>
                    }; <br>
                  </p>
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Хук useRef -->
            <li>
              <h4 class="section-title__name">Хук useRef</h4>
              <p>
                Рефи дозволяють отримати прямий доступ до DOM-вузлів або React-елементів із шаблону компонента. Вони використовуються якщо необхідно звернутися до імперативних методів та властивостям елемента.
              </p>
              <ul>
                <li>
                  <p>Фокус елемент під час події, виділення тексту</p>
                </li>
                <li>
                  <p>Контроль програвання медіаконтенту</p>
                </li>
                <li>
                  <p>Інтеграція з DOM-бібліотеками</p>
                </li>
                <li>
                  <p>Доступ до DOM-властивостей, значення яких неможливо отримати по-іншому - розміри елемента, значення скрола тощо.</p>
                </li>
              </ul>
              <h4>Тобто якщо нам потрібна якась змінна яка буде зберігати значення яке створене при монтуванні компонента і не буде змінюватися при подальших монтуваннях, плюс якщо буде декілька елементів яким потрібні також фіксоіані стартові значення і щоб в результаті їх можна використати для зупинки якоїсь дії (таймер, відеоплеєр і т д) то ми використовуємо Хук useRef</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Створення</h5>
                  <p>Рефи створюються хуком useRef() та прив'язані до React-елементів за допомогою атрибуту ref (скорочення від reference), який зберігатиме посилання на DOM-елемент.</p>
                  <p class="exemplar">
                    import { useRef } from "react"; <br>
                    <br>
                    const App = () => { <br>
                      const btnRef = useRef(); <br>
                    <br>
                      return < button ref={btnRef}>Button with ref< /button>; <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Життєвий цикл рефа</h5>
                  <p>
                    React надає властивості current посилання на DOM-елемент коли компонент монтується та null при розмонтуванні, тому значення рефа доступне тільки після монтування.
                  </p>
                  <p class="exemplar">
                    import { useState, useRef } from "react"; <br>
                                       <br>
                    const App = () => { <br>
                      const [value, setValue] = useState(0); <br>
                      const btnRef = useRef(); <br>
                     <br>
                      // Буде null на першому рендері <br>
                      // і посиланням на DOM-елемент всі наступні <br>
                      console.log(btnRef.current); <br>
                     <br>
                      useEffect(() => { <br>
                        // Ефект виконується після монтування, <br>
                        // тому завжди буде посиланням на DOM-елемент <br>
                        console.log(btnRef.current); <br>
                      }); <br>
                     <br>
                      const handleClick = () => { <br>
                        // Кліки будуть після монтування, <br>
                        // тому завжди буде посиланням на DOM-елемент <br>
                        console.log(btnRef.current); <br>
                      }; <br>
                     <br>
                      return ( <br>
                        <> <br>
                          < button onClick={() => setValue(value + 1)}> <br>
                            Update value to trigger re-render <br>
                          < /button> <br>
                          < button ref={btnRef} onClick={handleClick}> <br>
                            Button with ref <br>
                          < /button> <br>
                        </> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Відсутність реактивності</h5>
                  <p>Рефи це не стан, тобто вони не реактивні, тому зміна значення рефа не впливає на оновлення компонента і не викликає ре-рендер.</p>
                  <p class="exemplar">
                    import { useEffect, useRef } from "react"; <br>
                                       <br>
                    const App = () => { <br>
                      const valueRef = useRef(0); <br>
                     <br>
                      useEffect(() => { <br>
                        // Виконається лише один раз під час монтування. <br>
                        // Наступні оновлення значення рефа не <br>
                        // викличуть оновлення компонента <br>
                        console.log(valueRef.current); <br>
                      }); <br>
                     <br>
                      const handleClick = () => { <br>
                        valueRef.current += 1; <br>
                      }; <br>
                     <br>
                      return < button onClick={handleClick}>Click to update ref value< /button>; <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Перенаправлення рефів</h5>
                  <p>
                    При використанні рефів на компоненті, проп ref не передається автоматично. Це створює проблеми у випадку коли ми хочемо отримати ref на елемент усередині самого компонента, а не на сам компонент. Функція forwardRef автоматично передає пропси, отримані батьківським компонентом його дочірнім елементам.
                  </p>
                  <p>
                    Такий підхід дозволяє отримати посилання у батьківському компоненті на DOM-елемент усередині іншого компонента. Наприклад, ви створюєте галерею, так можна отримати посилання на DOM-елементи поза них і працювати з їх властивостями, наприклад використовувати метод Element.getBoundingClientRect() і тому подібне.
                  </p>
                  <p class="exemplar">
                    import { forwardRef, useRef, useEffect } from "react"; <br>
                                       <br>
                    const CustomButton = forwardRef((props, ref) => ( <br>
                      < button ref={ref}>{props.children}< /button> <br>
                    )); <br>
                                       <br>
                    const App = () => { <br>
                      const btnRef = useRef(); <br>
                     <br>
                      useEffect(() => btnRef.current.focus(), []); <br>
                     <br>
                      return < CustomButton ref={btnRef}>Button with forwarded ref< /CustomButton>; <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Простий відеоплеєр</h5>
                  <p>
                    Створимо компонент Player для програвання відео, використовуючи нативний тег < video>. Щоб запустити та зупинити програвання необхідно викликати методи HTMLMediaElement.play() та HTMLMediaElement.pause(), де HTMLMediaElement це елемент < video>. Використовуємо реф для отримання доступу до DOM-елементу та його методам.
                  </p>
                  <p class="exemplar">
                    import { useRef } from "react"; <br>
                                       <br>
                    const Player = ({ source }) => { <br>
                      const playerRef = useRef(); <br>
                      const play = () => playerRef.current.play(); <br>
                      const pause = () => playerRef.current.pause(); <br>
                     <br>
                      return ( <br>
                        < div> <br>
                          < video ref={playerRef} src={source}> <br>
                            Sorry, your browser does not support embedded videos. <br>
                          < /video> <br>
                          < div> <br>
                            < button onClick={play}>Play< /button> <br>
                            < button onClick={pause}>Pause< /button> <br>
                          < /div> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                     <br>
                    const App = () => { <br>
                      return < Player source="http://media.w3.org/2010/05/sintel/trailer.mp4" />; <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Хук useMemo -->
            <li>
              <h4 class="section-title__name">Хук useMemo</h4>
              <p>Використовується для обчислення. Наприклад, при роботі з великим списком співробітників компанії та пошуковим запитом, компонент повинен фільтрувати імена співробітників на запит. У таких випадках можна спробувати покращити продуктивність компонента за допомогою мемоізації.</p>
              <h4>Мемоізація</h4>
              <p>
                Метод оптимізації, який використовується для прискорення комп'ютерних програм шляхом збереження результатів викликів функції та повернення кешованого результату при повторенні тих самих вхідних даних. Мемоізована функція «запам'ятовує» результат обчислень відповідний набору аргументів. Наступні виклики з такими самими значеннями аргументів повертають запам'ятаний результат, а не перераховують його. <br>
                Хук useMemo() використовує концепцію мемоізації, тобто повертає пам'ятний (кешований) результат обчислень. Це може покращити продуктивність програми, якщо використовується для запобігання дорогим обчисленням на кожному рендері. <br>
              </p>
              <h4>Тобто, useMemo(compute, deps) робить якісь обчислення (пошук в списку і т п), він запускається перший раз при монтуванні робить обчислення і записує данні в змінну, потім якщо не змінюються данні в переданих йому залежностях то він при слідуючих монтуваннях передає запам'ятаний в цій змінній результат. І обчислення він заново робить тільки тоді коли зміняться данні в переданих йому залежностях [name, value]</h4>
              <p>Хук приймає два аругменти:</p>
              <h3>compute</h3>
              <p>- анонімну функцію, яка має повернути значення (compute), саме вона буде мемоізована</p>
              <h3>deps</h3>
              <p>- масив залежностей</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">const filteredPlanets = useMemo(() => {...}, [planets, query] );</h5>
                  <p>
                    При першому рендері компонента викликається функція (compute), запам'ятовується її результат та повертається як результат роботи хука. Якщо за наступних рендерів залежності не змінюються, то хук не викликає функції, а просто повертає збережений результат роботи. Якщо будь-яка залежність змінилася, то хук викликає функцію заново, запам'ятовує нове значення та повертає його.
                  </p>
                  <p class="exemplar">
                    Щоразу коли зміниться стан clicks або проп someProp, компонент буде відрендерен повторно, що не призведе до обчислення filteredPlanets, тому, що значення planets та query не змінилися, і тому воно підставить значення яке було обчислено при першому монтуванні! <br>
                    import { useMemo } from "react"; <br>
                                       <br>
                    const App = ({ someProp }) => { <br>
                      const [planets, setPlanets] = useState(["Earth", "Mars", "Jupiter", "Venus"]); <br>
                      const [query, setQuery] = useState(""); <br>
                      const [clicks, setClicks] = useState(0); <br>
                     <br>
                      const filteredPlanets = useMemo( <br>
                        () => planets.filter(planet => planet.includes(query)), <br>
                        [planets, query] <br>
                      ); <br>
                     <br>
                      return ( <br>
                        < div> <br>
                          < div>Some prop: {someProp}< /div> <br>
                          < button onClick={() => setClicks(clicks + 1)}> <br>
                            Number of clicks: {clicks} <br>
                          < /button> <br>
                          < div> <br>
                            {filteredPlanets.map(planet => ( <br>
                              < div key={planet}>{planet}< /div> <br>
                            ))} <br>
                          < /div> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Хук useReducer -->
              <li>
              <h4 class="section-title__name">Хук useReducer()</h4>
              <h3>Модуль 4_Урок-2/0:50:00</h3>
              <p>Цей хук ми використовуємо коли в нас багато стейтів (від 15)</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">const [total, setTotal] = useReducer(reducer(функція), default(дефаултне значення), fc(функція практично ніколи не використовується))</h5>
                  <p>Хук useReducer() приймає 3 значення</p>
                  <ul>
                    <li>
                      <p>перше ФУНКЦІЯ яку за звичай називають "reducer", і зазвичай виносять в інший файл</p>
                    </li>
                    <li>
                      <p>друге default ДЕФАУЛТНЕ значення </p>
                    </li>
                    <li>
                      <p>третье ДОДАТКОВА ФУНКЦІЯ Практично ніколи не використовується</p>
                    </li>
                  </ul>
                  <p>Функція reducer приймає два параметри function reducer(prevState, nextState) {}, де prevState це попередній стан а nextState актуальний стан. Також nextState за звичай називають action і це є об'єкт в якому є {type: "", payload: 1} </p>
                  
                  <div class="section-box">
                    <p class="exemplar">
                    Приклад простого лічильника, де збільшуємо і зменшуємо значення <br>
                    <br>
                    const Counter = () => { <br>
                      const [total, setTotal] = useReducer(reducer, 0) <br>
                      <br>
                      const handleClickIncrement = () =>  <br>
                      setTotal({type: 'increment', payload: 1}) <br>
                      <br>
                      const handleClickDecrement = () =>  <br>
                      setTotal({type: 'decrement', payload: 1}) <br>
                      <br>
                      // ... /// <br>                    
                    }<br>    
                    <br>    
                    В окремому файлі функція reducer де реалізована логіка<br>    
                    <br>    
                    function reducer(prevState, action) { <br>
                    if (action.type === "increment") {return prevState + action.payload} <br>
                    else if (action.type === "decrement") {return prevState - action.payload} <br>
                    } <br>
                  </p>
                  <p class="exemplar">
                    Коли на потрібно в початковому стані передати великий об'єкт, то передаємо і змінюємо слідуючим методом. <br>
                    <br>
                    const Counter = () => { <br>
                      const [total, dispatch(зазвичай називають функцію)] = useReducer(reducer, {name: user, items: [], age: 18,}) <br>
                      <br>
                      dispatch({ type: 'editUser', payload: 'Alex'}) <br>
                      <br>
                      dispatch({ type: 'pushItems', payload: [1, 2, 3]}) <br>
                      <br>
                      // ... /// <br>                    
                    }<br>
                    <br>
                      В іншому файлі логіка <br>
                      <br>
                        function reducer(prevState, action) { <br>
                    if (action.type === "ediUser") {return ...prevState, name: action.payload} <br>
                    else if (action.type === "pushItems") {return ...prevState, items: [...action.payload]} <br>
                    } <br>
                  </p>
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Контекст та useContext -->
            <li>
              <h4 class="section-title__name">Контекст та useContext</h4>
              <h3>Модуль 4_Урок-2/1:34:00</h3>
              <h4>Контекст дає можливість зв'язати компоненти різної вкладеності без того щоб прокидувати пропси в глибину від їх спільного батька</h4>

              <p>
                Дані передаються зверху вниз через пропси, але це може бути незручно для певних глобальних даних, які потрібні багатьом компонентам на різних рівнях у додатку (локалізація, тема оформлення, стан авторизації та ін.). <br>
                Контекст забезпечує спосіб передачі даних глибоко по дереву компонентів без необхідності явно передавати пропси в проміжні компоненти вручну на кожному рівні. <br>
                Не використовуйте контекст, щоб уникнути передачі пропсів на кілька рівнів вниз. Цей механізм призначений для вузького спектра завдань. <br>
              </p>
              <div class="section-icon section-box">
                  <img src="./img/react/use-context.jpg" width="400" alt="context" />
                  <img src="./img/react/context.jpg" width="400" alt="context" />
                </div>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Функція createContext()</h5>
                  <p>Створює об'єкт контексту</p>
                  <p>
                    import { createContext } from "react"; <br>
                     <br>
                    const MyContext = createContext(); <br>
                  </p>
                  <h5 class="section-title__value">Компонент < Provider></h5>
                  <p>За допомогою раніше створеного нами контексту MyContext та < Provider> огортаємо наші компоненти або одразу App</p>
                  <p>
                    Дозволяє споживачам підписуватись на зміни контексту. Використовується для створення та передачі контексту.
                  </p>
                  <p>
                    import { createContext } from "react"; <br>
                    import ReactDOM from "react-dom/client"; <br>
                                       <br>
                    const MyContext = createContext(defaultValue); <br>
                                       <br>
                    ReactDOM.createRoot(document.getElementById("root")).render( <br>
                      < MyContext.Provider value={/* context value */}> <br>
                        < App /> <br>
                      < /MyContext.Provider> <br>
                    ); <br>
                  </p>
                  <ul>
                    <li>
                      <p>Приймає проп value - значення контексту, яке буде передано нащадкам-споживачам цього контексту.</p>
                    </li>
                    <li>
                      <p>Дозволяє споживачам підписуватись на зміни контексту незалежно від глибини вкладеності.</p>
                    </li>
                    <li>
                      <p>Один провайдер може бути пов'язаний із багатьма споживачами.</p>
                    </li>
                    <li>
                      <p>Провайдери можуть бути вкладені один в одного.</p>
                    </li>
                  </ul>
                  <h5 class="section-title__value">Хук useContext()</h5>
                  <p>Цей хук ми використовуємо в компоненті в якому нам потрібно достукатись до value=(значення стейта) (< MyContext.Provider value={/* state */}>) і зв'язуємо його з раніше нами створеним контекстом MyContext який з провайдером огортає наші компоненти. Таким чином ми отримаємо доступ до стейта в нашому контексті.</p>
                  <p>Дозволяє отримати доступ до поточного значення контексту. Отримує поточний контекст із найближчого порівнянного < Provider> вище у дереві.</p>
                  <p class="exemplar">
                    import { createContext, useContext } from "react"; <br>
                    <br>
                    const MyContext = createContext(); <br>
                    <br>
                    const contextValue = useContext(MyContext); <br>
                  </p>
                  <ul>
                    <li>
                      <p>Очікує єдиний аргумент – посилання на створений контекст.</p>
                    </li>
                    <li>
                      <p>Поверне значення контексту найближчого провайдера для цього контексту вище дереві.</p>
                    </li>
                    <li>
                      <p>Щоразу, коли оновиться значення контексту, залежний компонент ре-рендерується з новим значенням.</p>
                    </li>
                  </ul>
                  <h5 class="section-title__value">Кастомний хук контексту</h5>
                  <h4>Щоб не імпортувати в кожен компонент MyContext  та useContext ми можемо в окремому файлі створити кастомний хук і там їх зв'язати та в подальшому імпотрувати тільки його</h4>
                  <p>Щоразу імпортувати посилання на об'єкт контексту не зручно. Тому робиться кастомний хук для доступу до контексту.</p>
                  <p class="exemplar">
                    import { createContext, useContext } from "react"; <br>
                                       <br>
                    const MyContext = createContext(); <br>
                                       <br>
                    // Імпортуємо та використовуємо цей хук у компонентах <br>
                    export const useMyContext = () => useContext(MyContext); <br>
                  </p>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Обмеження хуків -->
            <li>
              <h4 class="section-title__name">Обмеження хуків</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>Будь-які хуки можна викликати лише на верхньому рівні компонента функції. Тобто, поза циклами, умовами, вкладеними функціями і т.п. Це означає, що хук або є в компоненті, або його немає. Такі, можливо, дивні обмеження стандартизують написання логіки компонента та роблять код менш заплутаним.</p>
                  <p class="exemplar">
                    // ❌ Буде помилка <br>
                    const App = () => { <br>
                      if (isLoggedIn) { <br>
                        const [username, setUsername] = useState(""); <br>
                      } <br>
                     <br>
                      // ... <br>
                    }; <br>
                     <br>
                    // ✅ Так правильно використовувати хуки <br>
                    const App = () => { <br>
                      const [username, setUsername] = useState(""); <br>
                    }; <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Маршрутизація -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Маршрутизація</h3>
          <p>
            Відмінна перевага веб-застосунку від десктопного це наявність URL при переході по якому користувач опиняється у певної частини програми. Так можна зберегти закладку або надіслати посилання іншому користувачеві, при цьому йому буде відображено той самий інтерфейс (за винятком приватних даних).Відмінна перевага веб-застосунку від десктопного це наявність URL при переході по якому користувач опиняється у певної частини програми. Так можна зберегти закладку або надіслати посилання іншому користувачеві, при цьому йому буде відображено той самий інтерфейс (за винятком приватних даних).
          </p>
          <h3></h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Структура URL-рядка -->
            <li>
              <h4 class="section-title__name">Структура URL-рядка</h4>
              <div class="section-icon">
                <img src="./img/react/url-string.jpg" width="600" alt="" />
              </div>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Розберемо з яких частин може складатися будь-який URL.
                  </p>
                  <ul>
                    <li>
                      <p>https:// - протокол</p>
                    </li>
                    <li>
                      <p>mysite.com/ - хост</p>
                    </li>
                    <li>
                      <p>books/e3q76gm9lzk - шлях, то, де ми знаходимося у додатку</p>
                    </li>
                    <li>
                      <p>e3q76gm9lzk - url-параметр. Параметри бувають динамічними або статичними</p>
                    </li>
                    <li>
                      <p>? - символ початку рядка запиту</p>
                    </li>
                    <li>
                      <p>?category=adventure&status=unread - рядок запиту</p>
                    </li>
                    <li>
                      <p>category=adventure - пара параметр=значення</p>
                    </li>
                    <li>
                      <p>& - символ "І", розділяє параметри рядка запиту</p>
                    </li>
                    <li>
                      <p>#comments - якір (хеш), визначає положення на сторінці</p>
                    </li>
                  </ul>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
              </div>
            </li>
            <!-- Історія навігації -->
            <li>
              <h4 class="section-title__name">Історія навігації</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>Історія навігації описує, як ми переходимо по маршрутах (посиланням) додатків в поточній вкладці браузера, і, як ці переходи зберігаються та обробляються. Уявіть стопку листів, щоразу коли ми переходимо за посиланням, на верх стопки додається ще один лист з інформацією. Це називається стек історії. Використовуючи властивості та методи HTML5 History API, ми можемо переходити назад і вперед з історії користувача та маніпулювати її вмістом.</p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Маршрутизація в React -->
            <li>
              <h4 class="section-title__name">Маршрутизація в React</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">npm install react-router-dom</h5>
                  <p>У React немає вбудованого модуля маршрутизації, тому використовується <a href="https://reactrouter.com/en/main" target="_blank">React Router</a> - Бібліотека маршрутизації для React. Так само, як React надає нам набір примітивів для створення інтерфейсу користувача та роботи зі станом, React Router надає набір компонентів та хуків для створення маршрутизації, управління історією навігації користувача та відображення різних компонетів в залежності від поточного значення URL в адресному рядку браузера.</p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Компонент <BrowserRouter> -->
            <li>
              <h4 class="section-title__name">Компонент < BrowserRouter ></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>Командний центр управління маршрутизацією, який приховує в собі всю логіку взаємодії із історією браузера. Створює маршуртизатор та об'єкт історії навігації, щоб синхронізувати інтерфейс із URL-адресою. Використовуючи React контекст передає інформацію про поточний стан історії навігації всім нащадкам. Все, що необхідно зробити, це обернути компонентом < BrowserRouter> всі програми.</p>
                  <p class="exemplar">
                    index.js <br>
                    import { BrowserRouter } from "react-router-dom"; <br>
                                       <br>
                    ReactDOM.createRoot(document.getElementById("root")).render( <br>
                      < React.StrictMode> <br>
                        < BrowserRouter> <br>
                          < App /> <br>
                        < /BrowserRouter> <br>
                      < /React.StrictMode> <br>
                    ); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Компоненти <Route> та <Routes> -->
            <li>
              <h4 class="section-title__name">Компоненти < Route> та < Routes></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">< Route path="/about" element={< About />} /></h5>
                  <p>
                    Компонент < Route> дозволяє пов'язати певний URL з деяким компонентом. Наприклад, якщо ми хочемо відображати компонент < About> коли користувач переходить шляхом /about, необхідно буде описати такий маршрут. <br>
                    Значенням пропсу element може бути будь-який валідний JSX, але на практиці використовують лише компоненти.
                  </p>
                  <p>
                    Маршрутів може бути довільна кількість, як мінімум по одному на кожну сторінку програми. Припустимо ми створюємо додаток магазину одягу, тому опишемо маршрути трьох сторінок. <br>
                    Групу маршрутів обов'язково має обертати компонент < Routes>, навіть якщо маршрут лише один. Тобто < Route> не може використовуватися без < Routes>. Цей компонент виконує логіку підбору найбільш відповідного <Route> для поточного значення URL в адресному рядку браузера.
                  </p>
                  <p class="exemplar">
                    App.jsx <br>
                                       <br>
                    import { Routes, Route } from "react-router-dom"; <br>
                    import Home from "path/to/pages/Home"; <br>
                    import About from "path/to/pages/About"; <br>
                    import Products from "path/to/pages/Products"; <br>
                                       <br>
                    export const App = () => { <br>
                      return ( <br>
                        < div> <br>
                          < Routes> <br>
                            < Route path="/" element={< Home />} /> <br>
                            < Route path="/about" element={< About />} /> <br>
                            < Route path="/products" element={< Products />} /> <br>
                          < /Routes> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                   <h5 class="section-title__value">Сторінка помилки навігації</h5>
                  <p>
                    Що буде, якщо користувач перейде за посиланням /non-existing-route або будь-якому іншому, якого немає в нашому додатку? Він побачить порожню вкладку браузера, без будь-якого контенту, оскільки жоден з описаних нами <Route> не підійде. Для цього до кінця списку маршрутів додамо ще один <Route>, який збігатиметься з будь-яким URL, але він буде обраний тільки в тому випадку, якщо жоден інший маршрут не підійде.
                  </p>
                  <p class="exemplar">
                    import { Routes, Route } from "react-router-dom"; <br>
                    import Home from "path/to/pages/Home"; <br>
                    import About from "path/to/pages/About"; <br>
                    import Products from "path/to/pages/Products"; <br>
                    import NotFound from "path/to/pages/NotFound"; <br>
                                       <br>
                    const App = () => { <br>
                      return ( <br>
                        < div> <br>
                          < Routes> <br>
                            < Route path="/" element={< Home />} /> <br>
                            < Route path="/about" element={< About />} /> <br>
                            < Route path="/products" element={< Products />} /> <br>
                            < Route path="*" element={< NotFound />} /> <br>
                          < /Routes> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <p>
                    Символ * у пропсі path буквально вказує на те, що цей маршрут може збігатися з будь-яким значенням URL. Тому якщо жоден попередній <Route> не підійде, останній точно відобразить користувачеві сторінку з якимось повідомленням про те, що маршруту яким він перейшов, не існує.
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Компоненти <Link> та <NavLink> -->
            <li>
              <h4 class="section-title__name">Компоненти < Link> та < NavLink></h4>
              <p>
                Тепер розглянемо, як створювати посилання на різні сторінки нашої програми. Для створення навігації не можна використовувати звичайний тег < a href="/about">. При кліку, замість того щоб змінити URL на поточній сторінці, і дозволити маршрутизатору виконати навігацію на стороні клієнта, браузер перезавантажить сторінку. <br>
                Для створення посилань використовуються компоненти < Link> та < NavLink>. Вони рендерять тег < a>, але стандартна поведінка посилання змінена так, що при натисканні просто оновлюється URL в адресному рядку браузера, без перезавантаження сторінки.
              </p>
              <p class="exemplar">
                < nav> <br>
                  < Link to="/">Home< /Link> <br>
                  < Link to="/about">About< /Link> <br>
                  < Link to="/products">Products< /Link> <br>
                < /nav> <br>
              </p>
              <p>
                Компонент < NavLink> відрізняється тільки тим, що може мати додаткові стилі, якщо поточний URL збігається зі значенням пропcа to. За замовчуванням елементу активного посилання додається клас active. Це можна використовувати для її стилізації.
              </p>
              <p class="exemplar">
                App.jsx <br>
                               <br>
                import { Routes, Route, NavLink } from "react-router-dom"; <br>
                import styled from "styled-components"; <br>
                import Home from "path/to/pages/Home"; <br>
                import About from "path/to/pages/About"; <br>
                import Products from "path/to/pages/Products"; <br>
                               <br>
                const StyledLink = styled(NavLink)` <br>
                  color: black; <br>
                               <br>
                  &.active { <br>
                    color: orange; <br>
                  } <br>
                `; <br>
                 <br>
                export const App = () => { <br>
                  return ( <br>
                    < div> <br>
                      < nav> <br>
                        < StyledLink to="/" end> <br>
                          Home <br>
                        < /StyledLink> <br>
                        < StyledLink to="/about">About< /StyledLink> <br>
                        < StyledLink to="/products">Products< /StyledLink> <br>
                      < /nav> <br>
                 <br>
                      < Routes> <br>
                        < Route path="/" element={< Home />} /> <br>
                        < Route path="/about" element={< About />} /> <br>
                        < Route path="/products" element={< Products />} /> <br>
                      < /Routes> <br>
                    < /div> <br>
                  ); <br>
                }; <br>
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- URL-параметри -->
            <li>
              <h4 class="section-title__name">URL-параметри</h4>
              <p>
                Динамічні параметри схожі на параметри функції - у них завжди одна назва, але можуть бути різні значення. Вони дозволяють оголосити шаблон адреси, частини якого можуть мати довільне значення. Наприклад, немає сенсу визначати окремий маршрут для кожного посту у блозі, їх можуть бути тисячі. За структурою контенту такі сторінки будуть ідентичні, а відрізнятиметься лише назва, зображення, автор, текст тощо. Замість того, щоб визначати маршрут для кожної статті, ми можемо оголосити один маршрут з динамічним параметром по якому визначатимемо яку посаду необхідно відображати саме зараз. Для того, щоб вказати, що якась частина адреси це URL-параметр, використовується двокрапка (:) перед іменем параметра.
              </p>
              <h3>< Route path="/blog/:postId" element={< BlogPost />} /></h3>
              <p>
                Кожного разу, коли користувач буде відвідувати адресу, що відповідає шаблону /blog/:postId, наприклад /blog/react-fundamentals або /blog/top-5-css-tricks, йому відображатиметься сторінка цього поста.
              </p>
              <p class="exemplar">
                Додамо до нашої програми маршрут сторінки одного продукту з адресою /products/:productId. Це окрема сторінка, ніяк не прив'язана до /products - сторінці відображення всіх продуктів. <br>
                <br>
                App.jsx <br>
                               <br>
                import { Routes, Route, Link } from "react-router-dom"; <br>
                import Home from "path/to/pages/Home"; <br>
                import About from "path/to/pages/About"; <br>
                import Products from "path/to/pages/Products"; <br>
                import NotFound from "path/to/pages/NotFound"; <br>
                import ProductDetails from "path/to/pages/ProductDetails"; <br>
                               <br>
                export const App = () => { <br>
                  return ( <br>
                    < div> <br>
                      < nav> <br>
                        < Link to="/">Home< /Link> <br>
                        < Link to="/about">About< /Link> <br>
                        < Link to="/products">Products< /Link> <br>
                      < /nav> <br>
                      < Routes> <br>
                        < Route path="/" element={< Home />} /> <br>
                        < Route path="/about" element={< About />} /> <br>
                        < Route path="/products" element={< Products />} /> <br>
                        < Route path="/products/:productId" element={< ProductDetails />} /> <br>
                        < Route path="*" element={< NotFound />} /> <br>
                      < /Routes> <br>
                    < /div> <br>
                  ); <br>
                }; <br>


              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Хук useParams -->
            <li>
              <h4 class="section-title__name">Хук useParams</h4>
              <h3>він нам потрібен щоб брати динамічне значення з адресного рядка id (те що йде після /: id) /products/:id</h3>
              <p class="exemplar">
                В компоненті ми його візьмемо const { id } = useParams();
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>Повертає об'єкт з усіма динамічними параметрами, які є в поточному URL. Ім'я параметра буде ім'ям властивості в об'єкті, а його поточне значення в адресі - значенням властивості. Наприклад, якщо оголошено наступний маршрут /books/:genreId/:authorName, та користувач знаходиться за адресою /books/adventure/herman-melville.</p>
                  <p class="exemplar">
                    const { genreId, authorName } = useParams(); <br>
                    console.log(genreId, authorName);// adventure, herman-melville <br>
                  </p>
                  <p>
                    Для того, щоб отримати значення динамічної частини URL, у нашому випадку ідентифікатор продукту, використовуємо хук useParams у компоненті сторінки продукту.
                  </p>
                  <p class="exemplar">
                    src/pages/ProductDetails.jsx <br>
                    <br>
                    import { useParams } from "react-router-dom"; <br>
                    <br>
                    const ProductDetails = () => { <br>
                      const { productId } = useParams(); <br>
                      return < div>Now showing product with id - {productId}< /div>; <br>
                    }; <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Вкладені маршрути -->
             <li>
              <h4 class="section-title__name">Вкладені маршрути</h4>
              <p>
                Вкладені маршрути дозволяють описувати логіку «підсторінок», тобто якийсь URL по якому крім батьківського компонента цілої сторінки буде відображатися ще якийсь дочірній, вкладений компонент.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Наприклад, нам необхідно щоб на /about/mission, /about/team та /about/reviews крім контенту сторінки «Про нас» відображалася ще якась додаткова, більш специфічна інформація. Нехай це буде кілька різноманітних компонентів: стаття про місію нашої компанії, галерея з інформацією про співробітників та відгуки користувачів.
                  </p>
                  <p class="exemplar">
                    < Route path="/about" element={< About />}> <br>
                      < Route path="mission" element={< Mission />} /> <br>
                      < Route path="team" element={< Team />} /> <br>
                      < Route path="reviews" element={< Reviews />} /> <br>
                    < /Route> <br>
                  </p>
                  <h3>кілька особливостей:</h3>
                  <ul>
                    <li>
                      <p>
                        Ми декларативно вклали дочірні маршрути всередину батьківського < Route>. Саме такий синтаксис вказує на вкладений маршрут, компонент якого буде відображатися десь усередині батьківського компонента.
                      </p>
                    </li>
                    <li>
                      <p>
                        Значення пропсу path у вкладеного маршруту вказується відносно батьківського, саме тому ми передали значення path="mission", а не повний шлях path="/about/mission".
                      </p>
                    </li>
                    <li>
                      <p>
                        Відносні шляхи записуються без провідного символу /, тобто path="mission", а не path="/mission". Якщо додати слеш, то ми навпаки створимо окремий маршрут /mission та зламаємо логіку маршрутизації.
                      </p>
                    </li>
                  </ul>
                  <p>Повна конфігурація маршрутів нашої програми виглядатиме так.</p>
                  <p class="exemplar">
                    App.jsx <br>
                    <br>
                    import { Routes, Route, Link } from "react-router-dom"; <br>
                    import Home from "path/to/pages/Home"; <br>
                    import About from "path/to/pages/About"; <br>
                    import Products from "path/to/pages/Products"; <br>
                    import NotFound from "path/to/pages/NotFound"; <br>
                    import ProductDetails from "path/to/pages/ProductDetails"; <br>
                    import Mission from "path/to/components/Mission"; <br>
                    import Team from "path/to/components/Team"; <br>
                    import Reviews from "path/to/components/Reviews"; <br>
                    <br>
                    export const App = () => { <br>
                      return ( <br>
                        < div> <br>
                          < nav> <br>
                            < Link to="/">Home< /Link> <br>
                            < Link to="/about">About< /Link> <br>
                            < Link to="/products">Products< /Link> <br>
                          < /nav> <br>
                          < Routes> <br>
                            < Route path="/" element={< Home />} /> <br>
                            < Route path="/about" element={< About />}> <br>
                              < Route path="mission" element={< Mission />} /> <br>
                              < Route path="team" element={< Team />} /> <br>
                              < Route path="reviews" element={< Reviews />} /> <br>
                            < /Route> <br>
                            < Route path="/products" element={< Products />} /> <br>
                            < Route path="/products/:productId" element={< ProductDetails />} /> <br>
                            < Route path="*" element={< NotFound />} /> <br>
                          < /Routes> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <p>
                    Останнє, що обов'язково необхідно зробити, це вказати де саме в компоненті батьківського маршруту < About> ми хочемо рендерувати дочірні маршрути. Для цього у React Router є компонент < Outlet>.
                  </p>
                  <p class="exemplar">
                    src/pages/About.jsx <br>
                                       <br>
                    import { Link, Outlet } from "react-router-dom"; <br>
                                       <br>
                    export const About = () => { <br>
                      return ( <br>
                        < div> <br>
                          < h1>About page< /h1> <br>
                          < ul> <br>
                            < li> <br>
                              < Link to="mission">Read about our mission< /Link> <br>
                            < /li> <br>
                            < li> <br>
                              < Link to="team">Get to know the team< /Link> <br>
                            < /li> <br>
                            < li> <br>
                              < Link to="reviews">Go through the reviews< /Link> <br>
                            < /li> <br>
                          < /ul> <br>
                          <span class="selection">< Outlet /></span> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <p>
                    Якщо поточний URL в адресному рядку браузера збігається зі значенням пропсу path вкладеного маршруту, <Outlet> відрендерить його компонент, інакше він рендерить null та не впливає на розмітку батьківського компонента.
                  </p>
                  <a href="https://codesandbox.io/s/goit-textbook-lesson-9-nested-routes-2hui2h?from-embed" target="_blank" rel="noopener noreferrer">ПРИКЛАД</a>

                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Індексні маршрути -->
             <li>
              <h4 class="section-title__name">Індексні маршрути (Layout)</h4>
              <p>Розібравшись із вкладеними маршрутами, ми можемо розглянути прийом «shared layout», який полягає в тому, що якась загальна HTML-розмітка та стилі всього або частини сторінок програми виносяться в окремий компонент, замість того щоб дублюватися на кожній сторінці. У нашому додатку магазину це хедер з логотипом та головною навігацією, а також контейнер, що обмежує ширину контенту сторінок.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  
                    <p class="exemplar">
                      src/components/App.jsx <br>
                                           <br>
                      // Imports <br>
                                           <br>
                      export const App = () => { <br>
                        return ( <br>
                          < Container> <br>
                            < Header> <br>
                              < Logo> <br>
                                < span role="img" aria-label="computer icon"> <br>
                                  💻 <br>
                                < /span>{" "} <br>
                                GoMerch Store <br>
                              < /Logo> <br>
                              < nav> <br>
                                < Link to="/">Home< /Link> <br>
                                < Link to="/about">About< /Link> <br>
                                < Link to="/products">Products< /Link> <br>
                              < /nav> <br>
                            < /Header> <br>
                            < Routes> <br>
                              < Route path="/" element={< Home />} /> <br>
                              < Route path="/about" element={< About />}> <br>
                                < Route path="mission" element={< Mission />} /> <br>
                                < Route path="team" element={< Team />} /> <br>
                                < Route path="reviews" element={< Reviews />} /> <br>
                              < /Route> <br>
                              < Route path="/products" element={< Products />} /> <br>
                              < Route path="/products/:productId" element={< ProductDetails />} /> <br>
                            < /Routes> <br>
                          < /Container> <br>
                        ); <br>
                      }; <br>
                    </p>
                    <p>
                      Винесемо цю розмітку та її стилі в окремий компонент < SharedLayout>. Зверніть увагу на використання та місце розташування < Outlet> - у це місце буде рендетися розмітка компонентів сторінок.
                    </p>
                    <p class="exemplar">
                                          <br>
                      src/components/SharedLayout.jsx<br>
                                          <br>
                      // Imports<br>
                      import { Outlet } from "react-router-dom";<br>
                                          <br>
                      export const SharedLayout = () => {<br>
                        return (<br>
                          < Container><br>
                            < Header><br>
                              < Logo><br>
                                < span role="img" aria-label="computer icon"><br>
                                  💻<br>
                                < /span>{" "}<br>
                                GoMerch Store<br>
                              < /Logo><br>
                              < nav><br>
                                < Link to="/">Home< /Link><br>
                                < Link to="/about">About< /Link><br>
                                < Link to="/products">Products< /Link><br>
                              < /nav><br>
                            < /Header><br>
                            < Outlet /><br>
                          < /Container><br>
                        );<br>
                      };<br>
                    </p>
                    <p>
                     Далі використовуємо цей компонент у < App> так щоб він рендерився на будь-який маршрут. Для цього будемо рендерувати його на /, а всі інші маршрути робимо вкладеними в нього, тому змінимо path всіх вкладених маршрутів відносно батьківського.
                    </p>
                    <p class="exemplar">
                                             <br>
                      src/components/App.jsx <br>
                                             <br>
                      // Imports <br>
                      import { SharedLayout } from "path/to/components/SharedLayout"; <br>
                                             <br>
                      export const App = () => { <br>
                        return ( <br>
                          < Routes> <br>
                            < Route path="/" element={< SharedLayout />}> <br>
                              < Route path="about" element={< About />}> <br>
                                < Route path="mission" element={< Mission />} /> <br>
                                < Route path="team" element={< Team />} /> <br>
                                < Route path="reviews" element={< Reviews />} /> <br>
                              < /Route> <br>
                              < Route path="products" element={< Products />} /> <br>
                              < Route path="products/:productId" element={< ProductDetails />} /> <br>
                            < /Route> <br>
                          < /Routes> <br>
                        ); <br>
                      }; <br>
                    </p>
                    <p>
                      У вас може виникнути справедливе питання, куди зник компонент < Home> який раніше рендерився на path="/". Проблема в тому, що зараз на /about рендериться < SharedLayout> та < About>, а на / тільки < SharedLayout>. Для того, щоб відрендерити компонент < Home> на той же маршрут, на який рендериться його батько, необхідно зробити «індексний маршрут».
                    </p>
                    <p class="exemplar">
                                             <br>
                      src/components/App.jsx <br>
                                             <br>
                      // Imports <br>
                      import { SharedLayout } from "path/to/components/SharedLayout"; <br>
                                             <br>
                      export const App = () => { <br>
                        return ( <br>
                          < Routes> <br>
                            < Route path="/" element={< SharedLayout />}> <br>
                              < Route index element={< Home />} /> <br>
                              < Route path="about" element={< About />}> <br>
                                < Route path="mission" element={< Mission />} /> <br>
                                < Route path="team" element={< Team />} /> <br>
                                < Route path="reviews" element={< Reviews />} /> <br>
                              < /Route> <br>
                              < Route path="products" element={< Products />} /> <br>
                              < Route path="products/:productId" element={< ProductDetails />} /> <br>
                            < /Route> <br>
                          < /Routes> <br>
                        ); <br>
                      }; <br>
                    </p>
                  
                  <p>Індексних маршрутів може бути скільки завгодно, все залежить від завдання. Наприклад, якби у нас у додатку були сторінки панелі адміністратора, на яких зовсім інші загальні компоненти інтерфейсу, то структуру маршрутів можна було б спроектувати наступним чином.</p>
                  <p class="exemplar">
                    < Routes> <br>
                      < Route path="/" element={< SharedLayout />}> <br>
                        < Route index element={< Home />} /> <br>
                        < Route path="about" element={< About />}> <br>
                          < Route path="mission" element={< Mission />} /> <br>
                          < Route path="team" element={< Team />} /> <br>
                          < Route path="reviews" element={< Reviews />} /> <br>
                        < /Route> <br>
                        < Route path="products" element={< Products />} /> <br>
                        < Route path="products/:productId" element={< ProductDetails />} /> <br>
                      < /Route> <br>
                      < Route path="/admin" element={< AdminLayout />}> <br>
                        < Route index element={< Dashboard />} /> <br>
                        < Route path="sales" element={< Sales />} /> <br>
                        < Route path="customers" element={< Customers />} /> <br>
                      < /Route> <br>
                    < /Routes> <br>
                  </p>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Програмна навігація -->
             <li>
              <h4 class="section-title__name">Програмна навігація</h4>
              <p>
                React Router дозволяє виконати навігацію не тільки при натисканні на Link, але й щодо певної дії користувача, події чи ефекту. Наприклад, при натискання на кнопку, після відправлення форми, за результатом HTTP-запиту і тому подібне. Наприклад використовуємо процес логіна користувача в додаток. Після надсилання форми на сторінці логіну ми виконуємо навігацію на сторінку профілю користувача, але тільки якщо HTTP-запит був успішним.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Варіант 1</h5>
                  <p>Перший спосіб це хук useNavigate. Він надає нам функцію navigate якій під час виклику передаємо шлях, куди необхідно виконати навігацію. Цей спосіб імперативний, але більш гнучкий і вимагає менше коду.</p>
                  <p class="exemplar">
                    src/pages/Login.jsx <br>
                                       <br>
                    import { useNavigate } from "react-router-dom"; <br>
                                       <br>
                    export const Login = () => { <br>
                      const navigate = useNavigate(); <br>
                     <br>
                      const handleSubmit = async values => { <br>
                        const response = await FakeAPI.login(values); <br>
                        if (response.success) { <br>
                          navigate("/profile", { replace: true }); <br>
                        } <br>
                      }; <br>
                     <br>
                      return ( <br>
                        < div> <br>
                          < h1>Login page< /h1> <br>
                          < LoginForm onSubmit={handleSubmit} /> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <p>
                    Зверніть увагу на другий, необов'язковий аргумент функції navigate - це об'єкт параметрів. Властивість replace, за замовчуванням false, контролює як буде додано новий запис на стек історії. Повернемося до аналогії зі стопкою паперів. За замовчуванням новий аркуш буде додано на гору стопки, що ніяк не вплине на решту листів. Якщо вказати значення true, то новий лист підмінить собою найвищий. Це використовується досить рідко, наприклад при логіні, щоб користувач не зміг повернутися кнопкою «назад» на сторінку логіна після входу, адже він уже в системі і робити йому там нічого.
                  </p>

                  <h5 class="section-title__value">Варіант 2</h5>
                  <p>
                    Другий спосіб це компонент Navigate - обгортка над хуком useNavigate. Він виконує навігацію у момент рендеру. Шлях для навігації та необов'язкові параметри передаються окремими пропсами. Такий спосіб більш декларативний, але менш гнучкий і вимагає більше коду.
                  </p>
                  <p class="exemplar">
                    src/pages/Login.jsx <br>
                                       <br>
                    import { Navigate, useState } from "react-router-dom"; <br>
                                       <br>
                    export const Login = () => { <br>
                      const [isLoginSuccess, setIsLoginSuccess] = useState(false); <br>
                     <br>
                      const handleSubmit = async values => { <br>
                        const response = await FakeAPI.login(values); <br>
                        setIsLoginSuccess(response.success); <br>
                      }; <br>
                     <br>
                      if (isLoginSuccess) { <br>
                        return < Navigate to="/profile" replace />; <br>
                      } <br>
                     <br>
                      return ( <br>
                        < div> <br>
                          < h1>Login page< /h1> <br>
                          < LoginForm onSubmit={handleSubmit} /> <br>
                        < /div> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <p>
                    ЩО КРАЩЕ? <br>
                    Який спосіб використовувати залежить тільки від ваших уподобань та вимог поставленого завдання. В одному випадку вам буде зручно використовувати декларативний Navigate, в іншому – імперативний useNavigate.
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Рядок запиту -->
             <li>
              <h4 class="section-title__name">Рядок запиту</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!--  -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">title</h3>
          <h3></h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

    </main>

    <footer class="footer"></footer>

  </body>
</html>
