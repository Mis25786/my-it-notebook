<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script
      src="https://kit.fontawesome.com/7f832f4aea.js"
      crossorigin="anonymous"
    ></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Kaushan+Script&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Tilt+Prism&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="./style.css" />
    <title>Конспект-ІТ</title>
  </head>

  <body>
    <div class="wrapper">
      <header class="header">
        <a class="logo" href="./index.html">Конспект-ІТ</a>
        <nav class="header-nav">
          <a class="header-page" href="./html.html">html/css</a>
          <a class="header-page" href="./image.html">Зображення</a>
          <a class="header-page" href="./animations.html">Анімації/Ефекти</a>
          <a class="header-page" href="./js.html">JavaScript</a>
          <a class="header-page" href="./react.html">React</a>
          <a class="header-page" href="./node.html">Node</a>
          <a class="header-page" href="./commponents.html">Компоненти</a>
          <a class="header-page" href="./resources.html">Ресурси/Бібліотеки</a>
          <a class="header-page" href="./terminal.html">Термінал</a>
        </nav>
        <div class="header-search">
          <i class="fa-solid fa-magnifying-glass"></i>
          <input
            class="header-search__input"
            type="text"
            name="text"
            placeholder="site search"
          />
        </div>
      </header>
    </div>

    <main class="main">
      <!-- React -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">React</h3>
          <h3>Модуль 1_1</h3>
          <h4>файли мають закінчення jsx вмісто js</h4>
          <ul>
            <li>
              <a
                href="https://create-react-app.dev/"
                target="_blank"
                rel="noopener noreferrer"
                >Create React App</a
              >
            </li>
            <li><a href="https://uk.legacy.reactjs.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">React документація на українській</a></li>
          </ul>
          <div>
            <h3>React</h3>
            <p>
              – це бібліотека для створення елементів інтерфейсу користувача. У
              React немає вбудованої маршрутизації, HTTP-модуля тощо. Проте є
              багата екосистема, яка дозволить вирішити будь-яке завдання.
              <br />
              <br />
              При створенні застосунку з використанням React розробник не
              взаємодіє безпосередньо з DOM-деревом. Його завдання – описати
              інтерфейс за допомогою компонентів (шаблон) та керувати зміною
              даних (модель). React, при зміні даних моделі, сам оновить
              інтерфейс за шаблоном.
            </p>
            <br />
            <div>
              <h3>React – мультиплатформний</h3>
              розмітку можна рендерити на сервері (
              <a
                href="https://nextjs.org/"
                target="_blank"
                rel="noopener noreferrer"
                >Next.js</a
              >
              ), писати нативні (
              <a
                href="https://reactnative.dev/"
                target="_blank"
                rel="noopener noreferrer"
                >React Native</a
              >
              ) або десктопні (
              <a
                href="https://www.electronjs.org/"
                target="_blank"
                rel="noopener noreferrer"
                >Electron</a
              >
              ) застосунки.
            </div>
            <p>
              Для створення React-застосунку необхідні Node.js, Webpack, Babel,
              React і DevTools. Можна написати свою Webpack-збірку або взяти
              будь-яку хорошу з GitHub.
            </p>
          </div>

          <ul>
            <!-- створення React-застосунку -->
            <li>
              <h4 class="section-title__name">створення React-застосунку</h4>
              <p>
                Для навчання та маленьких/середніх проектів рекомендується
                використовувати утиліту від авторів React.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    npx create-react-app ім'я_папки_проекту
                  </h5>
                  <p>
                    Щоб створити застосунок у поточній папці, замість імені
                    проекту ставиться крапка. Наприклад npx create-react-app .
                  </p>

                  <h5 class="section-title__value">React DevTools</h5>
                  <p>
                    В інструментах розробника можна подивитися на дерево
                    компонентів, їх стан та пропси. Профайлер корисний під час
                    оптимізації застосунку.
                  </p>
                  <ul>
                    <li>
                      <a
                        href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                        target="_blank"
                        rel="noopener noreferrer"
                        >Devtools в Chrome Web Store</a
                      >
                    </li>
                    <li>
                      <a
                        href="https://legacy.reactjs.org/blog/2019/08/15/new-react-devtools.html"
                        target="_blank"
                        rel="noopener noreferrer"
                        >Introducing the New React DevTools</a
                      >
                    </li>
                  </ul>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- JSX (JavaScript Syntax Extension) -->
            <li>
              <h4 class="section-title__name">
                JSX (JavaScript Syntax Extension)
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    JSX створює елементи – найменші будівельні блоки React.
                    Елементи Virtual DOM це звичайні JavaScript об'єкти, тому
                    створювати їх дуже швидко. <br />
                    <br />
                    Використовуючи JSX, розмітка стає схожою на звичні
                    HTML-шаблони. <br />
                  </p>
                  <ul>
                    <li>
                      <p>
                        Усередині JSX можна використовувати будь-який валідний
                        вираз, обертаючи його в фігурні дужки.
                      </p>
                    </li>
                    <li>
                      <p>
                        Значення атрибутів вказуються в подвійних лапках, якщо
                        це звичайний рядок, та у фігурних дужках, якщо значення
                        обчислюється, або тип відрізняється від рядка.
                      </p>
                    </li>
                    <li>
                      <p>
                        Всі атрибути React-елементів іменуються в camelCase
                        нотації.
                      </p>
                    </li>
                    <li>
                      <p>
                        JSX-теги можуть бути батьками інших JSX-тегів. Якщо тег
                        порожній або самозакривається, його обов'язково
                        необхідно закрити використовуючи />.
                      </p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    const imageUrl = <br />
                    "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";
                    <br />
                    const productPrice = 10.99; <br />
                    <br />
                    const product = ( <br />
                    < div> <br />
                    < img src={imageUrl} alt="Tacos With Lime" width="640" />
                    <br />
                    < h2>Tacos With Lime< /h2> <br />
                    < p>Price: {productPrice}$< /p> <br />
                    < button type="button">Add to cart< /button> <br />
                    < /div> <br />
                    ); <br />
                  </p>

                  <h5 class="section-title__value">
                    Рендер елементів у DOM-дерево
                  </h5>
                  <p>
                    Для того, щоб відрендерувати елемент у DOM-дерево, у пакеті
                    react-dom є методи createRoot(container) та render(element),
                    які працюють разом.
                  </p>
                  <p>
                    Перший приймає посилання на існуючий DOM-елемент, наприклад
                    div#root з index.html і створює корінь, в який буде
                    рендеруватись вся програма. <br />
                    Другий чекає на посилання на React-елемент або компонент (що
                    рендерити). <br />
                  </p>
                  <h4>
                    ReactDOM.createRoot(document.getElementById("root")).render(product);
                  </h4>

                  <h5 class="section-title__value">Правило спільного батька</h5>
                  <p>
                    Якщо в розмітці зайвий тег-обгортка не потрібний,
                    використовуються фрагменти, схожі на DocumentFragment. Цей
                    вбудований компонент при рендері розчиняється, підставляючи
                    свій вміст.
                  </p>
                  <p class="exemplar">
                    import { Fragment } from "react"; <br />
                    <br />
                    const post = ( <br />
                    < Fragment> <br />
                    < h2>Post Header< /h2> <br />
                    < p>Post text< /p> <br />
                    < /Fragment> <br />
                    ); <br />
                  </p>
                  <p>
                    Синтаксис фрагментів можна скоротити та не додавати імпорт
                    Fragment. Babel зробить всі необхідні трансформації,
                    замінивши порожні JSX-теги на React.Fragment.
                  </p>
                  <p class="exemplar">
                    const post = ( <br />
                    < > <br />
                    < h2>Post Header< /h2> <br />
                    < p>Post text< /p> <br />
                    < /> <br />
                    ); <br />
                  </p>

                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Компоненти -->
            <li>
              <h4 class="section-title__name">Компоненти</h4>
              <p>
                – основні будівельні блоки React-застосунків, за допомогою яких
                інтерфейс розділяється на незалежні частини. <br />
                <br />
                Розробник створює невеликі компоненти, які можна поєднувати, щоб
                сформувати більші, або використовувати їх як самостійні елементи
                інтерфейсу. Найголовніше в цій концепції те, що і великі, і
                маленькі компоненти можна використовувати повторно і в
                поточному, і в новому проекті. <br />
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Компонент це окремо створений файл, в якому створена
                    розмітка будьякого елемента (картки товару, лоадер, модалка
                    і т д) який ми потім можемо підключити в будь-якому іншому
                    компоненті (файлі) і перевикористовувати. <br />
                    Також можна вставляти один компонент в інший при рендері.
                    <br />
                    В компонент не імпортуеться масив з елементами, всі данні
                    передаються пропсами з основного файлу (App.js) де буде
                    рендиритись компонент. <br />
                    Пропси мають ключ="значення", зазвичай пропси називають так
                    само як в ключі в об'єктах які передаємо. Пропси значення в
                    пропсах передаємо в фігурних дужках price={product.price},
                    рядок (текст) в лапках.
                  </p>
                  <div class="exemplar">
                    <h4>КОМПОНЕНТ</h4>
                    <p>
                      const Product = ({ imgUrl, name, price }) => ( <br />
                      < div> <br />
                      < img src={imgUrl} alt={name} width="640" /> <br />
                      < h2>{name}< /h2> <br />
                      < p>Price: {price}$< /p> <br />
                      < button type="button" >Add to cart< /button> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                  </div>
                  <p>
                    Тут ми імпортуемо компонент ProductList і в ньому рендиремо
                    компонент Product
                  </p>
                  <div class="exemplar">
                    <h4>ФАЙЛ ОСНОВНИЙ З ЯКОГО РЕНДЕРИТЬСЯ ВЕСЬ ПРОЕКТ</h4>
                    <p>
                      import ProductList from "productList.js"; <br />
                      import Product from "product.js"; <br />
                      <br />
                      import products from "products.json"; // файл з масивом
                      об'єктів продуктів <br />
                      <br />
                      <br />
                      const App = () => ( <br />
                      < div> <br />
                      < h1>Best selling products< /h1> <br />
                      < ProductList > <br />
                      < Product <br />
                      imgUrl={products.imgUrl} <br />
                      name="Tacos With Lime" <br />
                      price={products.price} <br />
                      /> <br />
                      < /ProductList> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                  </div>

                  <h5 class="section-title__value">
                    Значення пропсів за замовчуванням
                  </h5>
                  <p>
                    Що якщо компонент очікує якесь значення, а його не передали?
                    - під час звернення до властивості об'єкта props отримаємо
                    undefined. <br />
                    <br />
                    Для того щоб вказати значення властивостей за замовчуванням,
                    використовується синтаксис значень за замовчуванням під час
                    деструктуризації пропсів. <br />
                  </p>
                  <p class="exemplar">
                    import imageDefault from "../images/image.jpg"; <br />
                    <br />
                    const Product = ({ <br />
                    imgUrl = imageDefault, <br />
                    name = "no name", <br />
                    price = "please call at", <br />
                    }) => ( <br />
                    - || - <br />
                    ); <br />
                  </p>

                  <h5 class="section-title__value">
                    Властивість props.children
                  </h5>
                  <p>
                    Концепція дочірніх елементів дозволяє дуже просто робити
                    композицію компонентів. У вигляді дітей можна передавати
                    компоненти як вбудовані, так і кастомні. Це дуже зручно під
                    час роботи зі складними складеними компонентами. <br />
                    <br />
                    Властивість children автоматично доступна в кожному
                    компоненті, її вмістом є те, що знаходиться між відкриваючим
                    та закриваючим JSX-тегом. <br />
                    У функціональних компонентах звертаємось як props.children.
                    <br />
                    Значенням props.children може бути практично все, що
                    завгодно. <br />
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      const Profile = ({ name, email }) => ( <br />
                      < div> <br />
                      < p>Name: {name}< /p> <br />
                      < p>Email: {email}< /p> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                    <p>
                      const Panel = ({ title, children }) => ( <br />
                      < section> <br />
                      < h2>{title}< /h2> <br />
                      {children} <br />
                      < /section> <br />
                      ); <br />
                    </p>
                    <p>
                      const App = () => ( <br />
                      < div> <br />
                      < Panel title="User profile"> <br />
                      < Profile name="Mango" email="mango@mail.com" /> <br />
                      < /Panel> <br />
                      < /div> <br />
                      ); <br />
                    </p>
                  </div>

                  <h5 class="section-title__value">
                    Перевірка типів одержуваних пропсів Властивість propTypes
                  </h5>
                  <div>
                    Пакет
                    <a
                      href="https://www.npmjs.com/package/prop-types"
                      target="_blank"
                      rel="noopener noreferrer"
                      >prop-types</a
                    >
                    надає ряд валідаторів для перевірки коректності отриманих
                    типів даних під час виконання коду, повідомляючи про
                    невідповідності в консолі.
                  </div>
                  <h3>npm install --save-dev prop-types</h3>
                  <p class="exemplar">
                    import PropTypes from "prop-types"; <br />
                    <br />
                    const Product = ({ <br />
                    imgUrl =
                    "https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder",
                    <br />
                    name, <br />
                    price, <br />
                    }) => ( <br />
                    < div> <br />
                    < img src={imgUrl} alt={name} width="640" /> <br />
                    < h2>{name}< /h2> <br />
                    < p>Price: {price}$< /p> <br />
                    < button type="button">Add to cart< /button> <br />
                    < /div> <br />
                    ); <br />
                    <br />
                    Product.propTypes = { <br />
                    imgUrl: PropTypes.string, <br />
                    name: PropTypes.string.isRequired, <br />
                    price: PropTypes.number.isRequired, <br />
                    }; <br />
                  </p>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Рендер за умовою -->
            <li>
              <h4 class="section-title__name">Рендер за умовою</h4>
              <ul>
                <li>
                  <a
                    href="https://react.dev/learn/conditional-rendering"
                    target="_blank"
                    rel="noopener noreferrer"
                    >Умовний рендеринг</a
                  >
                </li>
                <li>
                  <a
                    href="https://www.robinwieruch.de/conditional-rendering-react/"
                    target="_blank"
                    rel="noopener noreferrer"
                    >All the Conditional Renderings in React</a
                  >
                </li>
              </ul>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    if за допомогою логічного оператора &&
                  </h5>
                  <p class="exemplar">
                    Читається як: якщо умова приводиться до true, то рендерим
                    розмітку. <br />
                    <br />
                    const Mailbox = ({ unreadMessages }) => { <br />
                    return ( <br />
                    < div> <br />
                    < h1>Hello!< /h1> <br />
                    {unreadMessages.length > 0 && ( <br />
                    < p>You have {unreadMessages.length} unread messages.< /p>
                    <br />
                    )} <br />
                    < /div> <br />
                    ); <br />
                    }; <br />
                  </p>

                  <h5 class="section-title__value">
                    if...else за допомогою тернарного оператора
                  </h5>
                  <p class="exemplar">
                    const Mailbox = ({ name, unreadMessages }) => { <br />
                    return ( <br />
                    < div> <br />
                    < h1>Hello {name}< /h1> <br />
                    < p> <br />
                    {unreadMessages.length > 0 <br />
                    ? `You have ${unreadMessages.length} unread messages.`
                    <br />
                    : "No unread messages."} <br />
                    < /p> <br />
                    < /div> <br />
                    ); <br />
                    }; <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Рендер колекції однотипних елементів
              </h4>
              <a
                href="https://react.dev/learn/rendering-lists"
                target="_blank"
                rel="noopener noreferrer"
                >Списки і ключі</a
              >
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Для того щоб відрендерити колекцію однотипних елементів,
                    використовується метод Array.prototype.map(),
                    callback-функція якого, для кожного елемента колекції
                    повертає JSX-розмітку. Отже, отримуємо масив
                    React-елементів, який можна рендерити. <br />
                    <br />
                    Під час виконання коду з прикладу вище спливе попередження
                    про те, що для елементів списку потрібен ключ. React не може
                    відрізнити елементи в колекції, таким чином, перемальовуючи
                    всю колекцію повністю у разі будь-яких змін. <br />
                    <br />
                    <span class="selection">Ключ (key)</span> — це спеціальний
                    рядковий проп, який потрібно задати під час створення
                    елементів колекції. <br />
                    <br />
                    Елементи всередині колекції повинні бути забезпечені
                    ключами, щоб мати стабільну ідентичність. React використовує
                    ключі, щоб визначити, які з елементів в колекції необхідно
                    створити і відрендерити знову, а не використовувати елементи
                    з попереднього рендеру. Таким чином ми уникаємо
                    перестворення всіх елементів колекції щоразу, коли щось
                    змінюється. <br />
                    <br />
                  </p>
                  <p class="exemplar">
                    const favouriteBooks = [ <br />
                    { id: "id-1", name: "JS for beginners" }, <br />
                    { id: "id-2", name: "React basics" }, <br />
                    { id: "id-3", name: "React Router overview" }, <br />
                    { id: "id-4", name: "Redux in depth" }, <br />
                    ]; <br />
                    <br />
                    const BookList = ({ books }) => ( <br />
                    < ul> <br />
                    {books.map(book => ( <br />
                    < li key={book.id}>{book.name}< /li> <br />
                    ))} <br />
                    < /ul> <br />
                    ); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Стилізація (SCSS, CSS) -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Стилізація (SCSS, CSS)</h3>
          <h3></h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- CSS-модулі (основний метод для стилізації) -->
            <li>
              <h4 class="section-title__name">CSS-модулі (основний метод для стилізації)</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Create React App за замовчуванням підтримує CSS-модулі, все, що необхідно зробити це створювати файли стилів з розширенням .module.css, наприклад Alert.module.css. Всередині модуля CSS можна використовувати будь-який валідний CSS.
                  </p>
                  <p class="exemplar">
                    src/components/Alert.module.css <br>
                    .alert { <br>
                      margin: 8px; <br>
                      padding: 12px 16px; <br>
                      border-radius: 4px; <br>
                      background-color: gray; <br>
                      color: white; <br>
                    } <br>
                  </p>
                  <p>
                    Синтаксис імпорту CSS-модуля нагадує імпорт файлу JavaScript модуля. У CSS-модулі є експорт за замовчуванням - об'єкт відповідності оригінального та згенерованих імен класів. У фінальному файлі стилів буде унікальне ім'я класу у форматі [filename]_[classname]__[hash].
                  </p>
                  <p class="exemplar">
                    src/components/Alert.js <br>
                    // Синтаксис імпорту CSS-модуля <br>
                    import css from "./Alert.module.css"; <br>
                    // Отримуємо об'єкт відповідності імен класів <br>
                    console.log(css); // { alert: "Alert_alert_ax7yz" } <br>
                    const Alert = ({ children }) => { <br>
                      // Звертаємось до властивості об'єкта на ім'я класу з файлу модуля <br>
                      return < p className={css.alert}>{children}< /p>; <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Властивість composes</h5>
                  <p>
                    Композиція селекторів це одна з ключових можливостей CSS-модулів, яка дозволяє створювати клас, наслідуючи стилі іншого класу, але не дублюючи їх.
                    Наслідуємо стилі базового класу .alert у всіх класах варіантів. Властивість composes має передувати іншим правилам, щоб можна було перевизначити стилі, якщо це необхідно.
                  </p>
                  <p class="exemplar">
                    src/components/Alert.module.css <br>
                    .alert { <br>
                      margin: 8px; <br>
                      padding: 12px 16px; <br>
                      border-radius: 4px; <br>
                      background-color: gray; <br>
                      color: white; <br>
                    } <br>
                    .info { <br>
                      composes: alert; <br>
                      background-color: blue; <br>
                    } <br>
                    .success { <br>
                      composes: alert; <br>
                      background-color: green; <br>
                    } <br>
                    .error { <br>
                      composes: alert; <br>
                      background-color: red; <br>
                    } <br>
                    .warning { <br>
                      composes: alert; <br>
                      background-color: orange; <br>
                    } <br>
                  </p>
                  <p>
                    При композиції у простих випадках можна обійтися без бібліотеки clsx. Не задаємо базовий клас alert, тому що від нього виконано композицію класів варіантів. В результаті на елементі <p> будуть два класи, базовий alert і клас варіанта, у якому перевизначається значення кольору фону.
                  </p>
                  <p class="exemplar">
                    src/components/Alert.js <br>
                    import css from "./Alert.module.css"; <br>
                    const Alert = ({ variant, children }) => { <br>
                      return < p className={css[variant]}>{children}< /p>; <br>
                    }; <br>
                  </p>
                  <h3>До властивостей об'єкта зазвичай звертаються як css.alert, але можна використовувати квадратні дужки, наприклад css["alert"]. Це корисно у випадку коли ім'я властивості зберігається у змінній, як у нас у пропсі variant.</h3>
                  
                  <h5 class="section-title__value">Бібліотека <a href="https://www.npmjs.com/package/clsx" target="_blank" rel="noopener noreferrer">clsx</a></h5>
                  <p>
                    Додамо CSS класи для вже знайомих нам пропсів outlined та elevated. Імена класи, що складаються з декількох слів записують у верблюжій нотації. В протилежному випадку, оскільки вони стають властивостями об'єкта, звертатися до них доведеться через квадратні дужки, наприклад css["is-outlined"], що менш зручно.
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      src/components/Alert.module.css <br>
                      .alert { <br>
                        margin: 8px; <br>
                        padding: 12px 16px; <br>
                        border-radius: 4px; <br>
                        background-color: gray; <br>
                        color: white; <br>
                      } <br>
                        <br>
                      .info { <br>
                        composes: alert; <br>
                        background-color: blue; <br>
                      } <br>
                        <br>
                      .success { <br>
                        composes: alert; <br>
                        background-color: green; <br>
                      } <br>
                        <br>
                      .error { <br>
                        composes: alert; <br>
                        background-color: red; <br>
                      } <br>
                        <br>
                      .warning { <br>
                        composes: alert; <br>
                        background-color: orange; <br>
                      } <br>
                        <br>
                      .alert.isOutlined { <br>
                        outline: 1px solid black; <br>
                      } <br>
                        <br>
                      .alert.isElevated { <br>
                        box-shadow: rgb(0 0 0 / 20%) 0px 3px 3px -2px, <br>
                          rgb(0 0 0 / 14%) 0px 3px 4px 0px, rgb(0 0 0 / 12%) 0px 1px 8px 0px; <br>
                      } <br>
                    </p>
                    <p>
                      src/components/Alert.js <br>
                      import clsx from "clsx"; <br>
                      import css from "./Alert.module.css"; <br>
                      const Alert = ({ variant, outlined, elevated, children }) => { <br>
                        return ( <br>
                          < p <br>
                            className={clsx(css[variant], { <br>
                              [css.isOutlined]: outlined, <br>
                              [css.isElevated]: elevated, <br>
                            })} <br>
                          > <br>
                            {children} <br>
                          < /p> <br>
                        ); <br>
                      }; <br>
                    </p>
                  </div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Вбудовані стилі -->
            <li>
              <h4 class="section-title__name">Вбудовані стилі</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <h3>
                    Існує кілька способів стилізації компонентів, найпростіший,
                    але в той же час найбільш обмежений – це вбудовані стилі.
                    Для цього використовується атрибут style, який у React
                    приймає не рядок, а об'єкт стилів.
                  </h3>
                  <p></p>
                  <div class="section-box">
                    <p class="exemplar">
                      Створимо компонент Alert який буде рендерувати абзац
                      тексту та приховає у собі майбутню логіку вибору кольору
                      фону. <br />
                      <br />
                      src/components/Alert.js <br />
                      const alertStyles = { <br />
                      margin: 8, <br />
                      padding: "12px 16px", <br />
                      borderRadius: 4, <br />
                      backgroundColor: "gray", <br />
                      color: "white", <br />
                      }; <br />
                      export const Alert = ({ children }) => { <br />
                      return < p style={alertStyles}>{children}< /p>; <br />
                      }; <br />
                    </p>
                    <p class="exemplar">
                      Зробимо так, щоб залежно від типу оповіщення, у компоненті Alert змінювався колір фону абзацу. Для цього додамо йому обов'язковий пропс variant з кількома можливими значеннями. <br>
                      <br>
                      src/components/App.js <br>
                      import { Alert } from "./Alert"; <br>
                      const App = () => { <br>
                        return ( <br>
                          <> <br>
                            < Alert variant="info"> <br>
                              Would you like to browse our recommended products? <br>
                            < /Alert> <br>
                            < Alert variant="error"> <br>
                              There was an error during your last transaction <br>
                            < /Alert> <br>
                            < Alert variant="success"> <br>
                              Payment received, thank you for your purchase <br>
                            < /Alert> <br>
                            < Alert variant="warning"> <br>
                              Please update your profile contact information <br>
                            < /Alert> <br>
                          </> <br>
                        ); <br>
                      }; <br>
                    </p>
                    <p class="exemplar">
                      Логіку вибору кольору винесемо у функцію getBgColor(variant), яка буде повертати рядок із назвою кольору залежно від значення параметра variant. <br>
                                           <br>
                      src/components/Alert.js <br>
                      const alertStyles = { <br>
                        margin: 8, <br>
                        padding: "12px 16px", <br>
                        borderRadius: 4, <br>
                        color: "white", <br>
                      }; <br>
                      const getBgColor = variant => { <br>
                        switch (variant) { <br>
                          case "info": <br>
                            return "blue"; <br>
                          case "success": <br>
                            return "green"; <br>
                          case "error": <br>
                            return "red"; <br>
                          case "warning": <br>
                            return "orange"; <br>
                          default: <br>
                            throw new Error(`Unsupported variant prop value - ${variant}`); <br>
                        } <br>
                      }; <br>
                      export const Alert = ({ variant, children }) => { <br>
                        return ( <br>
                          < p style={{ ...alertStyles, backgroundColor: getBgColor(variant) }}> <br>
                            {children} <br>
                          < /p> <br>
                        ); <br>
                      }; <br>
                    </p>
                  </div>
                  <h3 class="selection">На практиці вбудовані стилі використовуються тільки для динамічно обчислюваних значень властивостей, у парі із зовнішніми таблицями стилів. В якості основного способу стилізації компонентів вбудовані стилі не використовуються в проектах та тому не рекомендуються.</h3>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Ванільний CSS -->
            <li>
              <h4 class="section-title__name">Ванільний CSS</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Оформлення компонента можна винести до таблиці стилів. У цьому випадку стилі кожного компонента оголошуються в окремому CSS-файлі з розширенням .css. Ім'я файлу складається з імені компонента та розширення. Наприклад, для компонента Alert, файл стилів буде називатися Alert.css.
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      src/components/Alert.css <br>
                      .alert { <br>
                        margin: 8px; <br>
                        padding: 12px 16px; <br>
                        border-radius: 4px; <br>
                        background-color: gray; <br>
                        color: white; <br>
                      } <br>
                    </p>
                    <p>
                      src/components/Alert.js <br>
                      import "./Alert.css"; <br>
                      const Alert = ({ children }) => { <br>
                        return < p className="alert">{children}< /p>; <br>
                      }; <br>
                    </p>
                  </div>
                  <h5 class="section-title__value">Бібліотека <a href="https://www.npmjs.com/package/clsx" target="_blank" rel="noopener noreferrer">clsx</a> </h5>
                  <p>
                    Для вирішення більшості завдань, пов'язаних з безліччю класів, що задаються згідно з певними умовами, використовують бібліотеку clsx. Звичайно, JavaScript надає багатий синтаксис, але здебільшого пишуться непродуктивні рішення або код, що погано читається. Бібліотека стандартизує цей процес і робить його більш зручним за рахунок продуманого синтаксису.
                  </p>
                  <h3>npm install clsx</h3>
                  <p>
                    Функції clsx можна передати список виразів як набір аргументів. Вирази що приводяться до true, результат яких це рядок або число, буде додано у фінальний рядок класів.
                  </p>
                  <p class="exemplar">
                    import clsx from "clsx"; <br>
                    <br>
                    const className = clsx( <br>
                      "first", <br>
                      10, <br>
                      undefined && "second", <br>
                      true && "third", <br>
                      false ? "fourth" : "fifth" <br>
                    ); <br>
                    console.log(className); // "first 10 third fifth" <br>
                  </p>
                  <p>Ось як виглядатиме код компонента Alert використовуючи бібліотеку clsx.</p>
                  <p class="exemplar">
                    src/components/Alert.js <br>
                    import clsx from "clsx"; <br>
                    import "./Alert.css"; <br>
                    const Alert = ({ variant, outlined, elevated, children }) => { <br>
                      return ( <br>
                        < p <br>
                          className={clsx( <br>
                            "alert", <br>
                            variant, <br>
                            outlined && "is-outlined", <br>
                            elevated && "is-elevated" <br>
                          )} <br>
                        > <br>
                          {children} <br>
                        < /p> <br>
                      ); <br>
                    }; <br>
                  </p>
                  <h5 class="section-title__value">Препроцесори</h5>
                  <h3>npm install sass</h3>
                  <p>
                    Використовувати препроцесори можна, але можливість композиції компонентів робить їх менш корисними, оскільки замінює такі концепції як домішки, функції, вкладеність та інші. Не рекомендується використовувати одні й ті самі CSS-класи в різних компонентах, для цього є композиція компонентів. <br>
                     <br>
                    Наприклад, замість використання базового CSS-класу .button у компонентах < LoginButton> та < FollowButton>, краще створити компонент < Button> зі своїми власними стилями, які можуть відображатись у кількох варіантах. Тоді компоненти < LoginButton> та < FollowButton> можуть використовувати компонент < Button>, а не просто CSS-клас. <br>
                  </p>
                  <p class="exemplar">
                    // Button.js <br>
                    const Button = ({ variant, children }) => { <br>
                      // Базові стилі кнопки з кількома варіантами відображення <br>
                      return < button className={clsx("button", variant)}>{children}< /button>; <br>
                    }; <br>
                     <br>
                    // LoginButton.js <br>
                    const LoginButton = () => { <br>
                      // Унікальна логіка кнопки логіна <br>
                      return < Button variant="primary">Login< /Button>; <br>
                    }; <br>
                     <br>
                    // FollowButton.js <br>
                    const FollowButton = () => { <br>
                      // Унікальна логіка кнопки підписки <br>
                      return < Button variant="secondary">Follow< /Button>; <br>
                    }; <br>
                  </p>
                  <p>Правила іменування файлів такі ж, як і для ванільного CSS, відрізняється тільки розширення, наприклад .scss для SASS. В іншому у препроцесорів ті ж можливості, концепції та недоліки, що і у ванільного CSS. Для того щоб додати можливість використання SASS, встановіть його компілятор у проект.</p>
                  <h3>
                    Використання ванільного CSS теж не найкращий підхід і має ряд недоліків, особливо у великих проектах. <br>
                                       <br>
                    Слабка масштабованість <br>
                    Обмежене повторне використання стилів <br>
                    Для динамічних значень необхідно використовувати вбудовані стилі <br>
                    Проблема глобального простору імен <br>
                    Необхідність використовувати якусь конвенцію іменування селекторів класу <br>
                    Відсутність автоматичного видалення коду, що не використовується. <br>
                  </h3>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            
            <!-- Нормалізація стилів -->
            <li>
              <h4 class="section-title__name">Нормалізація стилів</h4>
              <ul>
                <li><a href="https://github.com/csstools/normalize.css" target="_blank" rel="noopener noreferrer">normalize.css</a></li>
                <li><a href="https://github.com/csstools/sanitize.css" target="_blank" rel="noopener noreferrer"> sanitize.css</a></li>
              </ul>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Стилі елементів можуть відрізнятись між браузерами. Для того, щоб привести їх до стандартного вигляду, необхідно додати набір правил, що виправляє відмінності у стилях елементів між браузерами, наскільки це можливо. <br>
                                       <br>
                    У Create React App вбудована можливість використовувати PostCSS Normalize - суміш кількох популярних таблиць стилів (normalize.css та sanitize.css) з найкращими практиками нормалізації. Все, що необхідно зробити - це додати директиву @import-normalize; у будь-якому місці файлу стилів або CSS-модуля. Повторюючі імпорти будуть автоматично видалені, тому достатньо додати директиву до одного файлу стилів, наприклад index.css. <br>
                  </p>
                  <p class="exemplar">
                    src/index.css <br>
                    @import-normalize; <br>
                    body { <br>
                      font-family: sans-serif; <br>
                      line-height: 1.5; <br>
                    } <br>
                    h1, <br>
                    h2, <br>
                    h3, <br>
                    h4, <br>
                    h5, <br>
                    h6, <br>
                    p { <br>
                      margin: 0; <br>
                    } <br>
                    ul, <br>
                    ol { <br>
                      margin: 0; <br>
                      padding: 0; <br>
                    } <br>
                    img { <br>
                      display: block; <br>
                      max-width: 100%; <br>
                      height: auto; <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            

            <!--  -->
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

          </ul>
        </div>
      </div>

      <!-- Компоненти-класи -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Компоненти-класи</h3>
          <h3>Модуль 2_1</h3>
          <h4>Назви компонентів пишуться з великої букви</h4>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Компоненти-класи -->
            <li>
              <h4 class="section-title__name">Компоненти-класи</h4>
              <img src="./img/js/component-class.jpg" width="400" alt="" />
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Якщо необхідно додати динаміки, компоненти створюються як класи, тому що компоненти-функції (до хуків) обмежені можливістю створення розмітки за отриманими пропсами.
                  </p>
                  <ul>
                    <li>
                      <p>Звичайний ES6 клас, тому застосовуються правила: конструктор, методи, контекст (this).</p>
                    </li>
                    <li>
                      <p>Обов'язково розширює базовий клас React.Component.</p>
                    </li>
                    <li>
                      <p>Діє як функція, яка отримує props, але також реалізує приватний внутрішній стан.</p>
                    </li>
                    <li>
                      <p>Необхідно оголосити обов'язковий метод render(), який викликається за замовчуванням і повертає JSX-розмітку.</p>
                    </li>
                    <li>
                      <p>Щоразу під час використання компонента-класу, React буде створювати екземпляр компонента (класу), тому доступ до пропсів відбувається через this.props.</p>
                    </li>
                    <li>
                      <p>Можна визначити кастомні методи класу і використовувати їх в будь-якому місці, зокрема всередині JSX, викликати або передавати дітям як пропси.</p>
                    </li>
                    <li>
                      <p>Коли змінюється стан або пропcи компонента, відбувається його ререндер.</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    // Відокремлюйте іменовані імпорти, це підвищує читабельність коду <br>
                    import React, { Component } from "react"; <br>
                    <br>
                    class MyClassComponent extends Component { <br>
                      static defaultProps = {}; <br>
                    <br>
                      static propTypes = {}; <br>
                    <br>
                      render() { <br>
                        return < div>Class Component< /div>; <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Події -->
            <li>
              <h4 class="section-title__name">Події</h4>
              <a href="https://uk.legacy.reactjs.org/docs/handling-events.html" target="_blank" rel="noopener noreferrer">Обробка подій</a>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">< button onClick={event => console.log(event)}>Click me!< /button></h5>
                  <p>
                    Для нативної події браузера в React створюється об'єкт-обгортка SyntheticEvent Object з ідентичним інтерфейсом. Це необхідно, щоб забезпечити крос-браузерність та оптимізувати продуктивність.
                  </p>
                  <ul>
                    <li>
                      <p>Додавання обробника подій з EventTarget.addEventListener() майже не використовується, за рідкісним винятком.</p>
                    </li>
                    <li>
                      <p>Пропси подій – не виняток та іменуються за допомогою camelCase. Наприклад onClick, onChange, onSubmit, onMouseEnter.</p>
                    </li>
                    <li>
                      <p>У проп події передається посилання на callback-функцію, яка буде викликана під час настання події.</p>
                    </li>
                    <li>
                      <p>Обробники подій отримують екземпляр SyntheticEvent Object.</p>
                    </li>
                  </ul>
                  <p>В React "під капотом" реалізовано делегування подій. Слухачі не додаються безпосередньо до DOM-елементів. Передача колбека – це просто реєстрація функції, яка буде викликана внутрішніми механізмами реакта під час настання події.</p>
                  <p class="exemplar">
                    return (
                    < div> <br>
                      < span>0< /span> <br>
                      < button type="button" onClick={this.handleIncrement.bind(this)}> <br>
                        Increment by {step} <br>
                      < /button> <br>
                      < button type="button" onClick={this.handleDecrement.bind(this)}> <br>
                        Decrement by {step} <br>
                      < /button> <br>
                    < /div> <br>
                  ); <br>
                  </p>
                  <h5 class="section-title__value">Прив'язка контексту (використовуємо такий спосіб)</h5>
                  <p>
                    Потрібно завжди пам'ятати про значення this у методах, що використовуються як callback-функції. В JavaScript контекст у методах класу не прив'язується за замовчуванням. Якщо забути прив'язати контекст, і передати метод як callback-функцію обробнику події, під час виклику функції this буде невизначений (undefined).
                  </p>
                  <p>
                    Тобто, коли передаємо колбек функції для обробки подій то потрібно передавати не як звичайний метод класу <br>
                    <br>
                    // ❌ Погано <br>
                    class Counter extends Component { <br>
                      /* ... */ <br>
                     <br>
                      handleIncrement(evt) { <br>
                        // ... <br>
                      } <br>
                      <br>
                      а передаємо як стрілочну функцію щоб привязало контекст <br>
                      <br>
                      // ✅ Добре <br>
                      class Counter extends Component { <br>
                        /* ... */ <br>
                       <br>
                        handleIncrement = evt => { <br>
                          /* ... */<br>
                        }; <br>
                  </p>
                  <h5 class="section-title__value">Прив'язка в конструкторі</h5>
                  <p>
                    Ще один спосіб прив'язати контекст – зробити це у конструкторі класу. Якщо callback-функцій багато, можете уявити, наскільки великий може вийти конструктор. <br>
                                       <br>
                    Конструктор виконується один раз, тому bind викликається один раз <br>
                    Методи класу записуються у властивість prototype функції-конструктора <br>
                    <br>
                    // ✅ Непогано <br>
                    class Counter extends Component { <br>
                      /* ... */ <br>
                     <br>
                      constructor() { <br>
                        super(); <br>
                        this.handleIncrement = this.handleIncrement.bind(this); <br>
                        this.handleDecrement = this.handleDecrement.bind(this); <br>
                      } <br>
                  </p>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Внутрішній стан компонента</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Об'єкт-стану state – це властивість класу, яка не повинна безпосередньо змінюватися розробником.
                  </p>
                  <ul>
                    <li>
                      <p>Дані в state контролюють те, що відображається в інтерфейсі.</p>
                    </li>
                    <li>
                      <p>Дані, що зберігаються у стані, повинні бути інформацією, яка буде оновлюватися методами компонента.</p>
                    </li>
                    <li>
                      <p>Не потрібно дублювати дані з props у стані.</p>
                    </li>
                    <li>
                      <p>Щоразу, коли змінюється стан компонента (або пропси), викликається метод render().</p>
                    </li>
                    <li>
                      <p>Інтерфейс залежить від стану компонента.</p>
                    </li>
                    <li>
                      <p>Стан може змінитися як реакція на дії користувача.</p>
                    </li>
                    <li>
                      <p>Під час зміни стану дані передаються вниз по дереву компонентів.</p>
                    </li>
                    <li>
                      <p>Компоненти повертають оновлену розмітку і змінюється інтерфейс.</p>
                    </li>
                  </ul>
                  <p>
                    Стан належить компоненту і змінюється тільки його методами. <br>
                    Стан оголошується в конструкторі, оскільки це перше, що відбувається, коли створюється екземпляр класу.
                  </p>
                  <p class="exemplar">
                    class Counter extends Component { <br>
                      constructor() { <br>
                        super(); <br>
                       <br>
                        this.state = { <br>
                          value: 0, <br>
                        }; <br>
                      } <br>
                     <br>
                      render() { <br>
                        return ( <br>
                          < div> <br>
                            < span>{this.state.value}< /span> <br>
                            {/* ... */} <br>
                          < /div> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>

                    <h5 class="section-title__value">Початковий стан від props (як задати дефолтні значення в класах)</h5>
                  <p class="exemplar">
                    class Counter extends Component { <br>
                    static defaultProps = { <br>
                      step: 1, <br>
                      initialValue: 0, <br>
                    }; <br>
                   <br>
                    constructor(props) { <br>
                      super(props); <br>
                     <br>
                      this.state = { <br>
                        value: this.props.initialValue, <br>
                      }; <br>
                    } <br>
                  </p>
                  <h3>В реакті не потрібно створювати конструктор а вказуємо стан як публічну властивість, все інше за нас зробить Babel</h3>
                 <div class="exemplar section-box">
                   <p >
                    В МІСТО ЦЬОГО constructor() <br>
                    class Counter extends Component {                     <br>
                      constructor(props) { <br>
                        super(props); <br>
                        <br>
                        this.state = {value: this.props.initialValue, }} <br>
                    } <br>
                  </p>
                  <p class="selection">
                     СТВОРЮЄМО state = {} <br>
                    class Counter extends Component {                      <br>
                      state = {value: this.props.initialValue,};                     <br>
                    // ... // <br>
                    } <br>
                  </p>
                 </div>

                    <h5 class="section-title__value">Зміна стану компонента</h5>
                    <h3>Для оновлення стану використовується вбудований метод setState().</h3>
                    <p class="selection">setState(updater, callback)</p>
                    <ul>
                      <li><p>Першим, обов'язковим аргументом, передається об'єкт з полями, які вказують, яку частину стану необхідно змінити.</p></li>
                      <li><p>Другим, необов'язковим аргументом, можна передати callback-функцію, яка виконається після зміни стану.</p></li>
                    </ul>
                    <p>
                      class Toggle extends Component { <br>
                        state = { isOpen: false }; <br>
                                             <br>
                        show = () => this.setState({ isOpen: true }); <br>
                                             <br>
                        hide = () => this.setState({ isOpen: false }); <br>
                                             <br>
                        render() { <br>
                          const { isOpen } = this.state; <br>
                          const { children } = this.props; <br>
                         <br>
                          return ( <br>
                            <> <br>
                              < button onClick={this.show}>Show< /button> <br>
                              < button onClick={this.hide}>Hide< /button> <br>
                              {isOpen && children} <br>
                            </> <br>
                          ); <br>
                        } <br>
                      } <br>
                    </p>
                    <p>
                      Під час виклику setState() не потрібно передавати всі властивості, що зберігаються у стані. Достатньо вказати лише ту частину (зріз) стану, яку ми хочемо змінити у цій операції.
                    </p>
                    <p>
                      Актуальний стан і пропси на момент асинхронного виконання функції, переданої в setState(), будуть передані в неї аргументами state і props. Таким чином, можна бути впевненими у коректному значенні попереднього стану під час створення наступного.
                    </p>
                    

                    <h5 class="section-title__value">setState з функцією нове значення обчислюється на підставі попереднього стану (prevState -попередній стан)</h5>
                  <p></p>
                  <div class="section-box exemplar">

                      <p >
                        // Припустимо, що є такий стан <br>
                        state = { value: 0 }; <br>
                        <br>
                        // Запустимо цикл і створимо 3 операції оновлення <br>
                        for (let i = 0; i < 3; i += 1) { <br>
                          // Якщо переглянути стан, на всіх ітераціях буде 0 <br>
                          // Тому що це синхронний код та оновлення стану ще не відбулося <br>
                          console.log(this.state.value); // 0 <br>
                        <br>
                          this.setState(prevState => { <br>
                            // Якщо переглянути стан, переданий callback-функції під час її виклику, <br>
                            // отримаємо актуальний стан на момент оновлення. <br>
                            console.log(prevState.value); // буде різний на кожній ітерації <br>
                          <br>
                            return { value: prevState.value + 1 }; <br>
                          }); <br>
                        } <br>
                      </p>
                      <p>
                        Тепер можемо замінити функціонал відкрити/закрити у компоненті <Toggle>. <br>
                        <br>
                        class Toggle extends Component { <br>
                          state = { isOpen: false }; <br>
                          <br>
                          toggle = () => { <br>
                            this.setState(state => ({ isOpen: !state.isOpen })); <br>
                          }; <br>
                          <br>
                          render() { <br>
                            const { isOpen } = this.state; <br>
                            const { children } = this.props; <br>
                          <br>
                            return ( <br>
                              < div> <br>
                                < button onClick={this.toggle}>{isOpen ? "Hide" : "Show"}< /button> <br>
                                {isOpen && children} <br>
                              < /div> <br>
                            ); <br>
                          } <br>
                        } <br>
                      </p>
                    </div>

                    <h5 class="section-title__value">Підіймання стану (зміна стану батька під час події в дитині)</h5>
                  <p>
                    Оскільки React використовує односпрямований потік даних зверху вниз, для того щоб змінити стан батька під час події в дитині, використовується наступний патерн з callback-функцією.
                  </p>
                  <ul>
                    <li>
                      <p>У батька є стан і метод, який його змінює.</p>
                    </li>
                    <li>

                      <p>Дочірньому елементу у формі пропу передається метод батька, що змінює стан батька.</p>
                    </li>
                    <li>

                      <p>У дочірньому елементі відбувається виклик переданого йому методу. – Під час виклику цього методу змінюється стан батька.</p>
                    </li>
                    <li>

                      <p>Відбувається рендер піддерева компонентів батька.</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    // Button отримує функцію changeMessage (ім'я пропа), <br>
                    // яка викликається під час події onClick <br>
                    const Button = ({ changeMessage, label }) => ( <br>
                      < button type="button" onClick={changeMessage}> <br>
                        {label} <br>
                      < /button> <br>
                    ); <br>
                     <br>
                    class App extends Component { <br>
                      state = { <br>
                        message: new Date().toLocaleTimeString(), <br>
                      }; <br>
                     <br>
                      // Метод, який будемо передавати в Button для виклику під час кліку <br>
                      updateMessage = evt => { <br>
                        console.log(evt); // Доступний об'єкт події <br>
                        this.setState({ <br>
                          message: new Date().toLocaleTimeString(), <br>
                        }); <br>
                      }; <br>
                     <br>
                      render() { <br>
                        return ( <br>
                          <> <br>
                            < span>{this.state.message}< /span> <br>
                            < Button label="Change message" changeMessage={this.updateMessage} /> <br>
                          </> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>

                  <h5 class="section-title__value">Типи внутрішніх даних компонента-класу</h5>
                  <ul>
                    <li>
                      <h3>static data</h3> – статичні властивості і методи, до яких необхідно отримувати доступ без екземпляра.
                    </li>
                    <li>
                      <h3>this.state.data</h3> – динамічні дані, що змінюються методами компонента, стан.
                    </li>
                    <li>
                      <h3>this.data</h3> – дані, які будуть різні для кожного екземпляра.
                    </li>
                    <li>
                      <h3>const DATA</h3> – константи, дані, які не змінюються, та однакові для всіх екземплярів.
                    </li>
                  </ul>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Форми -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Форми</h3>
          <h3>Модуль 2_2</h3>
          <h3>Модуль 2_3 Formik</h3>
          <a href="https://formik.org/" target="_blank" rel="noopener noreferrer">Formik Створюйте форми в React</a>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Неконтрольовані елементи -->
            <li>
              <h4 class="section-title__name">Неконтрольовані елементи</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Такий прийом доречно використовувати, коли дані полів форми потрібні тільки під час її сабміту.</h5>
                  <p>отримати дані користувача</p>
                  <p class="exemplar">
                    class LoginForm extends Component { <br>
                      handleSubmit = evt => { <br>
                        evt.preventDefault(); <br>
                        const form = evt.currentTarget; <br>
                        const login = form.elements.login.value; <br>
                        const password = form.elements.password.value; <br>
                        console.log(login, password); <br>
                        this.props.onSubmit({ login, password }); <br>
                        form.reset(); <br>
                      }; <br>
                      <br>
                      render() { <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            < input type="text" name="login" /> <br>
                            < input type="password" name="password" /> <br>
                            < button type="submit">Login< /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                    <br>
                    ReactDOM.render( <br>
                      < LoginForm onSubmit={values => console.log(values)} />, <br>
                      document.getElementById("root") <br>
                    ); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Контрольовані елементи -->
            <li>
              <h4 class="section-title__name">Контрольовані елементи</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Якщо значення елементів форм необхідно отримати в момент зміни поля і зробити щось динамічно</h5>
                  <p>Якщо значення елементів форм необхідно отримати в момент зміни поля і зробити щось динамічно, вони повинні бути контрольовані. Тобто значення всіх полів повинні бути в state. Цей прийом роботи з елементами форм – досить простий.</p>
                  <p>
                    Поле в state визначає значення атрибуту value поля <br>
                    Події onChange передається метод, що змінює поле в стані <br>
                    Отримуємо замкнене коло. <br>
                                       <br>
                    Під час події onChange метод класу оновлює поле в стані <br>
                    Під час зміни стану відбувається ререндер <br>
                    Інпут відображається з оновленими даними <br>
                    Недолік у тому, що вся форма буде повторно рендеритися під час кожної зміни будь-якого поля, але для невеликих форм – це не проблема. <br>
                  </p>
                  <p class="exemplar">
                    class App extends Component { <br>
                      state = { <br>
                        inputValue: "", <br>
                      }; <br>
                     <br>
                      handleChange = evt => { <br>
                        this.setState({ inputValue: evt.target.value }); <br>
                      }; <br>
                     <br>
                      render() { <br>
                        const { inputValue } = this.state; <br>
                        return ( <br>
                          < input type="text" value={inputValue} onChange={this.handleChange} /> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Складні форми -->
            <li>
              <h4 class="section-title__name">Складні форми</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Створимо форму реєстрації.</h5>
                  <p class="exemplar">
                    // Виносимо об'єкт із примітивами в константу, щоб було зручно скидати. <br>
                    // Не можна використовувати, якщо в якійсь властивості стану зберігається складний тип. <br>
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                    }; <br>
                     <br>
                    class SignUpForm extends React.Component { <br>
                      state = { ...INITIAL_STATE }; <br>
                     <br>
                      // Для всіх інпутів створюємо один обробник <br>
                      // Розрізняти інпути будемо за атрибутом name <br>
                      handleChange = evt => { <br>
                        const { name, value } = evt.target; <br>
                        this.setState({ [name]: value }); <br>
                      }; <br>
                     <br>
                      handleSubmit = evt => { <br>
                        evt.preventDefault(); <br>
                        const { login, email, password } = this.state; <br>
                        console.log(`Login: ${login}, Email: ${email}, Password: ${password}`); <br>
                        this.props.onSubmit({ ...this.state }); <br>
                        this.reset(); <br>
                      }; <br>
                     <br>
                      reset = () => { <br>
                        this.setState({ ...INITIAL_STATE }); <br>
                      }; <br>
                     <br>
                      render() { <br>
                        const { login, email, password } = this.state; <br>
                       <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            < label> <br>
                              Name <br>
                              < input <br>
                                type="text" <br>
                                placeholder="Enter login" <br>
                                name="login" <br>
                                value={login} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                            < label> <br>
                              Email <br>
                              < input <br>
                                type="email" <br>
                                placeholder="Enter email" <br>
                                name="email" <br>
                                value={email} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                            < label> <br>
                              Password <br>
                              < input <br>
                                type="password" <br>
                                placeholder="Enter password" <br>
                                name="password" <br>
                                value={password} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                              <br>
                            < button type="submit">Sign up as {login}< /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Генерація Id елементів форми -->
            <li>
              <h4 class="section-title__name">Генерація Id елементів форми</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">label  та input кожної форми повинні мати одинаковий ІД</h5>
                  <p>
                    Доступність (accessibility, a11y) – дуже важлива тема в сучасному вебі. HTML-атрибут for тегу label допомагає асистивним технологіям та іншим допоміжним інструментам. В React він представлений jsx-атрибутом htmlFor. <br>
                                       <br>
                    Для генерації унікальних ідентифікаторів елементів форм використовується наступний підхід: для кожного екземпляра компонента, під час його ініціалізації, створюється набір унікальних ідентифікаторів, що зберігаються на екземплярі. Таким чином, між різними формами одержуємо унікальні id. <br>
                  </p>
                  <p class="exemplar">
                    // Можна використовувати будь-який пакет для генерації унікальних рядків <br>
                    import { nanoid } from "nanoid"; <br>
                    <br>
                    class Form extends React.Component { <br>
                      loginInputId = nanoid(); <br>
                      <br>
                      render() { <br>
                        return ( <br>
                          < form> <br>
                            < label htmlFor={this.loginInputId}>Login< /label> <br>
                            < input type="text" name="login" id={this.loginInputId} /> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Чекбокси -->
            <li>
              <h4 class="section-title__name">Чекбокси</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Робота з чекбоксами – проста та зрозуміла. Чекбокс може бути всього у 2-х станах: true або false. <br>
                                       <br>
                    Особливості чекбоксів: <br>
                                       <br>
                    Ім'я атрибута, якому передається поточне значення зі state. Для чекбоксів – це checked, і передаємо туди буль <br>
                    Під час обробки події onChange, для отримання значення, в об'єкті події звертаємось до властивості event.target.checked <br>
                    Якщо чекбокс повинен зберігати значення, його можна повісити на атрибут value і прочитати з об'єкта події <br>

                  </p>
                  <p class="exemplar">
                    Додамо до нашої форми реєстрації чекбокс для підтвердження згоди користувача, і зробимо кнопку сабміту неактивною, доки неактивний чекбокс. <br>
                                      <br>
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                      agreed: false, <br>
                    }; <br>
                    <br>
                    class SignUpForm extends React.Component { <br>
                      state = { <br>
                        ...INITIAL_STATE, <br>
                      }; <br>
                    <br>
                      handleChange = evt => { <br>
                        const { name, value, type, checked } = evt.target; <br>
                        // Якщо тип елемента – checkbox, беремо значення checked, <br>
                        // в іншому випадку – value <br>
                        this.setState({ [name]: type === "checkbox" ? checked : value }); <br>
                      }; <br>
                    <br>
                      handleSubmit = e => { <br>
                        e.preventDefault(); <br>
                        const { login, email, password, agreed } = this.state; <br>
                        console.log( <br>
                          `Login: ${login}, Email: ${email}, Password: ${password}, Agreed: ${agreed}` <br>
                        ); <br>
                      <br>
                        /* ... */ <br>
                      }; <br>
                    <br>
                      render() { <br>
                        const { login, email, password, agreed } = this.state; <br>
                        <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            {/* ... */} <br>
                            < label> <br>
                              Agree to terms <br>
                              < input <br>
                                type="checkbox" <br>
                                checked={agreed} <br>
                                onChange={this.handleChange} <br>
                              /> <br>
                            < /label> <br>
                              <br>
                            < button type="submit" disabled={!agreed}> <br>
                              Sign up as {login} <br>
                            < /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Радіокнопки -->
            <li>
              <h4 class="section-title__name">Радіокнопки</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    На відміну від звичного групування за значенням атрибуту name, в React радіокнопка – це лише елемент інтерфейсу, який: <br>
                                       <br>
                    Знає, чи він вибраний <br>
                    Може попросити форму змінити виділення <br>
                    Зазвичай у радіокнопок є і атрибут checked і value. Наприклад, радіокнопка, що відповідає за вибір статі користувача. <br>
                                       <br>
                    < input <br>
                      type="radio" <br>
                      checked={this.state.gender === "male"} <br>
                      value="male" <br>
                      onChage={this.handleGenderChage} <br>
                    /> <br>
                  </p>
                  <p class="exemplar">
                    Додамо групу радіокнопок у нашу форму. <br>
                    <br>
                    // Використовуємо Enumerable, щоб не створювати антипатерн "магічні рядки" <br>
                                      <br>
                    const Gender = { <br>
                      MALE: "male", <br>
                      FEMALE: "female", <br>
                    }; <br>
                    <br>
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                      agreed: false, <br>
                      gender: null, <br>
                    }; <br>
                    <br>
                    class SignUpForm extends React.Component { <br>
                      state = { <br>
                        ...INITIAL_STATE, <br>
                      }; <br>
                    <br>
                      /*... */ <br>
                    <br>
                      render() { <br>
                        const { login, email, password, agreed, gender } = this.state; <br>
                      <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            {/* ... */} <br>
                      <br>
                            < section> <br>
                              < h2>Choose your gender< /h2> <br>
                              < label> <br>
                                Male <br>
                                < input <br>
                                  type="radio" <br>
                                  checked={gender === Gender.MALE} <br>
                                  name="gender" <br>
                                  value={Gender.MALE} <br>
                                  onChange={this.handleChange} <br>
                                /> <br>
                              < /label> <br>
                              < label> <br>
                                Female <br>
                                < input <br>
                                  type="radio" <br>
                                  checked={gender === Gender.FEMALE} <br>
                                  name="gender" <br>
                                  value={Gender.FEMALE} <br>
                                  onChange={this.handleChange} <br>
                                /> <br>
                              < /label> <br>
                            < /section> <br>
                      <br>
                            < button type="submit" disabled={!agreed}> <br>
                              Sign up as {login} <br>
                            < /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Селект -->
            <li>
              <h4 class="section-title__name">Селект</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>Все просто – є селект, є опції, у селекта є value та onChange. Додаємо вибір вікової категорії.</p>
                  <p class="exemplar">
                    const INITIAL_STATE = { <br>
                      login: "", <br>
                      email: "", <br>
                      password: "", <br>
                      agreed: false, <br>
                      gender: null, <br>
                      age: "", <br>
                    }; <br>
                      <br>
                    class SignUpForm extends React.Component { <br>
                      state = { <br>
                        ...INITIAL_STATE, <br>
                      }; <br>
                      <br>
                      /* ... */ <br>
                      <br>
                      render() { <br>
                        const { login, email, password, agreed, gender, age } = this.state; <br>
                          <br>
                        return ( <br>
                          < form onSubmit={this.handleSubmit}> <br>
                            {/* ... */} <br>
                              <br>
                            < label> <br>
                              Choose your age <br>
                              < select name="age" value={age} onChange={this.handleChange}> <br>
                                < option value="" disabled> <br>
                                  ... <br>
                                < /option> <br>
                                < option value="18-25">18-25< /option> <br>
                                < option value="26-35">26-35< /option> <br>
                                < option value="36+">36+< /option> <br>
                              < /select> <br>
                            < /label> <br>
                              <br>
                            < button type="submit" disabled={!agreed}> <br>
                              Sign up as {login} <br>
                            < /button> <br>
                          < /form> <br>
                        ); <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Життєвий цикл -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Життєвий цикл</h3>
          <h3>Модуль 3_1 (+модалка)</h3>
          <p>
            Всього є сім методів життєвого циклу, якщо не рахувати render і constructor. На практиці, в більшості повсякденних завдань використовують три: componentDidMount, componentDidUpdate і componentWillUnmount.
            <br>
            Існує кілька стадій життєвого циклу – монтування, оновлення та розмонтування. Під час кожної з них у компонента-класу викликаються методи, що наслідуються від React.Component. Ми можемо перевизначити їхню поведінку, додавши необхідний функціонал в рамках встановлених правил.
          </p>
          <img src="./img/react/react-life-cycle.jpg" width="600" alt="" />
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!-- Стадія монтування -->
            <li>
              <h4 class="section-title__name">Стадія монтування</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentDidMount() {}</h5>
                  <ul>
                    <li>
                      <p>Викликається відразу після монтування компонента в DOM</p>
                    </li>
                    <li>
                      <p>Робимо HTTP-запити, вішаємо кастомні слухачі подій та виконуємо операції з DOM деревом</p>
                    </li>
                    <li>
                      <p>Виклик setState() у цьому методі викличе повторний рендер – це нормально</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    async componentDidMount() { <br>
                      const response = await axios.get("/search?query=react"); <br>
                      this.setState({ articles: response.data.hits }); <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Стадія оновлення -->
            <li>
              <h4 class="section-title__name">Стадія оновлення</h4>
              <p>Оновлення може бути викликано зміною state самого компонента або props, що йому передаються. Під час оновлення необхідно перерендерити компонент</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentDidUpdate(prevProps, prevState, snapshot) {}</h5>
                  <ul>
                    <li>
                      <p>Викликається відразу після оновлення компонента в DOM</p>
                    </li>
                    <li>
                      <p>Не викликається при початковому рендері компонента</p>
                    </li>
                    <li>
                      <p>Можна викликати setState(), обов'язково обгорнувши його в умову перевірки зміни попередніх і наступних props або state, щоб не виник нескінченний цикл ререндера (вкладка зависне або впаде).</p>
                    </li>
                    <li>
                      <p>Можна робити HTTP-запити</p>
                    </li>
                    <li>
                      <p>Якщо в компоненті є getSnapshotBeforeUpdate(), то значення, що повертається їм, буде передане третім аргументом snapshot, в іншому випадку його значенням буде undefined</p>
                    </li>
                  </ul>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Стадія розмонтування -->
            <li>
              <h4 class="section-title__name">Стадія розмонтування</h4>
              <p>У якийсь момент компонент буде видалений з DOM. При цьому викликається наступний метод.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentWillUnmount() {}</h5>
                  <ul>
                    <li>
                      <p>Викликається перед розмонтуванням та видаленням елемента з DOM</p>
                    </li>
                    <li>
                      <p>Добре підходить для прибирання за собою: слухачі, таймери, HTTP-запити. В іншому випадку будуть витоки пам'яті</p>
                    </li>
                    <li>
                      <p>Викликати setState() немає сенсу, компонент ніколи не перерендериться</p>
                    </li>
                  </ul>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Обробка помилок рендеру -->
             <li>
              <h4 class="section-title__name">Обробка помилок рендеру</h4>
              <p>React дуже любить класти весь застосунок за будь-якої помилки. Метод componentDidCatch спрацьовує у разі помилки у дочірньому компоненті та дозволяє батьківським компонентам відловлювати помилки у дітей, відображаючи запасний інтерфейс. В результаті, у разі помилки, інтерфейс не падає.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">componentDidCatch(error, info) {}</h5>
                  <ul>
                    <li>
                      <p>Використовується для контролю помилок</p>
                    </li>
                    <li>
                      <p>Ловить помилки лише у дітей, але не в самому батьку</p>
                    </li>
                    <li>
                      <p>error – результат toString() об'єкта помилки</p>
                    </li>
                    <li>
                      <p>info – об'єкт, що описує stack trace</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    class ErrorBoundary extends React.Component { <br>
                      state = { hasError: false }; <br>
                                         <br>
                      componentDidCatch(error, info) { <br>
                        // Якщо метод був викликаний, отже, є помилка! <br>
                        // Встановлюємо стан <br>
                        this.setState({ hasError: true }); <br>
                        // Також можна надіслати звіт про помилку вашому аналітичному сервісу <br>
                        // logErrorToMyService(error, info); <br>
                      } <br>
                     <br>
                      render() { <br>
                        // Якщо є помилка... <br>
                        if (this.state.hasError) { <br>
                          // Рендеримо fallback UI <br>
                          return < h1>Something went wrong, please try again later :(< /h1>; <br>
                        } <br>
                       <br>
                        // Якщо все ок, рендеримо дітей <br>
                        return this.props.children; <br>
                      } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- HTTP-запити -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">HTTP-запити</h3>
          <h3>Модуль 3_2</h3>
       
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <!--  -->
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                     <p>
            Який саме компонент в ієрархії повинен відповідати за HTTP-запити і зберігання результату відповіді? Якщо не використовуємо бібліотеку управління станом, то це залежить від трьох критеріїв. <br>
                       <br>
            Яким компонентам будуть необхідні отримані дані? <br>
            Де буде рендеритися індикатор завантаження, доки виконується HTTP-запит? <br>
            Де буде рендеритися повідомлення у разі помилки HTTP-запиту? <br>
            Методи життєвого циклу componentDidMount та componentDidUpdate ідеально підходять для HTTP-запитів. Коли викликається componentDidMount(), компонент вже був відрендерений у DOM і готовий до подальшого оновлення стану. Коли викликається componentDidUpdate(), пропи або стан компонента змінилися, і, можливо, необхідно зробити новий запит, попередньо порівнявши їх, щоб не зациклити рендер компонента. <br>
                       <br>
            Для HTTP-запиту можна використовувати будь-що: XMLHTTPRequest, fetch, axios, superagent тощо. Ми будемо використовувати бібліотеку axios. <br>
          </p>
                  <p>
                    import React, { Component } from "react"; <br>
                    mport axios from "axios"; <br>
                                       <br>
                    xios.defaults.baseURL = "https://hn.algolia.com/api/v1"; <br>
                                       <br>
                    onst ArticleList = ({ articles }) => ( <br>
                     < ul> <br>
                       {articles.map(({ objectID, url, title }) => ( <br>
                         < li key={objectID}> <br>
                           < a href={url} target="_blank" rel="noreferrer noopener"> <br>
                             {title} <br>
                           < /a> <br>
                         < /li> <br>
                       ))} <br>
                     < /ul> <br>
                    ; <br>
                                       <br>
                    lass App extends Component { <br>
                     state = { <br>
                       articles: [], <br>
                     }; <br>
                   <br>
                     async componentDidMount() { <br>
                       const response = await axios.get("/search?query=react"); <br>
                       this.setState({ articles: response.data.hits }); <br>
                     } <br>
                   <br>
                     render() { <br>
                       const { articles } = this.state; <br>
                       return ( <br>
                         < div> <br>
                           articles.length > 0 ? < ArticleList articles={articles} /> : null <br>
                         < /div> <br>
                       ); <br>
                     } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Індикатор завантаження (Спінер, Лоадер) -->
            <li>
              <h4 class="section-title__name">Індикатор завантаження (Спінер, Лоадер)</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Доки чекаємо на відповідь на HTTP-запит, показуємо індикатор завантаження. Щойно надійшла відповідь, ховаємо індикатор. Для цього, на старті запиту ставимо isLoading – true, а у разі успішної відповіді або помилки – false.
                  </p>
                  <p class="exemplar">
                    /* ... */ <br>
                                       <br>
                    class App extends Component { <br>
                      state = { <br>
                        articles: [], <br>
                        isLoading: false, <br>
                      }; <br>
                     <br>
                      async componentDidMount() { <br>
                        this.setState({ isLoading: true }); <br>
                        const response = await axios.get("/search?query=react"); <br>
                        this.setState({ <br>
                          articles: response.data.hits, <br>
                          isLoading: false, <br>
                        }); <br>
                      } <br>                   
                    <br>
                    В методі render за умовою повертаємо розмітку. Якщо дані завантажуються, показуємо лоадер, в іншому випадку – список з результатами. <br>
                    <br>
                    render() { <br>
                      const { articles, isLoading } = this.state; <br>
                      return ( <br>
                        < div> <br>
                          isLoading ? < p>Loading...< /p> : < ArticleList articles={articles} /> <br>
                        < /div> <br>
                      ); <br>
                    } <br>
                  </p>
                  <p>
                    Індикатор завантаження може бути будь-чим: від простого тексту або спінера до кастомного компонента, наприклад react-content-loader.
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Обробка помилки -->
            <li>
              <h4 class="section-title__name">Обробка помилки</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    HTTP-запит не завжди виконується без помилок, тому користувачеві обов'язково потрібно дати зрозуміти, якщо щось пішло не так. Для цього у стан додаємо властивість зберігання помилки. <br>
                                       <br>
                    При використанні промісів для обробки помилок використовується блок catch, якщо він виконається, значить, сталася помилка. Встановлення індикатора завантаження переносимо в блок finally, щоб не дублювати код, який буде виконаний в будь-якому випадку. <br>
                  </p>
                  <p class="exemplar">
                    /* ... */ <br>
                                       <br>
                    class App extends Component { <br>
                      state = { <br>
                        articles: [], <br>
                        isLoading: false, <br>
                        error: null, <br>
                      }; <br>
                     <br>
                      async componentDidMount() { <br>
                        this.setState({ isLoading: true }); <br>
                       <br>
                        try { <br>
                          const response = await axios.get("/search?query=react"); <br>
                          this.setState({ articles: response.data.hits }); <br>
                        } catch (error) { <br>
                          this.setState({ error }); <br>
                        } finally { <br>
                          this.setState({ isLoading: false }); <br>
                        } <br>
                      } <br>
                     <br>
                      render() { <br>
                        const { articles, isLoading, error } = this.state; <br>
                       <br>
                        return ( <br>
                          < div> <br>
                            {error && < p>Whoops, something went wrong: {error.message}< /p>} <br>
                            {isLoading && < p>Loading...< /p>} <br>
                            {articles.length > 0 && < ArticleList articles={articles} />} <br>
                          < /div> <br>
                        ); <br>
                      } <br>
                    } <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <!-- Поділ відповідальності -->
              <li>
              <h4 class="section-title__name">Поділ відповідальності</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Зберігати код, пов'язаний з HTTP-запитом, безпосередньо в компоненті – не найкраща практика. У застосунку буде багато різних запитів до API і вони будуть використовуватися у різних компонентах. До того ж код HTTP-запитів може бути складним та громіздким. Для зручності рефакторингу будемо все зберігати в одному місці. <br>
                                       <br>
                    Створимо додаткову папку всередині src. Назва папки довільна, але логічна, наприклад helpers, api, services тощо. У цій папці будемо зберігати файл з функціями для HTTP-запитів. <br>
                  </p>
                  <div class="section-box exemplar">
                    <p>
                      // services/api.js <br>
                      import axios from "axios"; <br>
                                           <br>
                      export const fetchArticlesWithQuery = async searchQuery => { <br>
                        const response = axios.get(`/search?query=${searchQuery}`); <br>
                        return response.data.hits; <br>
                      }; <br>
                       <br>
                      export default { <br>
                        fetchArticlesWithQuery, <br>
                      }; <br>
                    </p>
                    <p>
                      /* ... */ <br>
                      import api from "./path/to/services/api"; <br>
                                           <br>
                      class App extends Component { <br>
                        state = { <br>
                          articles: [], <br>
                          isLoading: false, <br>
                          error: null, <br>
                        }; <br>
                       <br>
                        async componentDidMount() { <br>
                          this.setState({ isLoading: true }); <br>
                         <br>
                          try { <br>
                            const articles = api.fetchArticlesWithQuery("react"); <br>
                            this.setState({ articles }); <br>
                          } catch (error) { <br>
                            this.setState({ error }); <br>
                          } finally { <br>
                            this.setState({ isLoading: false }); <br>
                          } <br>
                        } <br>
                       <br>
                        /* ... */ <br>
                      } <br>
                    </p>
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!--  -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">title</h3>
          <h3></h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
      <!--  -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">title</h3>
          <h3></h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
      <!--  -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">title</h3>
          <h3></h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

    </main>

    <footer class="footer"></footer>

  </body>
</html>
