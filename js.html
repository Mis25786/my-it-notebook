<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script
      src="https://kit.fontawesome.com/7f832f4aea.js"
      crossorigin="anonymous"
    ></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Kaushan+Script&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Tilt+Prism&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="./style.css" />
    <title>Конспект-ІТ</title>
  </head>
  
  <body>
    <div class="wrapper">
    <header class="header">
      <a class="logo" href="./index.html">Конспект-ІТ</a>
      <nav class="header-nav">
        <a class="header-page" href="./html.html">html/css</a>
        <a class="header-page" href="./image.html">Зображення</a>
        <a class="header-page" href="./animations.html">Анімації/Ефекти</a>
        <a class="header-page" href="./js.html">JavaScript</a>
        <a class="header-page" href="./react.html">React</a>
        <a class="header-page" href="./node.html">Node</a>
        <a class="header-page" href="./typescript.html">TypeScript</a>
        <a class="header-page" href="./commponents.html">Компоненти</a>
        <a class="header-page" href="./resources.html">Ресурси/Бібліотеки</a>
        <a class="header-page" href="./terminal.html">Термінал</a>
        <a class="header-page" href="./help.html">Фішки</a>
        <a class="header-page" href="./works.html">Мої роботи</a>
      </nav>
      <div class="header-search">
        <i class="fa-solid fa-magnifying-glass"></i>
        <input
          class="header-search__input"
          type="text"
          name="text"
          placeholder="site search"
        />
      </div>
    </header>
    </div>

    <main class="main">
      <!-- Підключення JS до проекту -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Підключення JS до проекту</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/wdViO9OcQzs?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >JAVASCRIPT Frilancer</a
              >
            </li>
            <li>
              <a href="https://youtu.be/CxgOKJh4zWE" target="_blank" rel="noopener noreferrer">JavaScript - Полный Курс JavaScript Для Начинающих [11 ЧАСОВ]</a>
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <ol>
                    <h4>Щоб підключити JavaScript із зовнішнього файлу:</h4>
                    <li>Створіть в папці проекту файл з розширенням .js</li>
                    <li>
                      Потім вкажіть шлях до файлу скрипту в атрибуті src тегу
                      script.
                    </li>
                    <img src="./img/js/підключення-джс.jpg" alt="" />
                  </ol>

                  <h5 class="section-title__value">
                    Підключення декілька скриптів
                  </h5>
                  <p>
                    Підключаючи декілька JavaScript-файлів до сторінки,
                    інтерпретатор обробляє їх у тому порядку, в якому вони
                    зазначені в HTML-файлі.
                  </p>
                  <img src="./img/js/підключення-джс-2.jpg" alt="" />

                  <h5 class="section-title__value">Суворий режим</h5>
                  <p>
                    Для того, щоб перевести скрипт в суворий режим, достатньо
                    зазначити директиву на початку js-файлу. Завжди пишіть код в
                    суворому режимі. <br />
                    <br />
                    В файлі script.js прописуємо - "use strict"; <br />
                    <br />
                  </p>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>

                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Завантаження і виконання скрипта, зазначеного в тезі script
                    без будь-яких атрибутів, блокують обробку HTML-документа і
                    побудову DOM. Це проблема. <br />
                    <br />
                  </p>
                  <h3>script src="path-to-script.js" /script</h3>
                  <br />
                  <p>
                    Коли аналізатор зустрічає такий тег, обробка HTML-документа
                    припиняється і починається завантаження файлу скрипта,
                    зазначеного в атрибуті src. Після завантаження скрипт
                    виконується, і тільки потім відновлюється обробка HTML. Це
                    називається «блокуючий» скрипт. <br />
                    <br />
                    Атрибути defer та async були введені, щоб дати розробникам
                    можливість краще контролювати спосіб завантаження скриптів,
                    і коли саме їх виконувати. <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                  <h5 class="section-title__value">Атрибут defer</h5>
                  <h3>script defer src="path-to-script.js /script</h3>
                  <p>
                    Атрибут defer вказує браузеру завантажувати файл скрипта у
                    фоновому режимі, паралельно обробці HTML-документа і
                    побудові DOM. Скрипт буде виконаний тільки після того, як
                    HTML-документ був оброблений, а DOM побудований. Такі
                    скрипти не блокують побудову DOM-дерева і гарантовано
                    виконуються у тому порядку, в якому вказані в
                    HTML-документі.
                  </p>
                  <div class="section-box">
                    <img src="./img/js/js-defer.jpg" width="400" alt="" />
                  </div>
                  <h5 class="section-title__value">Атрибут async</h5>
                  <h3>script async src="path-to-script.js" /script</h3>
                  <p>
                    Завантаження скрипта з атрибутом async не блокує побудову
                    DOM, але він виконується відразу після завантаження. Це
                    означає, що такі скрипти можуть заблокувати побудову DOM, і
                    виконуються у довільному порядку.
                  </p>
                  <div class="section-box">
                    <img src="./img/js/js-async.jpg" width="400" alt="" />
                  </div>
                  <h5 class="section-title__value">type="module"</h5>
                  <h3>script type="module" src="path-to-script.js" /script</h3>
                  <p>
                    Додається щоб можна було експортувати/імпортувати з файлів
                    js
                  </p>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Різні Методи -->
      <section class="section">
        <div class="container">
          <h3 class="section-title">Різні Методи</h3>
          <ul>
            <!-- Методи часто використовувані -->
            <li>
              <h4 class="section-title__name">Знайти кіл-ть символів рядка</h4>
              <h5 class="section-title__value">.length</h5>
              <p>"JavaScript is awesome".length;</p>
            </li>

            <!-- Зробить усі літери великими -->
            <li>
              <h4 class="section-title__name">Зробить усі літери великими</h4>
              <h5 class="section-title__value">.toUpperCase()</h5>
              <p>"JavaScript is awesome".toUpperCase();</p>
            </li>

            <!-- Зробить усі літери малими -->
            <li>
              <h4 class="section-title__name">Зробить усі літери малими</h4>
              <h5 class="section-title__value">.toLowerCase()</h5>
              <p>"JavaScript is awesome".toLowerCase();</p>
            </li>

            <!-- Отримання даних -->
            <li>
              <h4 class="section-title__name">Отримання даних</h4>
              <h5 class="section-title__value">confirm()</h5>
              <p>
                виводить модальне вікно з повідомленням, і дві кнопки, Ok і
                Cancel. Натискаючи на Ok, результатом будет true, натискаючи на
                Cancel - повертається false.
              </p>
              <p>
                const isComing = confirm("Please confirm hotel reservation");
                <br />
                console.log(isComing);
              </p>
              <h5 class="section-title__value">prompt()</h5>
              <p>
                виводить модальне вікно з полем введення і кнопками Ok і Cancel.
                Натискаючи на Ok, результатом буде те, що ввів користувач, у
                випадку Cancel - повертається null. <br />
                Важлива особливість prompt полягає в тому, що незалежно від
                того, що ввів користувач, завжди повернеться рядок. Тобто, якщо
                користувач ввів 5, то повернеться не число 5, а рядок "5".
              </p>
              <p>
                const hotelName = prompt("Please enter desired hotel name");
                <br />
                console.log(hotelName);
              </p>
            </li>

            <!-- Отримання типу значення змінної -->
            <li>
              <h4 class="section-title__name">
                Отримання типу значення змінної
              </h4>
              <h5 class="section-title__value">typeof</h5>
              <p>
                const quantity = 17; <br />
                console.log(typeof quantity); // "number"
              </p>
            </li>

            <!-- Перетворити в рядок -->
            <li>
              <h4 class="section-title__name">Перетворити в рядок</h4>
              <h5 class="section-title__value">String(thing)</h5>
              <p>
                value = String(value); // тепер value - це рядок "true" <br />
                alert(typeof value); // string
              </p>
            </li>

            <!-- Перетворити в число -->
            <li>
              <h4 class="section-title__name">Перетворити в число</h4>
              <h5 class="section-title__value">Number('123')</h5>
              <p>
                let str = "123"; <br />
                alert(typeof str); // string <br />
                <br />
                let num = Number(str); // становится числом 123 <br />
                <br />
                alert(typeof num); // number <br />
              </p>
            </li>

            <!-- Перетворити в булеан -->
            <li>
              <h4 class="section-title__name">Перетворити в булеан</h4>
              <h5 class="section-title__value">Boolean("Привет!")</h5>
              <p>
                alert( Boolean(1) ); // true <br />
                alert( Boolean(0) ); // false <br />
                <br />
                alert( Boolean("Привет!") ); // true <br />
                alert( Boolean("") ); // false <br />
              </p>
            </li>
          </ul>

          <h3 class="section-title">Числа</h3>
          <ul>
            <li>
              <a href="https://youtu.be/tiHvPGOX5yc" target="_blank"
                >Числа Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Приведення до числа</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Number(val)</h5>
                  <p>
                    Більшість арифметичних операцій і математичних функцій
                    перетворюють значення у число автоматично. Для того, щоб
                    зробити це явно, використовуйте функцію Number(val),
                    передаючи їй у val те, що потрібно привести до числа. <br />
                    Якщо значення привести до числа неможливо, результатом буде
                    спеціальне числове значення NaN (Not a Number). Аналогічним
                    чином відбувається перетворення і в інших математичних
                    операторах і функціях.
                  </p>
                  <p>
                    const valueA = "5"; <br />
                    console.log(Number(valueA)); // 5 <br />
                    console.log(typeof Number(valueA)); // "number" <br />
                    <br />
                    const valueB = "random string"; <br />
                    console.log(Number(valueB)); // NaN <br />
                    console.log(typeof Number(valueB)); // "number" <br />
                  </p>
                  <!-- <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div> -->
                </div>
                <!-- <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div> -->
              </div>
            </li>
            <li>
              <h4 class="section-title__name">парсить з рядка ціле число</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Number.parseInt()</h5>
                  <p>
                    console.log(Number.parseInt("5px")); // 5 <br />
                    console.log(Number.parseInt("12qwe74")); // 12 <br />
                    console.log(Number.parseInt("12.46qwe79")); // 12 <br />
                    console.log(Number.parseInt("qweqwe")); // NaN <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">парсить з рядка дробове число</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Number.parseFloat()</h5>
                  <p>
                    console.log(Number.parseFloat("5px")); // 5 <br />
                    console.log(Number.parseFloat("12qwe74")); // 12 <br />
                    console.log(Number.parseFloat("12.46qwe79")); // 12.46
                    <br />
                    console.log(Number.parseFloat("qweqwe")); // NaN <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Перевірка на число</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Number.isNaN(val)</h5>
                  <p>
                    Він перевіряє, чи вказане значення є NaN. Метод відповідає
                    на запитання "Це Not A Number?" і повертає:
                  </p>
                  <p>
                    true - якщо значення val - NaN <br />
                    false - якщо значення val - не NaN
                  </p>
                  <p>
                    <br />
                    const validNumber = Number("51"); // 51 <br />
                    console.log(Number.isNaN(validNumber)); // false <br />
                    <br />
                    const invalidNumber = Number("qweqwe"); // NaN <br />
                    console.log(Number.isNaN(invalidNumber)); // true <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">
                Додавання чисел з рухомою крапкою (комою)
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">toFixed()</h5>
                  <p>
                    При додаванні 0.1 і 0.2, додаються дві неточності, виходить
                    незначна, але все-таки помилка в обчисленнях.
                  </p>
                  <p>
                    console.log(0.1 + 0.2 === 0.3); // false <br />
                    console.log(0.1 + 0.2); // 0.30000000000000004
                  </p>
                  <p>
                    Можна зробити їх цілими, помноживши на N, додати, а потім
                    результат поділити також на N.
                    <br />
                    console.log(0.17 + 0.24); // 0.41000000000000003 <br />
                    console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41
                  </p>
                  <p>
                    Ще один спосіб - додати, а результат скоротити до певного
                    знаку після коми за допомогою методу toFixed().
                    <br />
                    console.log(0.17 + 0.24); // 0.41000000000000003 <br />
                    console.log((0.17 + 0.24).toFixed(2)); // 0.41
                  </p>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Клас Math</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    // Math.floor(num) - повертає найменше ціле число, <br />
                    // менше, або яке дорівнює зазначеному числу <br />
                    console.log(Math.floor(1.7)); // 1 <br />
                    <br />
                    // Math.ceil(num) - повертає найбільше ціле число, <br />
                    // більше, або яке дорівнює зазначеному числу. <br />
                    console.log(Math.ceil(1.2)); // 2 <br />
                    <br />
                    // Math.round(num) - повертає значення числа, <br />
                    // округленого до найближчого цілого <br />
                    console.log(Math.round(1.2)); // 1 <br />
                    console.log(Math.round(1.5)); // 2 <br />
                    <br />
                    // Math.max(num1, num2, ...) - повертає найбільше ціле число
                    з набору <br />
                    console.log(Math.max(20, 10, 50, 40)); // 50 <br />
                    <br />
                    // Math.min(num1, num2, ...) - повертає найменше ціле число
                    з набору <br />
                    console.log(Math.min(20, 10, 50, 40)); // 10 <br />
                    <br />
                    // Math.pow(base, exponent) - піднесення до степеня <br />
                    console.log(Math.pow(2, 4)); // 16 <br />
                    <br />
                    // Math.random() - повертає псевдовипадкове число в
                    діапазоні [0, 1) <br />
                    console.log(Math.random()); // випадкове число між 0 і 1
                    <br />
                    console.log(Math.random() * (10 - 1) + 1); //
                    псевдовипадкове число від 1 до 10 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </section>

      <!-- Цікаві фішки -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Цікаві фішки</h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">
                Показує ім'я елемента (в фуц. які ставляться при слухачах на
                кнопки або ...)
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">event.target.nodeName</h5>
                  <p>
                    function onClick(event){ console.log(event.target.nodeName)
                    }
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Показує значення дата-атрибута в тегу
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    event.target.dataset.value
                  </h5>
                  <p>
                    < button type="button" data-action="open">< /button> <br />
                    <br />
                    console.log(event.target.dataset.value) покаже -> open
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Провірити чи клікнули по елементу в якому є вказаний клас
                class="tree"
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    event.target.classList.contains('tree')
                  </h5>
                  <p>console.log(event.target.classList.contains('tree)</p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Викликає функцію кожні ... (скільки покажемо) мілісекунд
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    _.throttle(func, [wait=0], [options={}])
                  </h5>
                  <h3>
                    window.addEventListener("mousemove", _.throttle(onMouseMove,
                    250));
                  </h3>
                  <p></p>
                  <a
                    href="https://www.npmjs.com/package/lodash.throttle"
                    target="_blank"
                    >Пакет lodash.throttle (не ціла бібліотека)</a
                  >
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Викликає функцію при зупиненні введення інформації з інтервалом
                (показуємо в секундах яка пауза має бути після зупинки)
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    _.debounce(func, [wait=0], [options={}])
                  </h5>
                  <h3>
                    inputValue.addEventListener('input',
                    _.debounce(onInputChange, 2000))
                  </h3>
                  <p>
                    Використовується часто в інпутах при введенні данних для
                    пошуку, коли не потрібно шукати по кожному введеному
                    синволі. Запускає функцію після припинення введення з
                    інтервалом в 2сек (2000), час паузи встановлюємо будь-який
                  </p>
                  <a
                    href="https://www.npmjs.com/package/lodash.debounce"
                    target="_blank"
                    >Пакет lodash.debounce (не ціла бібліотека)</a
                  >
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Слухач спряцьовує один рас і самовидалиться
              </h4>
              <h3>
                Коли нам потрі,но повісити слухача і щоб він спрацював тільки
                один рас а потім самовидалився без remove то додаємо опції
              </h3>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">{once: true}</h5>
                  <p class="exemplar">
                    image.addEventListener("load", onImageLoaded, {once: true});
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Очищає всі поля форми</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    evt.currentTarget.reset()
                  </h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Забороняє в форми заповняти автоматично поля</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    autoComplete="off"
                  </h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                При валідації щоб можна вводити тільки числа і букви
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">.alphanum</h5>
                  <p>
                    const passwordShema = Joi.string().min(3).max(10).alphanum()
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Зберегти з форми в об'єкт кожене значення введене в інпуті
                окремо
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    formData[e.target.name] = e.target.value
                  </h5>
                  <p>
                    let form = document.querySelector('.form'); <br />
                    <br />
                    const formData = {}; <br />
                    <br />
                    form.addEventListener('input', e =>
                    {formData[e.target.value] = e.target.value})
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Рандомно викидує true або false</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">let random = Math.random() > 0.5</h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Отримати ссилку на елемент в формі з атрибутом name=""</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    const form = e.currentTarget <br>
                    const searchQuery = form.elements.query.value <br>
                    (query це імя записане в атрибуті name="query" в інпуті)
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Очищати пробіли в інпуті по краям</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">.trim()</h5>
                  <p>
                    const str = "   foo  "; <br>
                    console.log(str.trim()); // 'foo'
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Надпис в інпуті до введення тексту</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">placeholder=""</h5>
                  <p>
                    < input type="tel" id="phone" name="phone" placeholder="123-45-678" >
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Інструменти розробника -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Інструменти розробника</h3>
          <ul>
            <li>
              <a
                href="https://developer.chrome.com/docs/devtools/console/log/"
                target="_blank"
                >Виведення повідомлень в консоль</a
              >
            </li>
            <li>
              <a
                href="https://developer.chrome.com/docs/devtools/console/api/"
                target="_blank"
                >Довідник з API консолі</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">
                Наступні комбінації клавіш відкривають інструменти розробника на
                вкладці Console:
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    Windows і Linux - Ctrl + Shift + J або F12 <br />
                    MacOS - Command + Option + J
                  </h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Основи синтаксису -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Основи синтаксису</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/uOeFpp872MY?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Типи данных -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Типи данних</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/g7jDucodUzQ?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Типы данных JAVASCRIPT. Null String Undefined Boolean Number та
                інші. Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <!-- Отримання типу значення змінної -->
              <h4 class="section-title__name">
                Отримання типу значення змінної
              </h4>
              <h5 class="section-title__value">typeof</h5>
              <p>
                const quantity = 17; <br />
                console.log(typeof quantity); // "number"
              </p>
            </li>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Імена змінних -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Імена змінних</h3>
          <ul>
            <li>
              <a
                href="https://bookflow.ru/kak-nazyvat-peremennye/"
                target="_blank"
                >Як називати змінні</a
              >
            </li>

            <li>
              <a
                href="https://www.freecodecamp.org/news/javascript-naming-conventions-dos-and-don-ts-99c0e2fdd78a"
                target="_blank"
                >Домовленість про імена змінних</a
              >
            </li>
            <li>
              <a
                href="https://youtu.be/5V8IeATHr4w?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Перемінні в JAVASCRIPT. Константи. Ключові слова LET CONST VAR.
                Frilancer</a
              >
            </li>
          </ul>

          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Ідентифікатор - це ім'я змінної, функції або класу.
                    Складається з одного або декількох символів у наступному
                    форматі. <br />
                    Першим символом повинна бути літера a-z або A-Z, символ
                    підкреслення _ або знак долара $. <br />
                    Інші символи можуть бути літерами a-z, A-Z, цифрами 0-9,
                    підкресленнями _ і знаками долара $. <br />
                    Ідентифікатори чуттєві до регістру. Це означає, що змінні
                    user, usEr і User - різні. <br />
                  </p>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>

          <h3 class="section-title">Оголошення змінних</h3>
          <!-- <ul>
            <li><a href="" target="_blank"></a></li>
          </ul> -->
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    Оголошення змінної починається з ключового слова const. Така
                    змінна повинна бути одразу ініціалізована значенням, після
                    чого її не можна перевизначити.
                  </h5>
                  <p>
                    const yearOfBirth = 2006; <br />
                    console.log(yearOfBirth); // 2006
                  </p>
                  <h5 class="section-title__value">
                    Для того, щоб оголосити змінну, якій у подальшому можна буде
                    присвоїти нове значення, використовується ключове слово let.
                  </h5>
                  <p>
                    let age; <br />
                    console.log(age); // undefined <br />
                    age = 14; <br />
                    console.log(age); // 14
                  </p>
                  <p>
                    <br />
                    Єдина відмінність const і let полягає у тому, що const
                    забороняє повторно присвоювати змінній будь-яке значення.
                    Оголошення const робить код читабельнішим, тому що змінна
                    завжди посилається на одне і те саме зачення. У випадку з
                    let такої впевненості немає. <br />
                    <br />
                    Буде розумно використовувати let і const наступним чином:
                    <br />
                    <br />
                    Використовуйте const за замовчуванням, більшість змінних
                    будуть оголошені саме таким чином. <br />
                    Використовуйте let, якщо необхідно присвоїти змінній інше
                    значення під час виконання скрипту. <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Основні оператори -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Основні оператори</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/oSO_StIWaXM?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Операторы JAVASCRIPT Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Математичні оператори</h4>
              <p>
                Призначення, функціонал і пріоритет (порядок) операцій нічим не
                відрізняються від шкільного курсу алгебри. Оператори повертають
                значення у вигляді результату виразу.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    const x = 10; <br />
                    const y = 5; <br />
                    <br />
                    // Додавання <br />
                    console.log(x + y); // 15 <br />
                    // Віднімання <br />
                    console.log(x - y); // 5 <br />
                    // Множення <br />
                    console.log(x * y); // 50 <br />
                    // Ділення <br />
                    console.log(x / y); // 2 <br />
                    // Остача від ділення <br />
                    console.log(x % y); // 0 <br />
                    <br />
                    // Додавання із заміною (також є для всіх інших операторів)
                    <br />
                    let value = 5; <br />
                    <br />
                    // Аналогічно запису value = value + 10; <br />
                    value += 10; <br />
                    console.log(value); // 15 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
              <h4 class="section-title__name">Оператори порівняння</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    a > b і a < b - більше/менше <br />
                    a >= b і a <= b - більше/менше або дорівнює <br />
                    a == b - рівність <br />
                    a != b - нерівність <br />
                    a === b - строга рівність <br />
                    a !== b - строга нерівність <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
              <h4 class="section-title__name">Оператори рівності</h4>
              <p>
                «Нестрогі» оператори рівності == і != виконують перетворення
                типів порівнюваних значень у число, що може призвести до
                помилок, особливо у початківців.
              </p>
              <p>
                Тому для перевірки рівності або нерівності двох значень,
                використовуються тільки оператори === (строга рівність) і !==
                (строга нерівність), які не виконують приведення типів
                операндів.
              </p>
              <p></p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    // ❌ Погано, виконується приведення типів <br />
                    console.log(5 == "5"); // true <br />
                    console.log(5 != "5"); // false <br />
                    console.log(1 == true); // true <br />
                    console.log(1 != true); // false <br />
                    // ✅ Добре, приведення типів не виконується <br />
                    console.log(5 === "5"); // false <br />
                    console.log(5 === 5); // true <br />
                    console.log(5 !== "5"); // true <br />
                    console.log(5 !== 5); // false <br />
                    console.log(1 === true); // false <br />
                    console.log(1 !== true); // true <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
              <h4 class="section-title__name">Логічні оператори</h4>
              <div>
                <div>
                  <h5 class="section-title__value">?? повертає всі значення крім null, undefaind</h5>
                  <p>
                    - використовуэться з null. Наприклад (null??5) то якщо
                    прилетить null то цей вираз буде дорівнювати 5 <br />
                    name ?? "text" якщо не прилетить null або undefaind то
                    поверне name, якщо так то "text" <br />
                  </p>
                  <h5 class="section-title__value">? - (якщо є)</h5>
                  <p>
                    - наприклад (number?.lenght) тут написано якщо
                    number (є взагалі) true то далі провірить його довжину
                    (кількість синволів)
                  </p>
                </div>
                <div>
                  <h5 class="section-title__value">
                    Логічне «І» && - шукає до першого false
                  </h5>
                  <h3>
                    Тобто, логічне «І» зупиняється на хибному і повертає те, на
                    чому зупинилось, або останній операнд.
                  </h3>
                  <p>
                    const age = 20; <br />
                    console.log(age > 10 && age < 30); // true && true -> true
                    <br />
                    const age = 50; <br />
                    console.log(age > 10 && age < 30); // true && false -> false
                    <br />
                    console.log(age > 80 && age < 120); // false && true ->
                    false <br />
                    console.log(1 && 5); // true && true -> 5 <br />
                    console.log(5 && 1); // true && true -> 1 <br />
                    console.log(0 && 2); // false && true -> 0 <br />
                    console.log(2 && 0); // true && false -> 0 <br />
                    console.log("" && "Mango"); // false && true -> "" <br />
                    console.log("Mango" && ""); // true && false -> "" <br />
                    console.log("Mango" && "Poly"); // true && true -> "Poly"
                    <br />
                    console.log("Poly" && "Mango"); // true && true -> "Mango"
                    <br />
                  </p>
                </div>
                <div>
                  <h5 class="section-title__value">
                    Логічне «АБО» || - шукаэ до першого true
                  </h5>
                  <h3>
                    Тобто, логічне «АБО» зупиняється на правді і повертає те, на
                    чому зупинилося або останній операнд.
                  </h3>
                  <p>
                    const age = 5; <br />
                    console.log(age < p 10 || age>30); // true || false -> true
                    <br />
                    const age = 40; <br />
                    console.log(age < 10 || age > 30); // false || true -> true
                    <br />
                    const age = 20; <br />
                    console.log(age < 10 || age > 30); // false || false ->
                    false <br />
                    console.log(true || false); // true <br />
                    console.log(false || true); // true <br />
                    console.log(true || true); // true <br />
                    <br />
                    console.log(3 || false); // 3 <br />
                    console.log(false || 3); // 3 <br />
                    console.log(3 || true); // 3 <br />
                    console.log(true || 3); // true <br />
                  </p>
                </div>
                <div>
                  <h5 class="section-title__value">
                    Логічне «НЕ» ! - змінює false на true і навпаки
                  </h5>
                  <h3>
                    Оператор ! приводить операнд до буля, якщо необхідно, а
                    потім робить інверсію - змінює його на протилежний true ->
                    false або false -> true.
                  </h3>
                  <p>
                    console.log(!true); // false <br />
                    console.log(!false); // true <br />
                    console.log(!3); // !3 -> !true -> false <br />
                    console.log(!"Mango"); // !"Mango" -> !true -> false <br />
                    console.log(!0); // !0 -> !false -> true <br />
                    console.log(!""); // !"" -> !false -> true <br />
                    <br />
                    const isOnline = true; <br />
                    const isNotOnline = !isOnline; // !isOnline -> !true ->
                    false <br />
                  </p>
                </div>
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                </div>
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Рядки -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Рядки</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/jc5Upe8xIN0?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Frilancer</a
              >
            </li>
          </ul>
          <div>
            <p>
              Рядок - це індексований набір з нуля або більше символів, взятих в
              одинарні або подвійні лапки. <br />
              Вміст рядка не можна змінити, лише прочитати, як тільки рядок
              створений - він такий назавжди.
            </p>
            <p>const username = "Mango";</p>
          </div>
          <!-- <ul>
            <li><a href="" target="_blank"></a></li>
          </ul> -->
          <img src="./img/js/string.jpg" width="400" alt="" />
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Конкатенація рядків</h5>
                  <p>
                    const message = "Mango " + "is" + " happy"; <br />
                    console.log(message); // Mango is happy <br />
                    <br />
                    console.log(1 + "2"); // "12" <br />
                    console.log(1 + "2" + 4); // "124" <br />
                    console.log(1 + 2 + "4"); // "34" <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Шаблонні рядки</h5>
                  <p>
                    Шаблонні рядки - це альтернатива конкатенації зі зручнішим
                    синтаксисом. Шаблонний рядок береться у зворотні (косі)
                    лапки, замість подвійних або одинарних, і може містити
                    заповнювачі місця, які позначаються знаком долара і
                    фігурними дужками - ${вираз}. <br />
                    <br />
                    // Використовуючи змінні, необхідно скласти рядок з
                    підставленими значеннями <br />
                    const guestName = "Манго"; <br />
                    const roomNumber = 207; <br />
                    const greeting = <br />
                    "Welcome " + guestName + ", your room number is " +
                    roomNumber + "!"; <br />
                    console.log(greeting); // "Welcome Mango, your room number
                    is 207!" <br />
                    <br />
                    Складати рядки з підставленими значеннями, використовуючи
                    конкатенацію, - дуже незручно. На допомогу приходять
                    шаблонні рядки та інтерполяція. <br />
                    <br />
                    const guestName = "Манго"; <br />
                    const roomNumber = 207; <br />
                    const greeting = `Welcome ${guestName}, your room number is
                    ${roomNumber}!`; <br />
                    console.log(greeting); // "Welcome Mango, your room number
                    is 207!" <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Властивості і методи рядків</h4>
              <div>
                <div>
                  <h5 class="section-title__value">Властивість length</h5>
                  <h3>
                    Для того, щоб дізнатися довжину рядка, тобто кількість його
                    символів
                  </h3>
                  <p>
                    const message = "Welcome to Bahamas!"; <br />
                    console.log(message.length); // 19 <br />
                    console.log("There is nothing impossible to him who will
                    try".length); // 47 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">
                    Методи toLowerCase() і toUpperCase()
                  </h5>
                  <h3>
                    Повертають новий рядок у відповідному регістрі, не змінюючи
                    оригінальний рядок.
                  </h3>
                  <p>
                    const message = "Welcome to Bahamas!"; <br />
                    console.log(message.toLowerCase()); // "welcome to bahamas!"
                    <br />
                    console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
                    <br />
                    console.log(message); // "Welcome to Bahamas!" <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">Метод indexOf()</h5>
                  <h3>
                    Повертає позицію (індекс), на якій знаходиться перший збіг
                    підрядка або -1, якщо нічого не знайдено.
                  </h3>
                  <p>
                    const message = "Welcome to Bahamas!"; <br />
                    console.log(message.indexOf("to")); // 8 <br />
                    console.log(message.indexOf("hello")); // -1 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">Метод includes()</h5>
                  <h3>
                    Перевіряє, чи міститься підрядок в рядку, повертає буль -
                    true, якщо міститься, і false - в іншому випадку. Регістр
                    символів в рядку і підрядку має значення, оскільки,
                    наприклад, літера "a" не дорівнює літері "А".
                  </h3>
                  <p>
                    const productName = "Ремонтний дроїд"; <br />
                    <br />
                    console.log(productName.includes("н")); // true <br />
                    console.log(productName.includes("Н")); // false <br />
                    console.log(productName.includes("дроїд")); // true <br />
                    console.log(productName.includes("Дроїд")); // false <br />
                    console.log(productName.includes("Ремонтний")); // true
                    <br />
                    console.log(productName.includes("ремонтний")); // false
                    <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">Метод endsWith()</h5>
                  <h3>
                    Дозволяє визначити, чи завершується рядок символами
                    (підрядком), зазначеними в дужках, повертаючи true або
                    false.
                  </h3>
                  <p>
                    const jsFileName = "script.js"; <br />
                    console.log(jsFileName.endsWith(".js")); // true <br />
                    <br />
                    const cssFileName = "styles.css"; <br />
                    console.log(cssFileName.endsWith(".js")); // false
                  </p>
                  <br />
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">
                    Методи replace() і replaceAll()
                  </h5>
                  <h3>
                    Повертає новий рядок, в якому перше (replace) або усі збіги
                    (replaceAll) підрядка замінені на вказане значення.
                  </h3>
                  <p>
                    const jsFileName = "script.js"; <br />
                    const minifiedJsFileName = jsFileName.replace(".js",
                    ".min.js"); <br />
                    console.log(minifiedJsFileName); // "script.min.js" <br />
                    <br />
                    const cssFileNames = "styles.css, about.css, portfolio.css";
                    <br />
                    const minifiedCssFileNames = cssFileNames.replaceAll(".css",
                    ".min.css"); <br />
                    console.log(minifiedCssFileNames); // "styles.min.css,
                    about.min.css, portfolio.min.css" <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">Метод slice()</h5>
                  <h3>
                    Метод рядків slice (startIndex, endIndex) використовується
                    для створення копії частини або всього рядка. Він робить
                    копію елементів рядка від startIndex і до, але не включно
                    endIndex і повертає новий рядок, не змінюючи оригінал.
                  </h3>
                  <p>
                    const productName = "Repair droid"; <br />
                    console.log(productName.slice(0, 4)); // "Repa" <br />
                    console.log(productName.slice(3, 9)); // "air dr" <br />
                    console.log(productName.slice(0, productName.length)); //
                    "Repair droid" <br />
                    console.log(productName.slice(7, productName.length)); //
                    "droid"
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>

                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Розгалуження -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Розгалуження</h3>
          <p>
            Принцип роботи простий - результат умови приводиться до буля true
            або false, після чого потік програми спрямовується в ту або іншу
            гілку.
          </p>
          <ul>
            <li>
              <a
                href="https://youtu.be/tFyRhDZgHaU?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >if..else, тернарник Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Інструкція if</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">if</h5>
                  <p>
                    let cost = 0; <br />
                    const subscription = "pro"; <br />
                    <br />
                    if (subscription === "pro") { <br />
                    cost = 100; <br />
                    } <br />
                    <br />
                    console.log(cost); // 100 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">if...else</h5>
                  <p>
                    let cost; <br />
                    const subscription = "free"; <br />
                    <br />
                    if (subscription === "pro") { <br />
                    cost = 100; <br />
                    } else { <br />
                    cost = 0; <br />
                    } <br />
                    <br />
                    console.log(cost); // 0 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">else...if</h5>
                  <p>
                    let cost; <br />
                    const subscription = "premium"; <br />
                    <br />
                    if (subscription === "free") { <br />
                    cost = 0; <br />
                    } else if (subscription === "pro") { <br />
                    cost = 100; <br />
                    } else if (subscription === "premium") { <br />
                    cost = 500; <br />
                    } else { <br />
                    console.log("Invalid subscription type"); <br />
                    } <br />
                    <br />
                    console.log(cost); // 500 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Тернарний оператор</h4>
              <p>
                Тернарний оператор використовується у якості синтаксично
                коротшої заміни інструкції if...else, коли одній і тій самій
                змінній необхідно присвоїти різні значення за умовою. <br />
                < умова> ? < вираз_якщо_умова_правдива> : <
                вираз_якщо_умова_хибна>
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    const age = 20; <br />
                    const type = age >= 18 ? "adult" : "child"; <br />
                    console.log(type); // "adult" <br />
                    <br />
                    const num1 = 5; <br />
                    const num2 = 10; <br />
                    const biggerNumber = num1 > num2 ? num1 : num2; <br />
                    <br />
                    console.log(biggerNumber); // 10 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Інструкція switch</h4>
              <p>
                Його синтаксис складається із блоку switch(значення) - що
                потрібно порівняти і набору окремих випадків case значення - з
                чим потрібно порівняти. Для порівняння використовується оператор
                строгої рівності ===. Тобто, не можна порівняти більше або
                менше, лише рівність.
              </p>
              <p></p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    switch (значення) { <br />
                    case значення: <br />
                    інструкції; <br />
                    break; <br />
                    <br />
                    case значення: <br />
                    інструкції; <br />
                    break; <br />
                    <br />
                    default: <br />
                    інструкції; <br />
                    } <br />
                  </p>
                  <p>
                    let cost; <br />
                    const subscription = "premium"; <br />
                    <br />
                    switch (subscription) { <br />
                    case "free": <br />
                    cost = 0; <br />
                    break; <br />
                    <br />
                    case "pro": <br />
                    cost = 100; <br />
                    break; <br />
                    <br />
                    case "premium": <br />
                    cost = 500; <br />
                    break; <br />
                    <br />
                    default: <br />
                    console.log("Invalid subscription type"); <br />
                    } <br />
                    <br />
                    console.log(cost); // 500 <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Область видимості -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Область видимості</h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    Область видимості змінних (variable scope) - доступність
                    змінних в певному місці коду.
                  </h5>
                  <p>
                    Область видимості змінних (variable scope) - доступність
                    змінних в певному місці коду. <br />
                    Глибина вкладеності областей видимості - необмежена, і всі
                    вони будуть працювати за одним принципом - область видимості
                    має доступ до всіх змінних, оголошених вище по ієрархії
                    вкладеності, але не може отримати доступ до змінних,
                    оголошених у вкладених областях видимості.
                  </p>
                  <p>
                    const global = "global"; <br />
                    <br />
                    if (true) { <br />
                    const blockA = "block A"; <br />
                    <br />
                    // Бачимо глобальну + локальну A <br />
                    console.log(global); // 'global' <br />
                    console.log(blockA); // block A <br />
                    <br />
                    // Змінні blockB і blockC не знайдені в доступних областях
                    видимості. <br />
                    // Буде помилка звернення до змінної. <br />
                    console.log(blockB); // ReferenceError: blockB is not
                    defined <br />
                    console.log(blockC); // ReferenceError: blockC is not
                    defined <br />
                    <br />
                    if (true) { <br />
                    const blockB = "block B"; <br />
                    <br />
                    // Бачимо глобальну + зовнішню A + локальну B <br />
                    console.log(global); // global <br />
                    console.log(blockA); // block A <br />
                    console.log(blockB); // block B <br />
                    <br />
                    // Змінна blockC не знайдена в доступних областях видимості.
                    <br />
                    // Буде помилка звернення до змінної. <br />
                    console.log(blockC); // ReferenceError: blockC is not
                    defined <br />
                    } <br />
                    } <br />
                    <br />
                    if (true) { <br />
                    const blockC = "block C"; <br />
                    <br />
                    // Бачимо глобальну + локальну C <br />
                    console.log(global); // global <br />
                    console.log(blockC); // block C <br />
                    <br />
                    // Змінні blockA і blockB не знайдені в доступних областях
                    видимості. <br />
                    // Буде помилка звернення до змінної. <br />
                    console.log(blockA); // ReferenceError: blockA is not
                    defined <br />
                    console.log(blockB); // ReferenceError: blockB is not
                    defined <br />
                    } <br />
                    <br />
                    // Бачимо лише глобальну <br />
                    console.log(global); // global <br />
                    <br />
                    // Змінні blockA, blockB і blockC не знайдені в доступних
                    областях видимості. <br />
                    // Буде помилка звернення до змінної. <br />
                    console.log(blockA); // ReferenceError: blockA is not
                    defined <br />
                    console.log(blockB); // ReferenceError: blockB is not
                    defined <br />
                    console.log(blockC); // ReferenceError: blockC is not
                    defined <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Цикли -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Цикли</h3>
          <ul>
            <!-- for -->
            <li>
              <a
                href="https://youtu.be/QjDzp-yM_To?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >for, while Frilancer</a
              >
            </li>
          </ul>
          <p>
            Часте завдання програмування - багаторазове виконання однотипної
            дії. Наприклад, вивести клієнтів зі списку один за одним, або
            перебрати суми зарплат, і для кожної виконати однаковий код. Саме
            для таких цілей - багаторазового повторення однієї частини коду,
            використовуються цикли.
          </p>
          <ul>
            <h3>Цикл</h3>
            - керуюча конструкція у високорівневих мовах програмування,
            призначена для організації багаторазового виконання набору
            інструкцій.
            <br />
            <h3>Тіло циклу</h3>
            - послідовність інструкцій, призначена для багаторазового виконання.
            <br />
            <h3>Ітерація</h3>
            - одноразове виконання тіла циклу.
            <br />
            <h3>Умова виходу</h3>
            - вираз, що визначає, чи буде в черговий раз виконуватися ітерація,
            або цикл завершиться.
            <br />
            <h3>Лічильник</h3>
            - змінна, що зберігає поточний номер ітерації. Цикл не обов'язково
            містить лічильник, і він не повинен бути один, умова виходу з циклу
            може залежати від декількох змінних, що змінюються в циклі.
            <br />
          </ul>
          <ul>
            <!-- Цикл while -->
            <li>
              <h4 class="section-title__name">Цикл while</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Цикл з передумовою</h5>
                  <p>
                    Цикл з передумовою — цикл, який виконується, доки правдива
                    якась умова, зазначена до його початку. Ця умова
                    перевіряється до виконання тіла циклу, тому тіло може не
                    виконатися жодного разу, якщо умова від самого початку -
                    хибна.
                  </p>
                  <p>
                    Конструкція while створює цикл, який виконує блок коду, доки
                    умова перевірки оцінюється як true. <br />
                    <br />
                    condition, тобто умова, оцінюється перед кожною ітерацією
                    циклу. <br />
                    Якщо condition оцінюється як true, оператор while виконує
                    statement. <br />
                    Якщо condition оцінюється як false, виконання циклу
                    переривається і скрипт продовжує виконувати інструкції після
                    циклу while. <br />
                  </p>
                  <p>
                    Створимо лічильник. <br />
                    <br />
                    let counter = 0; <br />
                    <br />
                    while (counter < 10) { <br />
                    console.log("counter: ", counter); <br />
                    counter += 1; <br />
                    } <br />
                    <br />
                    Будемо заповнювати місця в готелі доти, доки поточна
                    кількість клієнтів не буде дорівнювати максимально можливій.
                    <br />
                    <br />
                    let clientCounter = 18; <br />
                    const maxClients = 25; <br />
                    <br />
                    while (clientCounter < maxClients) { <br />
                    console.log(clientCounter); <br />
                    clientCounter += 1; <br />
                    } <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>

                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Цикл do...while -->
            <li>
              <h4 class="section-title__name">Цикл do...while</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Цикл з постумовою</h5>
                  <p>
                    Цикл з постумовою - цикл, в якому умова перевіряється після
                    виконання тіла циклу. З цього випливає, що тіло завжди
                    виконується хоча б один раз.
                  </p>
                  <p>
                    Конструкція do...while створює цикл, який виконує блок коду
                    доти, доки condition не поверне false. <br />
                    <br />
                    На відміну від циклу while, цикл do...while завжди виконує
                    statement мінімум один раз, перш ніж він оцінить condition.
                    <br />
                    <br />
                    Всередині циклу потрібно внести зміни в деяку змінну, щоб
                    переконатися, що вираз дорівнює false після ітерацій. Інакше
                    буде нескінченний цикл. <br />
                  </p>
                  <p>
                    let password = ""; <br />
                    <br />
                    do { <br />
                    password = prompt("Введіть пароль довший 4-х символів", "");
                    <br />
                    } while (password.length < 5); <br />
                    <br />
                    console.log("Ввели пароль: ", password); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Цикл for -->
            <li>
              <h4 class="section-title__name">Цикл for</h4>
              <p>
                Цикл з лічильником - цикл, в якому певна змінна змінює своє
                значення із заданого початкового до кінцевого значення з деяким
                кроком, і для кожного значення цієї змінної тіло циклу
                виконується один раз.
              </p>
              <div>
                <div>
                  <h5 class="section-title__value">
                    for (let i = 0; i <= 20; i += 5) { console.log(i);}
                  </h5>
                  <div>
                    Алгоритм виконання циклу for: <br />
                    <br />
                    <h3>Ініціалізація (initialization)</h3>
                    - виконується один раз до початку циклу. Використовується
                    для створення змінної-лічильника і зазначення її початкового
                    значення.
                    <br />
                    <h3>Умова (condition)</h3>
                    - вираз, що оцінюється перед кожною ітерацією (повторенням)
                    циклу. Тіло циклу виконується тільки тоді, коли вираз
                    приводиться до true. Цикл завершується, якщо значення буде
                    false. <br />
                    <h3>Тіло (statements)</h3>
                    - набір інструкцій для виконання на кожному повторенні.
                    Виконується, якщо вираз умови приводиться до true. <br />
                    <h3>Пост-вираз (post-expression)</h3>
                    - виконується в кінці кожного повторення циклу, до перевірки
                    умови. Використовується для оновлення змінної-лічильника.
                    <br />
                    Змінні-лічильники, за традицією, називаються літерами i, j і
                    k. <br />
                  </div>
                  <p>
                    Порахуємо суму чисел до певного значення. <br />
                    <br />
                    const target = 3; <br />
                    let sum = 0; <br />
                    <br />
                    for (let i = 0; i <= target; i += 1) { <br />
                    sum += i; <br />
                    } <br />
                    console.log(sum); <br />
                    <br />
                    Згадаємо про операцію a % b і виведемо остачу від ділення за
                    допомогою циклу. <br />
                    <br />
                    const max = 10; <br />
                    for (let i = 0; i < max; i += 1) { <br />
                    console.log(`${max} % ${i} = `, max % i); <br />
                    } <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">Оператор break</h5>
                  <h3>
                    Перервати виконання циклу можна в будь-який момент. Для
                    цього існує оператор break, який повністю припиняє виконання
                    циклу і передає управління на рядок після його тіла.
                  </h3>
                  <p>
                    Знайдемо число 3. Щойно виконається умова if, цикл припинить
                    своє виконання (буде перерваний). <br />
                    <br />
                    for (let i = 0; i <= 5; i += 1) { <br />
                    console.log(i); <br />
                    <br />
                    if (i === 3) { <br />
                    console.log("Знайшли число 3, перериваємо виконання циклу");
                    <br />
                    break; <br />
                    } <br />
                    } <br />
                    console.log("Лог після циклу"); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value">Оператор continue</h5>
                  <h3>
                    Перериває не увесь цикл, а тільки виконання поточної
                    ітерації.
                  </h3>
                  <p>
                    Його використовують, якщо зрозуміло, що на поточній ітерації
                    циклу більше немає що робити або взагалі не потрібно нічого
                    робити, і час переходити до наступної ітерації.
                  </p>
                  <p>
                    Використовуємо цикл для введення тільки непарних чисел. Для
                    парних i спрацьовує continue, виконання тіла припиняється і
                    управління передається до наступної ітерації. <br />
                    <br />
                    const number = 10; <br />
                    <br />
                    for (let i = 0; i < number; i += 1) { <br />
                    if (i % 2 === 0) { <br />
                    continue; <br />
                    } <br />
                    console.log("Непарне i: ", i); // 1, 3, 5, 7, 9 <br />
                    } <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Цикл for...of -->
            <li>
              <h4 class="section-title__name">Цикл for...of</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Конструкція for...of оголошує цикл, що перебирає ітерабельні
                    об'єкти, як-от масиви і рядки. Тіло циклу буде виконуватися
                    для значення кожного елемента. Це хороша заміна циклу for,
                    якщо не потрібен доступ до лічильника ітерації. <br />
                    <br />
                    for (const variable of iterable) { <br />
                    // тіло циклу <br />
                    } <br />
                    variable — змінна, яка буде зберігати значення елемента на
                    кожній ітерації. <br />
                    iterable — колекція, яка містить ітерабельні (що можна
                    порахувати) елементи, наприклад масив.
                  </p>
                  <p>
                    const clients = ["Mango", "Ajax", "Poly"]; <br />
                    <br />
                    for (const client of clients) { <br />
                    console.log(client); <br />
                    } <br />
                    <br />
                    const string = "javascript"; <br />
                    <br />
                    for (const character of string) { <br />
                    console.log(character); <br />
                    } <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

          </ul>
        </div>
      </div>

      <!-- Масиви -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Масиви</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/GULFKAX0nxY?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <!-- Створення -->
            <li>
              <h4 class="section-title__name">Створення</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Масив оголошується і береться у квадратні дужки [] -
                    літералом масиву. <br />
                    Всередині дужок кожен елемент масиву розділяється комою.
                    <br />

                    const clients = ["Mango", "Poly", "Ajax"];
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Доступ до елементів -->
            <li>
              <h4 class="section-title__name">Доступ до елементів</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Для доступу до значення елемента масиву використовується
                    синтаксис квадратних дужок масив[індекс]. Між іменем
                    змінної, що зберігає масив, і квадратними дужками не повинно
                    бути пробілу.
                  </p>
                  <p>
                    const clients = ["Mango", "Poly", "Ajax"]; <br />
                    <br />
                    // Зазначаючи в дужках індекс елемента, ми отримуємо його
                    значення <br />
                    console.log(clients[0]); // Mango <br />
                    console.log(clients[1]); // Poly <br />
                    console.log(clients[2]); // Ajax <br />
                  </p>
                  <p>Індексація елементів масиву починається з нуля.</p>
                  <div class="section-box">
                    <img src="./img/js/array-element.jpg" width="300" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Перевизначення -->
            <li>
              <h4 class="section-title__name">Перевизначення</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    На відміну від рядків, елементи масиву можна змінювати,
                    звернувшись до них за індексом і присвоївши інше значення.
                    <br />
                    <br />
                    const clients = ["Mango", "Poly", "Ajax"]; <br />
                    clients[0] = "Kiwi"; <br />
                    clients[1] = "Pango"; <br />
                    console.log(clients); // ["Kiwi", "Pango", "Ajax"] <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Довжина масиву -->
            <li>
              <h4 class="section-title__name">Довжина масиву</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    const clients = ["Mango", "Poly", "Ajax"]; <br />
                    console.log(clients.length); // 3
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Індекс останнього елемента -->
            <li>
              <h4 class="section-title__name">Індекс останнього елемента</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    const clients = ["Mango", "Poly", "Ajax"]; <br />
                    const lastElementIndex = clients.length - 1; <br />
                    console.log(lastElementIndex); // 2 <br />
                    console.log(clients[lastElementIndex]); // "Ajax" <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Ітерація по масиву -->
            <li>
              <h4 class="section-title__name">Ітерація по масиву</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Цикл for можна використовувати для ітерації по масиву, тобто
                    «перебрати» його поелементно. <br />
                    <br />
                    const clients = ["Mango", "Ajax", "Poly"]; <br />
                    <br />
                    for (let i = 0; i < clients.length; i += 1) { <br />
                    console.log(clients[i]); <br />
                    } <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Цикл for...of</h5>
                  <p>
                    Конструкція for...of оголошує цикл, що перебирає ітерабельні
                    об'єкти, як-от масиви і рядки. Тіло циклу буде виконуватися
                    для значення кожного елемента. Це хороша заміна циклу for,
                    якщо не потрібен доступ до лічильника ітерації. <br />
                    <br />
                    for (const variable of iterable) { <br />
                    // тіло циклу <br />
                    } <br />
                    variable — змінна, яка буде зберігати значення елемента на
                    кожній ітерації. <br />
                    iterable — колекція, яка містить ітерабельні (що можна
                    порахувати) елементи, наприклад масив.
                  </p>
                  <p>
                    const clients = ["Mango", "Ajax", "Poly"]; <br />
                    <br />
                    for (const client of clients) { <br />
                    console.log(client); <br />
                    } <br />
                    <br />
                    const string = "javascript"; <br />
                    <br />
                    for (const character of string) { <br />
                    console.log(character); <br />
                    } <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Оператори break і continue -->
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    Оператори break і continue
                  </h5>
                  <p>
                    Будемо шукати ім'я клієнта в масиві імен, якщо знайшли -
                    перериваємо цикл, оскільки немає сенсу шукати далі, імена у
                    нас унікальні. <br />
                    <br />
                    const clients = ["Mango", "Poly", "Ajax"]; <br />
                    const clientNameToFind = "Poly"; <br />
                    let message; <br />
                    <br />
                    for (const client of clients) { <br />
                    // На кожній ітерації будемо перевіряти чи збігається
                    елемент масиву з <br />
                    // іменем клієнта. Якщо збігається - записуємо в message
                    повідомлення <br />
                    // про успіх і робимо break, щоб далі не шукати <br />
                    if (client === clientNameToFind) { <br />
                    message = "Клієнт з таким ім'ям є в базі даних!"; <br />
                    break; <br />
                    } <br />
                    <br />
                    // Якщо вони не збігаються - записуємо в message
                    повідомлення про відсутність імені <br />
                    message = "Клієнт з таким ім'ям відсутній в базі даних!";
                    <br />
                    } <br />
                    console.log(message); // "Клієнт з таким ім'ям є в базі
                    даних!" <br />
                    <br />
                  </p>
                  <p class="exemplar">
                    Використовуємо цикл для виведення тільки чисел, більших за
                    певне значення. <br />
                    <br />
                    const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34]; <br />
                    const threshold = 15; <br />
                    <br />
                    // Для чисел, менших ніж порогове значення, спрацьовує
                    continue, виконання тіла <br />
                    // припиняється і управління передається на наступну
                    ітерацію. <br />
                    for (let i = 0; i < numbers.length; i += 1) { <br />
                    if (numbers[i] < threshold) { <br />
                    continue; <br />
                    } <br />
                    console.log(`Число більше за ${threshold}: ${numbers[i]}`);
                    // 18, 29, 34 <br />
                    } <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <!-- Методи масиву -->
            <li>
              <h4 class="section-title__name">Методи масиву</h4>
              <div class="section-box">
                <div>
                  <!-- Методи split() і join() -->
                  <h5 class="section-title__value">Методи split() і join()</h5>
                  <h3>
                    Метод split(delimiter) перетворює рядок в масив,
                    «розбиваючи» його роздільником delimiter.
                  </h3>
                  <p>
                    Якщо роздільник - це порожній рядок, то створиться масив
                    окремих символів. Роздільником може бути один або декілька
                    символів. <br />
                    <br />
                    const name = "Mango"; <br />
                    console.log(name.split("")); // ["M", "a", "n", "g", "o"]
                    <br />
                    <br />
                    const message = "JavaScript - це цікаво"; <br />
                    console.log(message.split(" ")); // ["JavaScript", "-",
                    "це", "цікаво"] <br />
                  </p>
                  <h3>
                    Метод масивів join(delimiter) об'єднує елементи масиву у
                    рядок.
                  </h3>
                  <p>
                    У рядку елементи будуть розділені символом або групою
                    символів, зазначених в delimiter. Тобто ця операція
                    протилежна методу рядків split(delimiter). <br />
                    <br />
                    const words = ["JavaScript", "це", "цікаво"]; <br />
                    console.log(words.join("")); // "JavaScriptцецікаво" <br />
                    console.log(words.join(" ")); // "JavaScript це цікаво"
                    <br />
                    console.log(words.join("-")); // "JavaScript-це-цікаво"
                    <br />
                  </p>
                  <!-- Метод indexOf() -->
                  <h5 class="section-title__value">Метод indexOf()</h5>
                  <h3>
                    indexOf(value) повертає перший індекс, в якому елемент зі
                    значенням value був знайдений в масиві, або число -1, якщо
                    такий елемент відсутній.
                  </h3>
                  <p>
                    Використовуйте indexOf тоді, коли необхідно отримати сам
                    індекс елемента. <br />
                    <br />
                    const clients = ["Mango", "Ajax", "Poly", "Kiwi"]; <br />
                    console.log(clients.indexOf("Poly")); // 2 <br />
                    console.log(clients.indexOf("Monkong")); // -1 <br />
                  </p>
                  <h5 class="section-title__value">Метод includes()</h5>
                  <h3>
                    includes(value) перевіряє, чи містить масив елемент зі
                    значенням value і повертає true або false відповідно.
                  </h3>
                  <p>
                    Застосування цього методу корисне в ситуаціях, коли
                    необхідно перевірити, чи є елемент в масиві і не важлива
                    його позиція (індекс). <br />
                    <br />
                    const clients = ["Mango", "Ajax", "Poly", "Kiwi"]; <br />
                    console.log(clients.includes("Poly")); // true <br />
                    console.log(clients.includes("Monkong")); // false <br />
                  </p>
                  <h4>Перевірка багатьох умов з includes()</h4>
                  <p class="exemplar">
                    // Виносимо варіанти в масив <br />
                    const redFruits = ["apple", "strawberry", "cherry",
                    "cranberries"]; <br />
                    const fruit = "cherry"; <br />
                    // Перевіряємо присутність елемента <br />
                    const hasFruit = redFruits.includes(fruit); <br />
                    <br />
                    if (hasFruit) { <br />
                    console.log(`${fruit} is a red fruit!`); <br />
                    } <br />
                  </p>
                  <!-- Методи push() і pop() -->
                  <h5 class="section-title__value">Методи push() і pop()</h5>
                  <h3>Додають або видаляють крайні елементи масиву.</h3>
                  <div class="section-box">
                    <img src="./img/js/push-pop.jpg" width="300" alt="" />
                  </div>
                  <h3>Метод push()</h3>
                  <p>
                    додає один або декілька елементів наприкінці масиву, без
                    необхідності зазначати індекси елементів, що додаються.
                    Повертає довжину масиву після додавання елементів.
                  </p>
                  <p class="exemplar">
                    const numbers = []; <br />
                    <br />
                    numbers.push(1); <br />
                    console.log(numbers); // [1] <br />
                    <br />
                    numbers.push(2); <br />
                    console.log(numbers); // [1, 2] <br />
                    <br />
                    numbers.push(3); <br />
                    console.log(numbers); // [1, 2, 3] <br />
                  </p>
                  <div class="section-box">
                    <img src="./img/js/array-push.jpg" width="500" alt="" />
                  </div>
                  <h3>Метод pop()</h3>
                  <p>
                    видаляє останній елемент з кінця масиву і повертає видалений
                    елемент. Якщо масив порожній, метод повертає undefined.
                  </p>
                  <p class="exemplar">
                    const numbers = [1, 2, 3, 4, 5]; <br />
                    <br />
                    console.log(numbers.pop()); // 5 <br />
                    console.log(numbers); // [1, 2, 3, 4] <br />
                    <br />
                    console.log(numbers.pop()); // 4 <br />
                    console.log(numbers); // [1, 2, 3] <br />
                    <br />
                    console.log(numbers.pop()); // 3 <br />
                    console.log(numbers); // [1, 2]
                  </p>
                  <div class="section-box">
                    <img src="./img/js/array-pop.jpg" width="500" alt="" />
                  </div>
                  <!-- Метод slice() -->
                  <h5 class="section-title__value">Метод slice()</h5>
                  <h3>
                    slice(begin, end) повертає новий масив, що містить копію
                    частини вихідного масиву, не змінюючи його. Копія
                    створюється з begin і до, але не включно, end - індекси
                    елементів вихідного масиву.
                  </h3>
                  <div class="section-box">
                    <img src="./img/js/array-slice.jpg" width="200" alt="" />
                  </div>
                  <p class="exemplar">
                    const clients = ["Mango", "Ajax", "Poly", "Kiwi"]; <br />
                    console.log(clients.slice(1, 3)); // ["Ajax", "Poly"] <br />
                    <br />
                    Якщо begin і end не зазначені, буде створена повна копія
                    вихідного масиву. <br />
                    <br />
                    const clients = ["Mango", "Ajax", "Poly", "Kiwi"]; <br />
                    console.log(clients.slice()); // ["Mango", Ajax", "Poly",
                    "Kiwi"] <br />
                    <br />
                    Якщо не зазначено end, копіювання буде зі start і до кінця
                    вихідного масиву. <br />
                    <br />
                    const clients = ["Mango", "Ajax", "Poly", "Kiwi"]; <br />
                    console.log(clients.slice(1)); // ["Ajax", "Poly", "Kiwi"]
                    <br />
                    console.log(clients.slice(2)); // ["Poly", "Kiwi"] <br />
                    <br />
                    Якщо значення start від'ємне, а end не зазначено - будуть
                    скопійовані останні start елементи <br />
                    <br />
                    const clients = ["Mango", "Ajax", "Poly", "Kiwi"]; <br />
                    console.log(clients.slice(-2)); // ["Poly", "Kiwi"] <br />
                  </p>
                  <!-- Метод splice() -->
                  <h5 class="section-title__value">Метод splice()</h5>
                  <h3>
                    Видаляє, додає і замінює елементи у довільному місці масиву.
                  </h3>
                  <h2>Видалення</h2>
                  <p>
                    Щоб видалити елементи в масиві, передаються два аргументи.
                    <br />
                    <br />
                    splice(position, num) <br />
                    <br />
                    position - вказує на позицію (індекс) першого елемента для
                    видалення <br />
                    num - визначає кількість елементів, що видаляються <br />
                    Метод splice змінює вихідний масив і повертає масив, що
                    містить видалені елементи. Наприклад, у нас є масив оцінок,
                    який містить п'ять чисел від 1 до 5. <br />
                    <br />
                    const scores = [1, 2, 3, 4, 5]; <br />
                    <br />
                    // Видаляємо три елементи масиву, починаючи з першого
                    елемента (індекс 0) <br />
                    const deletedScores = scores.splice(0, 3); <br />
                    <br />
                    // Тепер масив scores містить два елементи <br />
                    console.log(scores); // [4, 5] <br />
                    <br />
                    // А масив deletedScores містить три видалені елементи
                    <br />
                    console.log(deletedScores); // [1, 2, 3] <br />
                  </p>
                  <div class="section-box">
                    <img
                      src="./img/js/array-splice-delete.jpg"
                      width="500"
                      alt=""
                    />
                  </div>
                  <h2>Додавання</h2>
                  <p>
                    Для того, щоб додати один або декілька елементів в масив,
                    необхідно передати три або більше аргументи, за такої умови,
                    другий аргумент повинен дорівнювати нулю. <br />
                    <br />
                    splice(position, 0, new_element_1, new_element_2, ...)
                    <br />
                    <br />
                    Аргумент position вказує початкову позицію в масиві, куди
                    будуть вставлені нові елементи. <br />
                    Другий аргумент - це нуль, він говорить методу не видаляти
                    елементи в місці додавання нових. <br />
                    Третій, четвертий і всі наступні аргументи - це нові
                    елементи, які додаються в масив. <br />
                    Наприклад, у нас є масив з назвами кольорів у вигляді
                    рядків. Додамо новий колір перед елементом з індексом 2.
                    <br />
                    <br />
                    const colors = ["red", "green", "blue"]; <br />
                    <br />
                    colors.splice(2, 0, "purple"); <br />
                    console.log(colors); // ["red", "green", "purple", "blue"]
                    <br />
                    Можна додати довільну кількість елементів, передавши
                    четвертий, п'ятий аргумент тощо. <br />
                    <br />
                    const colors = ["red", "green", "blue"]; <br />
                    <br />
                    colors.splice(1, 0, "yellow", "pink"); <br />
                    console.log(colors); // ["red", "yellow", "pink", "green",
                    "blue"] <br />
                  </p>
                  <div class="section-box">
                    <img
                      src="./img/js/array-splice-add.jpg"
                      width="500"
                      alt=""
                    />
                  </div>
                  <h2>Заміна</h2>
                  <p>
                    Заміна - це операція додавання, в якій видаляються елементи
                    в місці додавання нових. Для цього необхідно передати
                    мінімум три аргументи. Кількість елементів, що видаляються і
                    додаються, може не збігатися. <br />
                    <br />
                    splice(position, num, new_element_1, new_element_2, ...)
                    <br />
                    <br />
                    position - вказує на позицію (індекс) першого елемента для
                    видалення <br />
                    num - визначає кількість елементів, що видаляються <br />
                    Третій, четвертий і всі наступні аргументи - це нові
                    елементи, які додаються в масив. <br />
                    Наприклад, у нас є масив мов програмування з чотирьох
                    елементів. <br />
                    <br />
                    const languages = ["C", "C++", "Java", "JavaScript"]; <br />
                    <br />
                    // Заміняємо елемент з індексом 1 на новий <br />
                    languages.splice(1, 1, "Python"); <br />
                    console.log(languages); // ["C", "Python", "Java",
                    "JavaScript"] <br />
                    <br />
                    // Заміняємо один елемент (з індексом 2) на декілька <br />
                    languages.splice(2, 1, "C#", "Swift", "Go"); <br />
                    console.log(languages); // ["C", "Python", "C#", "Swift",
                    "Go", "JavaScript"] <br />
                  </p>
                  <div class="section-box">
                    <img
                      src="./img/js/array-splice-aupdate.jpg"
                      width="500"
                      alt=""
                    />
                  </div>
                  <!-- Метод concat() -->
                  <h5 class="section-title__value">Метод concat()</h5>
                  <h3>Об'єднує два або більше масивів в один.</h3>
                  <p>
                    Він не змінює масив, на якому викликається, а повертає
                    новий. Порядок аргументів методу впливає на порядок
                    елементів нового масиву.
                  </p>
                  <p class="exemplar">
                    <br />
                    const oldClients = ["Mango", "Ajax", "Poly", "Kiwi"]; <br />
                    const newClients = ["Monkong", "Singu"]; <br />
                    <br />
                    const allClientsWithOldFirst =
                    oldClients.concat(newClients); <br />
                    console.log(allClientsWithOldFirst); // ["Mango", "Ajax",
                    "Poly", "Kiwi", "Monkong", "Singu"] <br />
                    <br />
                    const allClientsWithNewFirst =
                    newClients.concat(oldClients); <br />
                    console.log(allClientsWithNewFirst); // ["Monkong", "Singu",
                    "Mango", "Ajax", "Poly", "Kiwi"] <br />
                    <br />
                    console.log(oldClients); // ["Mango", "Ajax", "Poly",
                    "Kiwi"] <br />
                    console.log(newClients); // ["Monkong", "Singu"] <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Об'єкти -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Об'єкти</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/ACXQO1YZOXI?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Об'єкти в JavaScript Frilancer
              </a>
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Функції -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Функції</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/6cKoB5ijaGA?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Функції. Стрелочные функции, рекурсия, планирование: setTimeout
                и setInterval. Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Document object model (DOM) -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Document object model (DOM)</h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/DuWyc76lYC4?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Frilancer</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Навігація по DOM</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <h3>
                    Для навігації по цій ієрархії елементи мають наступні
                    властивості.
                  </h3>
                  <div class="section-box">
                    <img src="./img/js/navigation-DOM.jpg" width="500" alt="" />
                  </div>
                  <ul>
                    <li>
                      <h3>elem.parentNode</h3>
                      <p>вибере батьківський elem.</p>
                    </li>
                    <li>
                      <h3>elem.childNodes</h3>
                      <p>
                        псевдомасив, зберігає всі дочірні елементи, включно з
                        текстовими.
                      </p>
                    </li>
                    <li>
                      <h3>elem.children</h3>
                      <p>
                        псевдомасив, зберігає тільки дочірні вузли-елементи,
                        тобто ті, що відповідають тегам.
                      </p>
                    </li>
                    <li>
                      <h3>elem.firstChild</h3>
                      <p>
                        вибере перший дочірній елемент всередині elem, включно з
                        текстовими вузлами.
                      </p>
                    </li>
                    <li>
                      <h3>elem.firstElementChild</h3>
                      <p>
                        вибере перший дочірній вузол-елемент всередині elem.
                      </p>
                    </li>
                    <li>
                      <h3>elem.lastChild</h3>
                      <p>
                        вибере останній дочірній елемент всередині elem, включно
                        з текстовими вузлами.
                      </p>
                    </li>
                    <li>
                      <h3>elem.lastElementChild</h3>
                      <p>
                        вибере останній дочірній вузол-елемент всередині elem.
                      </p>
                    </li>
                    <li>
                      <h3>elem.previousSibling</h3>
                      <p>
                        вибере елемент «зліва» від elem (його попереднього
                        сусіда).
                      </p>
                    </li>
                    <li>
                      <h3>elem.previousElementSibling</h3>
                      <p>
                        вибере вузол-елемент «зліва» від elem (його попереднього
                        сусіда).
                      </p>
                    </li>
                    <li>
                      <h3>elem.nextSibling</h3>
                      <p>
                        вибере елемент «праворуч» від elem (його наступного
                        сусіда)
                      </p>
                    </li>
                    <li>
                      <h3>elem.nextElementSibling</h3>
                      <p>
                        вибере вузол-елемент «праворуч» від elem (його
                        наступного сусіда).
                      </p>
                    </li>
                  </ul>
                  <p></p>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Пошук елементів</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    element.querySelector(selector);
                  </h5>
                  <h3>
                    Використовується, якщо необхідно знайти тільки один,
                    найчастіше унікальний елемент.
                  </h3>
                  <p>
                    Повертає перший знайдений елемент всередині element, що
                    відповідає CSS-селектору selector. <br />
                    Якщо нічого не знайдено, поверне null.
                  </p>
                  <h5 class="section-title__value">
                    element.querySelectorAll(selector)
                  </h5>
                  <h3>
                    Використовується, якщо необхідно знайти колекцію елементів,
                    тобто отримати масив посилань на елементи з однаковим
                    селектором. Наприклад, всі елементи списку з класом
                    menu-item.
                  </h3>
                  <p>
                    Повертає псевдомасив всіх елементів всередині element, які
                    відповідають CSS-селектору selector. <br />
                    Якщо нічого не знайдено, поверне порожній масив.
                  </p>
                  <p class="exemplar">
                    const listWithId = document.querySelector('#menu'); <br />
                    listWithId.style.textTransform = 'uppercase'; <br />
                    listWithId.style.fontSize = '24px'; <br />
                    console.log(listWithId); <br />
                    <br />
                    const listWithClass = document.querySelector('.menu');
                    <br />
                    console.log(listWithClass); <br />
                    <br />
                    const menuItemsByTagName = document.querySelectorAll("li");
                    <br />
                    console.log(menuItemsByTagName); <br />
                    <br />
                    const menuItemsByClass =
                    document.querySelectorAll(".menu-item"); <br />
                    console.log(menuItemsByClass); <br />
                    <br />
                    const firstMenuItem = document.querySelector(".menu-item");
                    <br />
                    firstMenuItem.style.color = 'tomato'; <br />
                    console.log(firstMenuItem); <br />
                  </p>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Властивості та атрибути</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Під час побудови DOM-дерева, деякі стандартні HTML-атрибути
                    стають властивостями елементів. Подивимося на декілька
                    властивостей, які часто використовуються.
                  </p>
                  <ul>
                    <li>
                      <h3>value</h3>
                      <p>містить поточний текстовий контент елементів форм.</p>
                    </li>
                    <li>
                      <h3>checked</h3>
                      <p>зберігає стан чекбокса або радіокнопки.</p>
                    </li>
                    <li>
                      <h3>name</h3>
                      <p>зберігає значення, вказане в HTML-атрибуті name.</p>
                    </li>
                    <li>
                      <h3>src</h3>
                      <p>шлях до зображення тегу < img >.</p>
                    </li>
                  </ul>
                  <h5 class="section-title__value">Властивість textContent</h5>
                  <p>
                    elem.textContent повертає текстовий контент всередині
                    елемента. Доступний для читання і запису. Неважливо, що буде
                    передано в textContent, дані завжди будуть записані як
                    текст.
                  </p>
                  <p class="exemplar">
                    const textEl = document.querySelector(".article-text");
                    <br />
                    console.log(textEl.textContent); // text inside
                    p.article-text <br />
                    <br />
                    const titleEl = document.querySelector(".article-title");
                    <br />
                    titleEl.textContent = 'Welcome to Bahamas!'; <br />
                  </p>
                  <h5 class="section-title__value">Властивість classList</h5>
                  <p>
                    У властивості classList зберігається об'єкт з методами для
                    роботи з класами елемента.
                  </p>
                  <ul>
                    <li>
                      <h3>elem.classList.contains(cls)</h3>
                      <p>
                        повертає true або false, залежно від наявності класу cls
                        в елемента.
                      </p>
                    </li>
                    <li>
                      <h3>elem.classList.add(cls)</h3>
                      <p>додає клас cls до списку класів елемента.</p>
                    </li>
                    <li>
                      <h3>elem.classList.remove(cls)</h3>
                      <p>видаляє клас cls зі списку класів елемента.</p>
                    </li>
                    <li>
                      <h3>elem.classList.toggle(cls)</h3>
                      <p>
                        якщо відсутній клас cls, то додає його, якщо -
                        присутній, навпаки - видаляє.
                      </p>
                    </li>
                    <li>
                      <h3>elem.classList.replace(oldClass, newClass)</h3>
                      <p>
                        замінює існуючий клас oldClass на вказаний newClass.
                      </p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    const link = document.querySelector(".link"); <br />
                    console.log(link.classList); <br />
                    <br />
                    const hasActiveClass = link.classList.contains("is-active");
                    <br />
                    console.log(`hasActiveClass - ${hasActiveClass}`); <br />
                    <br />
                    link.classList.add("special"); <br />
                    console.log(link.classList); <br />
                    <br />
                    link.classList.remove("is-active"); <br />
                    console.log(link.classList); <br />
                    <br />
                    link.classList.toggle("is-active"); <br />
                    console.log(link.classList); <br />
                    <br />
                    link.classList.replace("special", "regular"); <br />
                    console.log(link.classList); <br />
                  </p>
                  <h5 class="section-title__value">Властивість style</h5>
                  <p>
                    Використовується для читання та зміни інлайнових стилів.
                    Повертає об'єкт CSSStyleDeclaration, який містить список
                    усіх властивостей, визначених тільки у вбудованих стилях
                    елемента, а не увесь CSS. Під час запису властивості
                    записуються в camelCase, тобто background-color
                    перетворюється на element.style.backgroundColor тощо.
                  </p>
                  <p class="exemplar">
                    const button = document.querySelector(".btn"); <br />
                    <br />
                    button.style.backgroundColor = "teal"; <br />
                    button.style.fontSize = "24px"; <br />
                    button.style.textAlign = "center"; <br />
                    <br />
                    console.log(button.style); // inline styles object <br />
                  </p>
                  <p>
                    На практиці стилізація елементів виконується шляхом
                    додавання CSS-класів. Властивість style використовується для
                    додавання будь-яких динамічних стилів, наприклад, під час
                    анімації.
                  </p>
                  <h5 class="section-title__value">Атрибути</h5>
                  <p>
                    DOM-елементам відповідають HTML-теги, які містять текстові
                    атрибути. Доступ до атрибутів здійснюється за допомогою
                    стандартних методів. Ці методи працюють зі значенням, яке
                    знаходиться в HTML.
                  </p>
                  <ul>
                    <li>
                      <h3>elem.hasAttribute(name)</h3>
                      <p>
                        перевіряє наявність атрибута, повертає true або false.
                      </p>
                    </li>
                    <li>
                      <h3>elem.getAttribute(name)</h3>
                      <p>отримує значення атрибута і повертає його.</p>
                    </li>
                    <li>
                      <h3>elem.setAttribute(name, value)</h3>
                      <p>встановлює атрибут.</p>
                    </li>
                    <li>
                      <h3>elem.removeAttribute(name)</h3>
                      <p>видаляє атрибут.</p>
                    </li>
                    <li>
                      <h3>elem.attributes</h3>
                      <p>
                        властивість, що повертає об'єкт усіх атрибутів елемента.
                      </p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    const image = document.querySelector(".image"); <br />
                    <br />
                    console.log(image.attributes); // NamedNodeMap {0: class, 1:
                    src, 2: alt, length: 3} <br />
                    <br />
                    console.log(image.hasAttribute("src")); // true <br />
                    <br />
                    console.log(image.getAttribute("alt")); // "Rocks and
                    waterfall" <br />
                    <br />
                    image.setAttribute("alt", "Amazing nature"); <br />
                    <br />
                    console.log(image.getAttribute("alt")); // Amazing nature
                    <br />
                  </p>
                  <h5 class="section-title__value">data-атрибути</h5>
                  <p>
                    Дозволяють додати до тегу довільний атрибут і отримати його
                    значення в JavaScript. Цю можливість використовують для
                    того, щоб спростити написання коду, наприклад, зв'язати дані
                    і розмітку за унікальним ідентифікатором, вказати тип дії
                    кнопки тощо.
                  </p>
                  <p class="exemplar">
                    < button type="button" data-action="save">Save< /button>
                    <br />
                    < button type="button" data-action="close">Close< /button>
                  </p>
                  <p>
                    Для отримання значення data-атрибута використовується
                    властивість dataset, після якого стоїть ім'я атрибута. Тобто
                    data- відкидається, а інша частина імені записується як ім'я
                    властивості об'єкта.
                  </p>
                  <p class="exemplar">
                    const saveBtn =
                    document.querySelector('button[data-action="save"]'); <br />
                    console.log(saveBtn.dataset.action); // "save" <br />
                    <br />
                    const closeBtn =
                    document.querySelector('button[data-action="close"]');
                    <br />
                    console.log(closeBtn.dataset.action); // "close" <br />
                  </p>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Створення та видалення елементів
              </h4>
              <p>
                DOM API дозволяє не тільки вибирати або змінювати вже існуючі,
                але й видаляти, а також створювати нові елементи, після чого
                додавати їх в документ.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Створення</h5>
                  <h3>document.createElement(tagName);</h3>
                  <p>
                    Створює елемент з ім'ям tagName і повертає посилання на
                    нього як результат свого виконання. tagName - це рядок, що
                    вказує тип елемента, який створюється. Елемент створюється в
                    пам'яті, в DOM його ще немає.
                  </p>
                  <p class="exemplar">
                    const heading = document.createElement("h1"); <br />
                    console.log(heading); // < h1>< /h1> <br />
                    <br />
                    heading.textContent = "This is a heading"; <br />
                    console.log(heading); // < h1>This is a heading< /h1> <br />
                    <br />
                    const image = document.createElement("img"); <br />
                    image.src = "https://placeimg.com/640/480/nature"; <br />
                    image.alt = "Nature"; <br />
                    console.log(image); // < img
                    src="https://placeimg.com/640/480/nature" alt="Nature" />
                    <br />
                  </p>
                  <h5 class="section-title__value">Додавання</h5>
                  <p>
                    Щоб створений елемент відображався на сторінці, його
                    необхідно додати до вже існуючого елемента в DOM-дереві.
                    Припустимо, що додаємо до певного елемента element, для
                    цього існують методи.
                  </p>
                  <ul>
                    <li>
                      <h3>element.append(el1, el2, ...)</h3>
                      <p>
                        - додає один або декілька елементів після всіх дітей
                        елемента element.
                      </p>
                    </li>
                    <li>
                      <h3>element.prepend(el1, el2, ...)</h3>
                      <p>
                        - додає один або декілька елементів перед усіма дітьми
                        елемента element.
                      </p>
                    </li>
                    <li>
                      <h3>element.after(el1, el2, ...)</h3>
                      <p>
                        - додає один або декілька елементів після елемента
                        element.
                      </p>
                    </li>
                    <li>
                      <h3>element.before(el1, el2, ...)</h3>
                      <p>
                        - додає один або декілька елементів перед елементом
                        element.
                      </p>
                    </li>
                  </ul>
                  <p>
                    У всіх цих методах el - це елементи або рядки, в будь-якому
                    поєднанні і кількості. Рядки додаються як текстові вузли.
                  </p>
                  <p class="exemplar">
                    const list = document.querySelector(".usernames"); <br />
                    <br />
                    // Adds an item to the end of the list <br />
                    const lastItem = document.createElement("li"); <br />
                    lastItem.textContent = "Poly"; <br />
                    list.append(lastItem); <br />
                    <br />
                    // Adds an item to the beginning of the list <br />
                    const firstItem = document.createElement("li"); <br />
                    firstItem.textContent = "Ajax"; <br />
                    list.prepend(firstItem); <br />
                    <br />
                    // Adds a title before the list <br />
                    const title = document.createElement("h2"); <br />
                    title.textContent = "USERNAMES"; <br />
                    list.before(title); <br />
                    <br />
                    // Adds a paragraph after the list <br />
                    const text = document.createElement("p"); <br />
                    text.textContent = <br />
                    "Lorem ipsum dolor sit amet, consectetur adipisicing elit.
                    Nostrum tenetur assumenda fugiat maxime, soluta aspernatur
                    quasi nihil in asperiores ad distinctio illo et debitis
                    error iure voluptate numquam maiores nisi. Lorem ipsum dolor
                    sit amet, consectetur adipisicing elit. Nostrum tenetur
                    assumenda fugiat maxime, soluta aspernatur quasi nihil in
                    asperiores ad distinctio illo et debitis error iure
                    voluptate numquam maiores nisi!"; <br />
                    list.after(text); <br />
                  </p>
                  <p>
                    Якщо елемент для додавання вже знаходиться в DOM, то він
                    видаляється зі свого старого місця і додається у нове. З
                    цього випливає правило - один і той самий елемент не може
                    бути одночасно у двох місцях.
                  </p>
                  <h5 class="section-title__value">Видалення</h5>
                  <h3>elem.remove();</h3>
                  <p>
                    Для того, щоб видалити елемент, використовується метод
                    remove(). Він викликається на елементі elem, який необхідно
                    видалити
                  </p>
                  <p class="exemplar">
                    const text = document.querySelector('.text'); <br />
                    text.remove();
                  </p>
                  <h5 class="section-title__value">Оптимізація роботи з DOM</h5>
                  <p>
                    Сучасні браузери намагаються оптимізувати процес відтворення
                    сторінки без втручання розробника. Проте, зміна DOM-дерева -
                    це дорога операція, тому необхідно намагатися мінімізувати
                    кількість звернень до DOM.
                  </p>
                  <ul>
                    <li>
                      <h3>Repaint</h3>
                      <p>
                        - відбувається, коли зміни торкнулися стилів, що
                        впливають на зовнішній вигляд елемента, але не на
                        геометрію. Наприклад opacity, background-color,
                        visibility і outline. Браузер повторно створює елемент,
                        з урахуванням нового стилю. Також перевіряється
                        видимість інших елементів, один або більше можуть
                        виявитися прихованими під елементом, що змінив зовнішній
                        вигляд.
                      </p>
                    </li>
                    <li>
                      <h3>Reflow</h3>
                      <p>
                        - відбувається, коли зміни впливають на вміст, структуру
                        документу, положення елементів. Відбувається перерахунок
                        позиціонування і розмірів, що призводить до повторного
                        створення частини або всього документу. Зміна розміру
                        одного батьківського контейнера вплине на всіх його
                        дітей і предків. Має значно більший вплив на
                        продуктивність, ніж repaint.
                      </p>
                    </li>
                  </ul>
                  <p>
                    Усі перераховані вище операції блокують браузер. Сторінка не
                    може виконувати жодні інші операції у той час, коли
                    відбувається reflow або repaint.
                  </p>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Властивість innerHTML</h4>
              <p>
                Ще один спосіб створити DOM-елементи і помістити їх в дерево -
                це використовувати рядки з тегами і дозволити браузеру зробити
                всю важку роботу.
              </p>
              <p style="color: red">
                ВИКОРИТСОВУВАТИ ТІЛЬКИ ДЛЯ ОЧИЩЕННЯ РЯДКА (text.innerHTML="")
                АБО ДОДАВАННЯ ЧОГОСЬ НОВОГО НЕ ЗАМІНЮВАТИ СТАРЕ
              </p>
              <p>
                Якщо у властивість innerHTML записати порожній рядок, то вміст
                елемента буде очищено. Це простий і швидкий спосіб видалення
                всього вмісту. <br />
                Використовуйте властивість elem.innerHTML для додавання тільки
                тоді, коли елемент elem - порожній, або якщо потрібно повністю
                замінити його вміст.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Читання</h5>
                  <p>
                    Властивість innerHTML зберігає вміст елемента, включно з
                    тегами, у вигляді рядка. Значення, що повертається, - це
                    завжди валідний HTML-код.
                  </p>
                  <p class="exemplar">
                    const article = document.querySelector(".article"); <br />
                    console.log(article.innerHTML); <br />
                    <br />
                    const title = document.querySelector(".article .title");
                    <br />
                    console.log(title.innerHTML); <br />
                    <br />
                    const text = document.querySelector(".article .text");
                    <br />
                    console.log(text.innerHTML); <br />
                    <br />
                    const link = document.querySelector(".article .link");
                    <br />
                    console.log(link.innerHTML); <br />
                  </p>
                  <h5 class="section-title__value">Зміна</h5>
                  <p>
                    Властивість innerHTML доступна і для читання, і для запису.
                    Якщо записати в неї рядок з HTML-тегами, то браузер під час
                    парсингу рядка перетворить їх у валідні елементи і додасть в
                    DOM-дерево.
                  </p>
                  <p class="exemplar">
                    const title = document.querySelector(".article .title");
                    <br />
                    title.innerHTML = 'New and < span class="accent">improved<
                    /span> title'; <br />
                  </p>
                  <p>
                    Однотипна (шаблонна) розмітка створюється із масиву даних.
                    Прийом полягає у перебиранні цього масиву і складанні одного
                    рядка з HTML-тегами, який потім записуємо в innerHTML
                    елемента.
                  </p>
                  <p class="exemplar">
                    const technologies = ["HTML", "CSS", "JavaScript", "React",
                    "Node"]; <br />
                    const list = document.querySelector(".list"); <br />
                    <br />
                    const markup = technologies <br />
                    .map((technology) => `< li class="list-item">${technology}<
                    /li>`) <br />
                    .join(""); <br />
                    <br />
                    // Check the console, you'll see a single string with HTML
                    tags <br />
                    console.log(markup); <br />
                    <br />
                    // Adding all the markup in one operation <br />
                    list.innerHTML = markup; <br />
                  </p>

                  <h5 class="section-title__value">Додавання</h5>
                  <p>
                    Зміна elem.innerHTML повністю видалить і повторно створить
                    всі нащадки елемента elem. Якщо елемент спочатку не був
                    порожній, то виникнуть додаткові витрати на серіалізацію вже
                    існуючої розмітки, а це погано.
                  </p>
                  <p class="exemplar">
                    const article = document.querySelector(".article"); <br />
                    const htmlString = `< p class="article-text">Nullam quis
                    ante. Vestibulum dapibus nunc ac augue. In consectetuer
                    turpis ut velit.< /p> <br />
                    < a class="link" href="#">Read more...< /a>`; <br />
                    <br />
                    // Replace += with = operator. See the difference? <br />
                    // Article title is lost because we overwrite element
                    content. <br />
                    article.innerHTML += htmlString; <br />
                    <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Метод insertAdjacentHTML()</h4>
              <p>
                Сучасний метод для додавання рядка з HTML-тегами перед, після
                або всередину елемента. Вирішує проблему innerHTML з повторною
                серіалізацією вмісту елемента під час додавання розмітки до вже
                існуючої.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    elem.insertAdjacentHTML(position, string);
                  </h5>
                  <ul>
                    <li>
                      <p>
                        Аргумент position - це рядок, позиція щодо елемента
                        elem. Приймає одне з чотирьох значень.
                      </p>
                    </li>
                    <li>
                      <h3>"beforebegin"</h3>
                      <p>- перед elem</p>
                    </li>
                    <li>
                      <h3>"afterbegin"</h3>
                      <p>- всередині elem, перед усіма дітьми</p>
                    </li>
                    <li>
                      <h3>"beforeend"</h3>
                      <p>- всередині elem, після усіх дітей</p>
                    </li>
                    <li>
                      <h3>"afterend"</h3>
                      <p>- після elem</p>
                    </li>
                  </ul>

                  <p class="exemplar">
                    const list = document.querySelector(".list"); <br />
                    <br />
                    const newTechnologies = ["React", "TypeScript", "Node.js"];
                    <br />
                    const markup = newTechnologies <br />
                    .map((technology) => `< li class="list-item
                    new">${technology}< /li>`) <br />
                    .join(""); <br />
                    <br />
                    list.insertAdjacentHTML("beforeend", markup); <br />
                    list.insertAdjacentHTML("beforebegin", "< h2>Popular
                    technologies< /h2>"); <br />
                  </p>
                  <div class="section-box">
                    <img
                      src="./img/js/insertAdjacentHTML.jpg"
                      width="500"
                      alt=""
                    />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Розміри, прокрутка і координати елементів на сторінці і вікні браузера -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">
            Розміри, прокрутка і координати елементів на сторінці і вікні
            браузера
          </h3>
          <ul>
            <li>
              <a
                href="https://youtu.be/TEeKr2ON66A?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Frilancer</a
              >
            </li>

            <li>
              <p>Лінива загрузка throttle debaunce Модуль 8_2</p>
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Події -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Події</h3>

          <ul>
            <li>
              <a
                href="https://youtu.be/bWCzbR5DvCo?list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr"
                target="_blank"
                >Frilancer</a
              >
            </li>
          </ul>

          <p>
            Подія - це сигнал від браузера про те, що на веб-сторінці щось
            відбулося. Події використовуються для реакції на дії користувача і
            виконання коду, пов'язаного з певною подією. <br />
            <br />
            Одна дія може викликати декілька подій. <br />
            <br />
            Для того, щоб елемент реагував на дії користувача, до нього
            необхідно додати слухача (обробника) події. Тобто функцію, яка буде
            викликана, щойно подія відбулася.
          </p>
          <ul>
            <li>
              <h4 class="section-title__name">
                Додає слухача події на елемент.
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    element.addEventListener(event, handler, options);
                  </h5>
                  <ul>
                    <li>
                      <h3>event</h3>
                      <p>- ім'я події, рядок, наприклад "click".</p>
                    </li>
                    <li>
                      <h3>handler</h3>
                      <p>
                        - колбек-функція, яка буде викликана під час настання
                        події.
                      </p>
                    </li>
                    <li>
                      <h3>options</h3>
                      <p>
                        - необов'язковий об'єкт параметрів з розширеними
                        налаштуваннями.
                      </p>
                    </li>
                  </ul>

                  <p>
                    Для колбека можна (і бажано) використовувати окрему функцію
                    і передавати на неї посилання. Іменована функція підвищує
                    читабельність коду.
                  </p>
                  <p>
                    const button = document.querySelector(".my-button"); <br />
                    <br />
                    const handleClick = () => { <br />
                    console.log("Button was clicked"); <br />
                    }; <br />
                    <br />
                    button.addEventListener("click", handleClick); <br />
                  </p>
                  <p class="exemplar">
                    const singleBtn = document.querySelector("#single"); <br />
                    <br />
                    const handleClick = () => { <br />
                    console.log("click event listener callback"); <br />
                    }; <br />
                    <br />
                    singleBtn.addEventListener("click", handleClick); <br />
                    <br />
                    // =============================================== <br />
                    const multiBtn = document.querySelector("#multiple"); <br />
                    <br />
                    const firstCallback = () => { <br />
                    console.log("First callback!"); <br />
                    }; <br />
                    const secondCallback = () => { <br />
                    console.log("Second callback!"); <br />
                    }; <br />
                    const thirdCallback = () => { <br />
                    console.log("Third callback!"); <br />
                    }; <br />
                    <br />
                    multiBtn.addEventListener("click", firstCallback); <br />
                    multiBtn.addEventListener("click", secondCallback); <br />
                    multiBtn.addEventListener("click", thirdCallback); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                Видаляє слухача події з елемента.
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    element.removeEventListener(event, handler, options);
                  </h5>
                  <p>
                    Для видалення потрібно передати посилання саме на ту
                    колбек-функцію, яка була призначена в addEventListener(). У
                    такому разі, для колбеків використовують окрему функцію і
                    передають її за ім'ям (посиланням).
                  </p>
                  <p class="exemplar">
                    const addListenerBtn = document.querySelector('.js-add');
                    <br />
                    const removeListenerBtn =
                    document.querySelector('.js-remove'); <br />
                    const btn = document.querySelector(".target-btn"); <br />
                    <br />
                    const handleClick = () => { <br />
                    console.log("click event listener callback"); <br />
                    }; <br />
                    <br />
                    addListenerBtn.addEventListener("click", () => { <br />
                    btn.addEventListener("click", handleClick); <br />
                    console.log("click event listener was added to btn"); <br />
                    }); <br />
                    <br />
                    removeListenerBtn.addEventListener("click", () => { <br />
                    btn.removeEventListener("click", handleClick); <br />
                    console.log("click event listener was removed from btn");
                    <br />
                    }); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Ключове слово this</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Якщо колбеком буде функція, яка використовує this, за
                    замовчуванням контекст всередині неї буде посилатися на
                    DOM-елемент, на якому висить слухач.
                  </p>
                  <p>
                    const mango = { <br />
                    username: "Mango", <br />
                    showUsername() { <br />
                    console.log(this); <br />
                    console.log(`My username is: ${this.username}`); <br />
                    }, <br />
                    }; <br />
                    <br />
                    const btn = document.querySelector(".js-btn"); <br />
                    <br />
                    // ✅ Працює <br />
                    mango.showUsername(); <br />
                    <br />
                    // ❌ this буде посилатися на button, якщо використовувати
                    showUsername як callback <br />
                    btn.addEventListener("click", mango.showUsername); // не
                    працює <br />
                    <br />
                    // ✅ Не забувайте прив'язувати контекст методів об'єкта
                    <br />
                    btn.addEventListener("click",
                    mango.showUsername.bind(mango)); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Об'єкт події</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Щоб обробити подію - недостатньо знати про те, що це клік
                    або натискання клавіші, можуть знадобитися деталі.
                    Наприклад, поточне значення текстового поля, елемент, на
                    якому відбулася подія, вбудовані методи та інші.
                  </p>
                  <p>
                    const handleClick = event => { <br />
                    console.log(event); <br />
                    }; <br />
                    <br />
                    button.addEventListener("click", handleClick); <br />
                  </p>
                  <p>
                    Параметр event - це і є об'єкт події, який автоматично
                    передається першим аргументом під час виклику
                    колбек-функції. Ми можемо називати його як завгодно, але, як
                    правило, його оголошують як e, evt або event.
                  </p>
                  <ul>
                    <li>
                      <p>Деякі властивості об'єкта події:</p>
                    </li>
                    <li>
                      <h3>event.type</h3>
                      <p>- тип події.</p>
                    </li>
                    <li>
                      <h3>event.currentTarge</h3>
                      <p>елемент, на якому виконується обробник події.</p>
                    </li>
                    <li>
                      <h3>event.target</h3>
                      <p>елемент, на якому виконується обробник події.</p>
                    </li>
                  </ul>
                  <p class="exemplar">
                    const button = document.querySelector(".btn"); <br />
                    <br />
                    const handleClick = (event) => { <br />
                    console.log("event: ", event); <br />
                    console.log("event type: ", event.type); <br />
                    console.log("currentTarget: ", event.currentTarget); <br />
                    }; <br />
                    <br />
                    button.addEventListener("click", handleClick); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">
                скасування дії браузера за замовчуванням
              </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">event.preventDefault()</h5>
                  <p>
                    Деякі події викликають дію браузера, вбудовану за
                    замовчуванням як реакція на певний тип події. Наприклад,
                    клік на посиланні ініціює перехід на нову адресу, зазначену
                    в href, а відправлення форми перезавантажує сторінку.
                    Найчастіше ця поведінка небажана і її необхідно скасувати.
                  </p>
                  <p class="exemplar">
                    const form = document.querySelector(".register-form");
                    <br />
                    <br />
                    form.addEventListener("submit", (event) => { <br />
                    event.preventDefault(); <br />
                    const { <br />
                    elements: { username, password } <br />
                    } = event.currentTarget; <br />
                    console.log(username.value, password.value); <br />
                    }); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Події клавіатури</h4>
              <p>
                Існує дві основні події клавіатури: keydown і keyup. На відміну
                від інших, події клавіатури обробляються на документі, а не на
                конкретному елементі.
              </p>
              <p>
                document.addEventListener("keydown", event => { <br />
                console.log("Keydown: ", event); <br />
                }); <br />
                <br />
                document.addEventListener("keyup", event => { <br />
                console.log("Keyup: ", event); <br />
                }); <br />
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Властивості key і code</h5>
                  <p>
                    Властивість key повертає символ, згенерований натисканням
                    клавіші, враховуючи стан клавіш-модифікаторів, наприклад,
                    Shift, а також поточну мову. Властивість code повертає код
                    фізичної клавіші на клавіатурі і не залежить від мови.
                  </p>
                  <p>
                    document.addEventListener("keydown", event => { <br />
                    console.log("key: ", event.key); <br />
                    console.log("code: ", event.code); <br />
                    }); <br />
                  </p>
                  <h5 class="section-title__value">Клавіші-модифікатори</h5>
                  <p>
                    Для обробки комбінації клавіш, наприклад Ctrl + s або
                    будь-якої іншої, на об'єкті події є властивості ctrlKey,
                    altKey, shiftkey і metaKey, що зберігають булеве значення,
                    яке сигналізує про те, чи була затиснута
                    клавіша-модифікатор.
                  </p>
                  <p>
                    document.addEventListener("keydown", event => { <br />
                    event.preventDefault(); <br />
                    <br />
                    if ((event.ctrlKey || event.metaKey) && event.code ===
                    "KeyS") { <br />
                    console.log("«Ctrl + s» or «Command + s» combo"); <br />
                    } <br />
                    }); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Події елементів форм</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Подія submit</h5>
                  <p>
                    Відправлення форми відбувається під час кліку по кнопці з
                    атрибутом type="submit" або натискання клавіші Enter,
                    перебуваючи в будь-якому її текстовому полі. Подію submit
                    можна застосувати для валідації (перевірки) форми перед
                    відправленням, оскільки на об'єкті події існує багато
                    корисних властивостей, пов'язаних з елементами форми. Сабміт
                    форми перезавантажує сторінку, тому не забувайте скасовувати
                    дію за замовчуванням методом preventDefault().
                  </p>
                  <p class="exemplar">
                    const registerForm = document.querySelector(".form"); <br />
                    <br />
                    registerForm.addEventListener("submit", handleSubmit);
                    <br />
                    <br />
                    function handleSubmit(event) { <br />
                    event.preventDefault(); <br />
                    cont form = event.currentTarget; <br />
                    const login = form.elements.login.value; <br />
                    const password = form.elements.password.value; <br />
                    <br />
                    if (login === "" || password === "") { <br />
                    return console.log("Please fill in all the fields!"); <br />
                    } <br />
                    <br />
                    console.log(`Login: ${login.value}, Password:
                    ${password.value}`); <br />
                    form.reset(); <br />
                    } <br />
                  </p>
                  <p>
                    Властивість elements DOM-елемента форми містить об'єкт з
                    посиланнями на усі її елементи, які мають атрибут name. Тому
                    в прикладі ми отримуємо значення полів, звертаючись до
                    login.value і password.value.
                  </p>
                  <h5 class="section-title__value">Подія change</h5>
                  <p>
                    Відбувається після зміни елемента форми. Для текстових полів
                    або textarea подія відбудеться не на кожному введенні
                    символу, а після втрати фокусу, що не завжди зручно.
                    Наприклад, доки ви набираєте щось у текстовому полі - подія
                    відсутня, але як тільки фокус пропав, відбудеться подія
                    change. Для інших елементів, наприклад, select, чекбоксів і
                    радіо-кнопок, подія change спрацьовує відразу під час вибору
                    значення.
                  </p>
                  <p>
                    const select = document.querySelector(".pizza-select");
                    <br />
                    const textOutput = document.querySelector(".text-output");
                    <br />
                    const valueOutput = document.querySelector(".value-output");
                    <br />
                    <br />
                    select.addEventListener("change", setOutput); <br />
                    <br />
                    function setOutput(event) { <br />
                    const selectedOptionValue = event.currentTarget.value;
                    <br />
                    const selectedOptionIndex =
                    event.currentTarget.selectedIndex; <br />
                    const selectedOptionText = <br />
                    event.currentTarget.options[selectedOptionIndex].text;
                    <br />
                    <br />
                    textOutput.textContent = selectedOptionText; <br />
                    valueOutput.textContent = selectedOptionValue; <br />
                    } <br />
                  </p>
                  <h5 class="section-title__value">Подія input</h5>
                  <p>
                    Відбувається тільки на текстових полях і textarea, і
                    створюється щоразу при зміні значення елемента, не чекаючи
                    втрати фокусу. На практиці input - це найголовніша подія для
                    роботи з текстовими полями форми.
                  </p>
                  <p>
                    const textInput = document.querySelector(".text-input");
                    <br />
                    const output = document.querySelector(".output"); <br />
                    <br />
                    textInput.addEventListener("input", (event) => { <br />
                    output.textContent = event.currentTarget.value; <br />
                    }); <br />
                  </p>
                  <h5 class="section-title__value">Подія focus і blur</h5>
                  <p>
                    Елемент отримує фокус під час кліку миші або переходу
                    клавішею Tab. Момент отримання і втрати фокусу - дуже
                    важливий, отримуючи фокус, ми можемо завантажити дані для
                    автозаповнення, почати відстежувати зміни тощо. Під час
                    втрати фокусу - перевірити введені дані.
                    <br />
                    Під час фокусування елемента відбувається подія focus, а
                    коли фокус зникає, наприклад, користувач клікає в іншому
                    місці екрана, відбувається подія blur. Активувати або
                    скасувати фокус можна програмно, викликавши в коді для
                    елемента однойменні методи focus() і blur(). <br />
                    <br />
                    Фокус може бути тільки на одному елементі сторінки за
                    одиницю часу, і поточний елемент, на якому знаходиться
                    фокус, доступний як document.activeElement.
                  </p>
                  <p class="exemplar">
                    const textInput = document.querySelector(".text-input");
                    <br />
                    const setFocusBtn =
                    document.querySelector('[data-action="set"]'); <br />
                    const removeFocusBtn =
                    document.querySelector('[data-action="remove"]'); <br />
                    <br />
                    setFocusBtn.addEventListener("click", () => { <br />
                    textInput.focus(); <br />
                    }); <br />
                    <br />
                    removeFocusBtn.addEventListener("click", () => { <br />
                    textInput.blur(); <br />
                    }); <br />
                    <br />
                    textInput.addEventListener("focus", () => { <br />
                    textInput.value = "This input has focus"; <br />
                    }); <br />
                    <br />
                    textInput.addEventListener("blur", () => { <br />
                    textInput.value = ""; <br />
                    }); <br />
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Спливання подій</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <ul>
                    <li>
                      <h3>event.target</h3>
                      <p>
                        - це посилання на вихідний елемент, на якому відбулася
                        подія, в процесі спливання вона - незмінна.
                      </p>
                    </li>
                    <li>
                      <h3>event.currentTarget</h3>
                      <p>
                        - це посилання на поточний елемент, до якого дійшло
                        спливання, на ньому зараз виконується обробник події.
                      </p>
                    </li>
                  </ul>
                  <h5 class="section-title__value"></h5>

                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Припинення спливання</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">
                    тільки перешкоджає просуванню події далі
                  </h5>
                  <h3>stopPropagation()</h3>
                  <p>
                    descendant.addEventListener("click", (event) => { <br />
                    event.stopPropagation(); <br />
                    alert("Descendant click handler"); <br />
                    }); <br />
                  </p>
                  <h5 class="section-title__value">
                    повністю зупинить обробку події
                  </h5>
                  <h3>stopImmediatePropagation()</h3>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Делегування подій</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Спливання дозволяє реалізувати один із найкорисніших
                    прийомів - делегування подій (event delegation). Він полягає
                    у тому, що, якщо є група елементів, події яких потрібно
                    обробляти однаково, то додається один обробник на їх
                    загального предка, замість того, щоб додавати обробник до
                    кожного елемента. Використовуючи властивість event.target,
                    можна отримати посилання на цільовий елемент, зрозуміти, на
                    якому саме дочірньому елементі відбулася подія, і обробити
                    її.
                  </p>
                  <div class="section-box">
                    <img src="./img/js/delegate-1.jpg" width="500" alt="" />
                    <img src="./img/js/delegate-2.jpg" width="500" alt="" />
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Parcel -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Parcel</h3>
          <h3>
            Node.js npm parcel export/import = default/export (дефаултний та
            іменований) - модуль 8_1
          </h3>

          <ul>
            <li>
              <a href="https://parceljs.org" target="_blank"
                >Зборщик проекта PARCEL</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Webpack -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Webpack</h3>
          <h3>Webpack модуль 8_2</h3>
          <ul>
            <li>
              <a href="https://webpack.js.org" target="_blank"
                >Зборщик проектів Webpack</a
              >
              <a
                href="https://www.youtube.com/watch?v=o8KMucDpSno&pp=ygUbd2VicGFjayDRj9C6INC30ZbQsdGA0LDRgtC4"
                target="_blank"
                >Webpack 5 — Полный курс для начинающих. Обработка html, css,
                scss, js, image compress.</a
              >
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    - це збирач JS-модулів, менеджер модульних залежностей, який аналізує дерево залежностей і створює один або декілька результуючих файлів, що містять всю кодову базу проекту. Вибудовує порядок підключення модулів, збирає, мініфікує, запаковує та багато іншого.
                  </p>
                  <h5 class="section-title__value">Налаштування</h5>
                  <p>
                    За посиланнями нижче ви знайдете вичерпні інструкції з покроковими поясненнями налаштування Webpack.
                  </p>
                  <ul>
                    <li><a href="https://www.taniarascia.com/how-to-use-webpack/" target="_blank">How to set up webpack 5 from scratch</a></li>
                    <li><a href="https://webpack.js.org/concepts/" target="_blank">Документація Webpack</a></li>
                  </ul>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- GULP -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">GULP</h3>
          <ul>
            <li>
              <a href="https://youtu.be/jU88mLuLWlk" target="_blank">Зборщик проектів GULP video settings</a>
          
            </li>
            <li>
              <a href="https://gulpjs.com/" target="_blank">GULP</a>
            </li>
            <li>
              <a href="https://youtu.be/Hh1aDoWMJXA" target="_blank" rel="noopener noreferrer">Gulp 4, полное руководство, современный синтаксис</a>
              <a href="https://youtu.be/ODl2iCkIPpg" target="_blank" rel="noopener noreferrer">Gulp 4 сборка 2023, include файлов, конвертация шрифтов, работа с графикой, avif, webp, svg sprite</a>
            </li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
      </div>

      <!-- Формат JSON -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Формат JSON</h3>
          <h3>Модуль 8_3</h3>
          <div>
            <h3>JSON (JavaScript Object Notation)</h3>
            <p>- сучасний текстовий формат зберігання і передачі структурованих даних у текстовій формі. </p>
            <p>
              Але JSON - це не об'єкт, а його рядкове відображення. Синтаксис схожий на об'єкт, за винятком того, що ключі - це завжди рядки у подвійних лапках. Рядкові значення також обов'язково повинні бути взяті у подвійні лапки. Значеннями властивостей можуть бути типи: string, number, object, array, boolean і null.
            </p>
          </div>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Перетворення об'єкта або масива у рядок</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Метод JSON.stringify()</h5>
                  <p>
                    Приймає значення і перетворює його у JSON. Значенням може бути число, буль, null, масив або об'єкт. Рядки - це вже валідний JSON, тому в їх перетворенні немає сенсу.
                                      </p>
               <p class="exemplar"> 
                const dog = { <br>
                  name: "Mango", <br>
                  age: 3, <br>
                  isHappy: true, <br>
                }; <br>
                 <br>
                const dogJSON = JSON.stringify(dog); <br>
                console.log(dogJSON); // "{"name":"Mango","age":3,"isHappy":true}" <br>
               </p>
               <p>
                Не будь-який JavaScript об'єкт може бути перетворений один до одного у JSON. Наприклад, якщо в об'єкта є методи, то при перетворенні вони будуть проігноровані.
               </p>
               <p class="exemplar">
                const dog = { <br>
                  name: "Mango", <br>
                  age: 3, <br>
                  isHappy: true, <br>
                  bark() { <br>
                    console.log("Woof!"); <br>
                  }, <br>
                }; <br>
                 <br>
                const dogJSON = JSON.stringify(dog); <br>
                console.log(dogJSON); // "{"name":"Mango","age":3,"isHappy":true}" <br>
               </p>
               <p>Також, при спробі перетворити функцію в JSON, результатом буде undefined.</p>
               <p class="exemplar">JSON.stringify(() => console.log("Well, this is awkward")); // undefined</p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Перетворення рядка в об'єкт</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Метод JSON.parse()</h5>
                  <p>
                    Щоб отримати з JSON валідне JavaScript значення, його необхідно розпарсити (parse). Це операція зворотна перетворенню в рядок (stringify).
                  </p>
                <p class="exemplar">
                const json = '{"name":"Mango","age":3,"isHappy":true}'; <br>
                <br>
                const dog = JSON.parse(json); <br>
                console.log(dog); // {name: "Mango", age: 3, isHappy: true} <br>
                console.log(dog.name); // "Mango" <br>
                </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Обробка помилок (try...catch)</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    try...catch ловить тільки помилки, які виникли під час виконання коду (runtime errors). Це означає, що код повинен бути синтаксично правильним, інакше фаза виконання просто не запуститься. Помилки, які виникають під час фази оцінки, називаються помилками парсингу.
                  </p>
                    <ol>
                      <li>
                      <p>Спочатку виконується код всередині блоку try.</p>
                    </li>
                    <li>
                      <p>Якщо помилки відсутні, блок catch ігнорується і управління передається далі.</p>
                    </li>
                    <li>
                      <p>Якщо в блоці try сталася помилка, його виконання зупиняється та інтерпретатор переходить до блоку catch.</p>
                    </li>
                    </ol>
                    <p>Змінна error - це об'єкт помилки з інформацією про те, що сталося. У цього об'єкта є кілька корисних властивостей:</p>
                    <ul>
                      <li><h3>name</h3> - тип помилки. Для помилки парса - це SyntaxError.</li>
                      <li><h3>message</h3> - повідомлення про деталі помилки.</li>
                      <li><h3>stack</h3> - стек викликів функцій на момент помилки. Використовується для налагодження.</li>
                    </ul>
                    <h3>
                     Використовуючи конструкцію try...catch, ми можемо обробити код таким чином, щоб скрипт продовжив працювати, навіть у разі помилки.
                    </h3>
                    <p >
                                    try { <br>
                      const data = JSON.parse("Well, this is awkward"); <br>
                    } catch (error) { <br>
                      console.log(error.name); // "SyntaxError" <br>
                      console.log(error.message); // Unexpected token W in JSON at position 0 <br>
                    } <br>
                     <br>
                    console.log("✅ This is fine, we handled parse error in try...catch"); <br>
                                   </p>
                    <p>Те саме буде при спробі парса невалідного JSON, який, наприклад, може прийти з бекенду або бути прочитаний з файлу. У прикладі у властивості username бракує подвійних лапок.</p>
                    <p>
                      try { <br>
                      const data = JSON.parse('{username: "Mango"}'); <br>
                    } catch (error) { <br>
                      console.log(error.name); // "SyntaxError" <br>
                      console.log(error.message); // "Unexpected token u in JSON at position 1" <br>
                    } <br>
                     <br>
                    console.log("✅ This is fine, we handled parse error in try...catch"); <br>
                    </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
              <li>
              <h4 class="section-title__name">Фази виконання коду</h4>
              <p>В JavaScript код виконується не відразу, для початку рушію потрібно прочитати код і дізнатися, чи можливо його взагалі виконати.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <h3>Фаза інтерпретації або оцінки (compile time, evaluation time)</h3>
                  <p> - підготовка перед виконанням коду, рушій знаходить синтаксичні помилки, помилки типізації тощо. Тобто код ще не виконується, тільки оцінюється. Якщо ця фаза пройшла успішно, це як мінімум означає, що в коді відсутні синтаксичні помилки і його можна запустити для виконання.</p>
                  <h3>Фаза виконання (runtime)</h3>
                  <p>- скрипт починає виконуватися, виконуються інструкції викликів функцій і оцінки виразів, відбувається пошук необхідних ідентифікаторів у відповідних областях видимості тощо.</p>
                  <p>Якщо ця фаза завершилася успішно, отже скрипт написаний без явних помилок і завершив свою роботу. На цій фазі можуть бути помилки, пов'язані з відсутніми властивостями і змінними, перетворенням типів тощо, тобто щось, що відбувається тільки під час виконання коду.</p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Веб-сховище localStorage -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Веб-сховище localStorage</h3>
          <h3>Модуль 8_3</h3>
          <p>Подивитися вміст веб-сховища можна в інструментах розробника на вкладці Application.</p>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Web Storage API</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Веб-сховище складається з локального сховища (localStorage) і сховища сеансів (sessionStorage). Забезпечує спосіб зберігання даних інтуїтивно зрозумілим чином у вигляді пар ключ:значення.  <br>
                     Технічно у веб-сховище можна записати тільки рядки. <br>
                     У веб-сховищі не зберігають паролі, номери банківських карт і подібну конфіденційну інформацію. <br>
                  </p>
                  <h3>Локальне сховище (localStorage)</h3>
                  <p>- унікальне для кожного веб-застосунку і буде однаковим на декількох вкладках, в яких він (веб-застосунок) запущений. Дані в локальному сховищі не видаляються, навіть після закриття браузера або вимкнення комп'ютера. Щоб їх видалити, необхідно використовувати JavaScript.</p>
                  <h3>Сховище сеансів (sessionStorage) схоже на локальне</h3>
                  <p>- воно також унікальне для кожного веб-застосунку, але час життя збережених даних обмежений сесією вкладки браузера. Щойно користувач закриває вкладку або браузер, дані очищаються. На практиці сховище сеансів використовується значно рідше.</p>

                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Локальне сховище (localStorage)</h4>
              <p>Дозволяє зберігати дані без закінчення терміну дії у форматі пар ключ:значення на комп'ютері користувача і читати їх при повторному відвідуванні сторінки.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <ul>
                    <li><h3>setItem(key, value)</h3> - створює новий, або оновлює вже існуючий запис у сховищі.</li>
                    <li><h3>getItem(key</h3>) - повертає зі сховища значення з ключем key.</li>
                    <li><h3>removeItem(key)</h3> - видаляє зі сховища запис з ключем key.</li>
                    <li><h3>clear()</h3> - повністю очищає всі записи сховища.</li>
                    <li><h3>length </h3>- кількість записів у сховищі.</li>
                  </ul>
                  <h5 class="section-title__value">Збереження</h5>
                  <p>Використовуючи метод setItem(key, value), можна додати новий запис у вигляді пари ключ:значення.</p>
                  <p>localStorage.setItem("notification-level", "mute");</p>
                  <p>
                    Якщо необхідно зберегти щось, крім рядка, наприклад, масив або об'єкт, необхідно перетворити їх у рядок методом JSON.stringify(). <br>
                    localStorage.setItem("settings", JSON.stringify(settings));
                  </p>
                  <h5 class="section-title__value">Читання</h5>
                  <p>Метод getItem(key) дозволяє прочитати зі сховища запис з ключем key. Якщо у сховищі відсутній запис з таким ключем, метод повертає null. Якщо значення - це звичайний рядок, немає потреби його парсити.</p>
                  <p>
                    localStorage.setItem("ui-theme", "dark"); <br>
                    <br>
                    const theme = localStorage.getItem("ui-theme"); <br>
                    console.log(theme); // "dark" <br>
                  </p>
                  <p>
                    В іншому випадку, необхідно розпарсити значення методом JSON.parse(), щоб отримати валідні дані.
                  </p>
                  <p>
                    const settings = { <br>
                      theme: "dark", <br>
                      isAuthenticated: true, <br>
                      options: [1, 2, 3], <br>
                    }; <br>
                    <br>
                    localStorage.setItem("settings", JSON.stringify(settings)); <br>
                    <br>
                    const savedSettings = localStorage.getItem("settings"); <br>
                    const parsedSettings = JSON.parse(savedSettings); <br>
                    console.log(parsedSettings); // settings object <br>
                  </p>
                  <h5 class="section-title__value">Видалення</h5>
                  <p>Метод removeItem(key) видаляє зі сховища вже існуючий запис з ключем key.</p>
                  <p>
                    localStorage.setItem("ui-theme", "dark"); <br>
                    console.log(localStorage.getItem("ui-theme")); // "dark" <br>
                    <br>
                    localStorage.removeItem("ui-theme"); <br>
                    console.log(localStorage.getItem("ui-theme")); // null <br>
                  </p>
                  <h5 class="section-title__value">Очищення сховища</h5>
                  <p>Операція повного очищення сховища - небезпечна, оскільки може порушити записи, зроблені іншими розробниками проекту. Проте, якщо ви хочете повністю очистити сховище, потрібно викликати метод clear().</p>
                  <p>
                    localStorage.setItem("ui-theme", "light"); <br>
                    console.log(localStorage.getItem("ui-theme")); // "light" <br>
                    <br>
                    localStorage.clear(); <br>
                    console.log(localStorage.getItem("ui-theme")); // null <br>
                  </p>
                  <div class="exemplar">
                    <h3>Створимо форму для введення повідомлення і будемо зберігати його в localStorage по сабміту. </h3>
                    <div>
                      <h3>HTML</h3>
                      <p>
                        < form class="feedback-form"> <br>
                          < textarea name="message">< /textarea> <br>
                          < button type="submit">Send feedback< /button> <br>
                        < /form> <br>
                      </p>
                    </div>
                    <div>
                      <h3>CSS</h3>
                      <p>
                        body {  margin: 16px; }
                      </p>
                    </div>
                    <div>
                      <h3>JS</h3>
                      <p>
                        const form = document.querySelector(".feedback-form"); <br>
                        const localStorageKey = "goit-example-message"; <br>
                                               <br>
                        form.elements.message.value = localStorage.getItem(localStorageKey) ?? ""; <br>
                                               <br>
                        form.addEventListener("input", (evt) => { <br>
                          localStorage.setItem(localStorageKey, evt.target.value); <br>
                        }); <br>
                         <br>
                        form.addEventListener("submit", (evt) => { <br>
                          evt.preventDefault(); <br>
                          localStorage.removeItem(localStorageKey); <br>
                          form.reset(); <br>
                        }); <br>
                      </p>
                    </div>
                  </div>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Сервіс для localStorage</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Для того, щоб скоротити кількість повторюваного коду при роботі з веб-сховищем, можна написати сервіс зі стандартними методами, наприклад, save і load. Вони будуть абстрагувати повторюваний код перевірки помилок парса і подібну рутину.
                  </p>
                  <p>
                    const save = (key, value) => { <br>
                      try { <br>
                        const serializedState = JSON.stringify(value); <br>
                        localStorage.setItem(key, serializedState); <br>
                      } catch (error) { <br>
                        console.error("Set state error: ", error.message); <br>
                      } <br>
                    }; <br>
                     <br>
                    const load = key => { <br>
                      try { <br>
                        const serializedState = localStorage.getItem(key); <br>
                        return serializedState === null ? undefined : JSON.parse(serializedState); <br>
                      } catch (error) { <br>
                        console.error("Get state error: ", error.message); <br>
                      } <br>
                    }; <br>
                     <br>
                    export default { <br>
                      save, <br>
                      load, <br>
                    }; <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Асинхроність -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Асинхроність </h3>
          <h3>Модуль 9_1</h3>
          <p>JavaScript є однопоточною синхронною мовою програмування, і тому всі процеси виконуються послідовно один за одним в одному потоку і тому поки не виконяється одна дія всі інші будуть чекати в черзі на виконання. Асинхроність виконання дій реалізується за допомогою відкладення виклику дії, який здійсниться через вказаний проміжок часу. </p>
          <h4>(запуск відкладених функцій - повідомлення)</h4>
          <ul>
            <li><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank">event loop</a></li>
            <li><a href="https://www.jscamp.app/ru/docs/javascript25" target="_blank">event loop text</a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">дозволяє запланувати запуск одноразово функції через певний час</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">setTimeout()</h5>
                  <h3>const timerId = setTimeout(callback, delay, arg1, arg2, ...);</h3>
                  <ul>
                    <li><h3>callback</h3> - функція, виконання якої необхідно запланувати.</li>
                    <li><h3>delay</h3> - час в мілісекундах, через який callback-функція буде викликана один раз.</li>
                  </ul>
                  
                  <div class="section-box">
                    <p class="exemplar">
                      HTML <br>
                      < button type="button" class="btn">Click me< /button> <br>
                    </p>
                    <p class="exemplar">
                      CSS <br>
                      body { <br>
                        margin: 16px; <br>
                        text-align: center; <br>
                      } <br>
                    </p>
                    <p class="exemplar">
                      JS <br>
                      const button = document.querySelector("button"); <br>
                      <br>
                      const onClick = () => { <br>
                        const timerId = setTimeout(() => {console.log("I love async JS!");}, 2000); <br>
                      <br>
                        console.log(timerId); <br>
                      }; <br>
                      <br>
                      button.addEventListener("click", onClick); <br>
                    </p>
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">скасувати виклик функції (setTimeout()) </h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">clearTimeout(id)</h5>
                  <p class="exemplar">
                    const greet = () => {console.log("Hello!"); }; <br>
                    const timerId = setTimeout(greet, 3000); <br>
                    clearTimeout(timerId); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">запускає виконання функції не один раз, а регулярно повторює її через вказаний проміжок часу</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">setInterval()</h5>
                  <h3>const timerId = setInterval(callback, delay, arg1, arg2, ...);</h3>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Зупинити виконання setInterval()</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">clearInterval(id)</h5>
                  <p class="exemplar">
                    Клікаючи на кнопку «Start», запустимо інтервал і будемо кожну секунду виводити в консоль рядок. <br>
                    По кліку на кнопку «Stop» викличемо clearInterval() і передамо ідентифікатор інтервалу, який потрібно зупинити. <br>
                    <br>
                  </p>
                  <div class="section-box">
                    <p class="exemplar">
                      HTML <br>
                      < button class="btn js-start">Start< /button> <br>
                      < button class="btn js-stop">Stop< /button> <br>
                    </p>
                    <p class="exemplar">
                      CSS <br>
                      body { margin: 16px; text-align: center;}
                    </p>
                    <p class="exemplar">
                      JS <br>
                      const startBtn = document.querySelector(".js-start"); <br>
                      const stopBtn = document.querySelector(".js-stop"); <br>
                      let timerId = null; <br>
                      <br>
                      startBtn.addEventListener("click", () => { <br>
                        timerId = setInterval(() => { <br>
                          console.log(`I love async JS!  ${Math.random()}`); <br>
                        }, 1000); <br>
                      }); <br>
                      <br>
                      <br>
                      stopBtn.addEventListener("click", () => { <br>
                        clearInterval(timerId); <br>
                        console.log(`Interval with id ${timerId} has stopped!`); <br>
                      }); <br>
                    </p>
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

          </ul>
          <div class="section-box">
                    <img src="./img/js/event-loop.jpg" width="400" alt="" />
                    <img src="./img/js/event-loop1.jpg" width="400" alt="" />
                    <img src="./img/js/event-loop2.jpg" width="400" alt="" />
                    <img src="./img/js/event-loop3.jpg" width="400" alt="" />
                    
                  </div>
        </div>
      </div>

      <!-- Дата і час  -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Дата і час</h3>
          <h3>Модуль 9_1</h3>
          <h4>1 січня 1970 00:00 ЮНІКС ЧАС (від цього часу розпочався відлік часу в ПК)</h4>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Створення дати</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">const date = new Date() / const date = Date.now()</h5>
                  
                  <p>Екземпляр об'єкта Date - це об'єкт, що відображає певний момент часу. </p>
                  <h3>Якщо потрібно отримати теперішню дату то краще використати Date.now() щоб не створювати об'єкт</h3>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

             <li>
              <h4 class="section-title__name">повертає числове значення дати (timestamp) - кількість мілісекунд, що минула з півночі 1 січня 1970 року.</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">getTime()</h5>
                  <p>
                    const date = new Date(); <br>
                    console.log(date.getTime()); // 1624021654154
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

             <li>
              <h4 class="section-title__name">перетворює рядок у число - кількість мілісекунд</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Date.parse()</h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

             <li>
              <h4 class="section-title__name">Методи</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Геттери</h5>
                  <p>Геттери використовуються для читання усієї дати або окремої складової. Значення, що повертається, залежить від поточного часового поясу, встановленого на вашому комп'ютері.</p>
                  <ul>
                    const date = new Date(); 
                    console.log("Date: ", date); 
                                       
                    // Повертає день місяця від 1 до 31 
                    <h3>console.log("getDate(): ", date.getDate());</h3> 
                                       
                    // Повертає день тижня від 0 до 6 
                    <h3>console.log("getDay(): ", date.getDay());</h3> 
                                       
                    // Повертає місяць від 0 до 11 
                    <h3>console.log("getMonth(): ", date.getMonth());</h3> 
                                       
                    // Повертає рік з 4 цифр 
                    <h3>console.log("getFullYear(): ", date.getFullYear());</h3> 
                                       
                    // Повертає години 
                    <h3>console.log("getHours(): ", date.getHours());</h3> 
                                       
                    // Повертає хвилини 
                    <h3>console.log("getMinutes(): ", date.getMinutes());</h3> 
                                       
                    // Повертає секунди 
                    <h3>console.log("getSeconds(): ", date.getSeconds());</h3> 
                                       
                    // Повертає мілісекунди 
                    <h3>console.log("getMilliseconds(): ", date.getMilliseconds());</h3> 
                  </ul>
                  <p>Існують еквівалентні версії цих методів, які повертають значення у форматі UTC (Coordinated Universal Time), а не адаптовані до поточного часового поясу користувача.</p>
                  <ul>
                    const date = new Date();
                    console.log("Date: ", date);

                    // Повертає день місяця від 1 до 31
                    <h3>console.log("getUTCDate(): ", date.getUTCDate());</h3>

                    // Повертає день тижня від 0 до 6
                    <h3>console.log("getUTCDay(): ", date.getUTCDay());</h3>

                    // Повертає місяць від 0 до 11
                    <h3>console.log("getUTCMonth(): ", date.getUTCMonth());</h3>

                    // Повертає рік з 4 цифр
                    <h3>console.log("getUTCFullYear(): ", date.getUTCFullYear());</h3>

                    // Повертає години
                    <h3>console.log("getUTCHours(): ", date.getUTCHours());</h3>

                    // Повертає хвилини
                    <h3>console.log("getUTCMinutes(): ", date.getUTCMinutes());</h3>

                    // Повертає секунди
                    <h3>console.log("getUTCSeconds(): ", date.getUTCSeconds());</h3>

                    // Повертає мілісекунди
                    <h3>console.log("getUTCMilliseconds(): ", date.getUTCMilliseconds());</h3>
                  </ul>
                  <h5 class="section-title__value">Сеттери</h5>
                  <p>
                    Все, що можна прочитати - можна записати, методи для запису називаються також геттери, але починаються з префіксу set. <br> Також для всіх методів існують їх UTC еквіваленти.

                  </p>
                  <ul>
                    const date = new Date("March 16, 2030 14:25:00");

                    <h3>date.setMinutes(50);</h3>
                    // "Sat Mar 16 2030 14:50:00 GMT+0200"

                    <h3>date.setFullYear(2040, 4, 8);</h3>
                    // "Tue May 08 2040 14:50:00 GMT+0300"
                  </ul>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

             <li>
              <h4 class="section-title__name">Форматування дати</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Об'єкт дати може бути представлений у різних рядкових і числових форматах.
                  </p>
                  <ul>
                    const date = new Date("March 16, 2030 14:25:00");

                    <h3>date.toString();</h3>
                    // "Sat Mar 16 2030 14:25:00 GMT+0200 (Eastern European Standard Time)"

                    <h3>date.toTimeString();</h3>
                    // "14:25:00 GMT+0200 (Eastern European Standard Time)"

                    <h3>date.toLocaleTimeString();</h3>
                    // "2:25:00 PM"

                    <h3>date.toUTCString();</h3>
                    // "Sat, 16 Mar 2030 12:25:00 GMT"

                    <h3>date.toDateString();</h3>
                    // "Sat Mar 16 2030"

                    <h3>date.toISOString();</h3>
                    // "2030-03-16T12:25:00.000Z"

                    <h3>date.toLocaleString();</h3>
                    // "3/16/2030, 2:25:00 PM"

                    <h3>date.getTime();</h3>
                    // 1899894300000
                  </ul>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Проміси -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Проміси</h3>
          <h3>Модуль 9_2</h3>
          <h3>Promise (обіцянка, проміс)</h3>
          <p>- об'єкт, що представляє поточний стан асинхронної операції. Це обгортка для значення, невідомого на момент створення промісу. Дозволяє обробляти результати асинхронних операцій таким чином, якби вони були синхронними: замість кінцевого результату асинхронної операції, повертається своєрідна обіцянка отримати результат у майбутньому.</p>
          <h5 class="section-title__value">promise.then(value => console.log(value)).catch(error => console.log(error)).finally(() => console.log("Promise settled"));</h5>
          <h3>Проміс може бути у трьох станах: </h3>
          <ul>
            <li><h3>Очікування (pending)</h3> - початковий стан під час створення промісу.</li>
            <li><h3>Виконано (fulfilled)</h3> - операція виконана успішно з будь-яким результатом.</li>
            <li><h3>Відхилено (rejected)</h3> - операція відхилена з помилкою.</li>
          </ul>
          <img src="./img/js/promis.jpg" width="400" alt="">
          
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Створення</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">const promise = new Promise((resolve, reject) => {  // Asynchronous operation })</h5>
                  <ul>
                    <li><h3>resolve(value)</h3> - функція для виклику у разі успішної операції. Переданий їй аргумент буде значенням виконаного промісу.</li>
                    <li><h3>reject(error)</h3> - функція для виклику у разі помилки. Переданий їй аргумент буде значенням відхиленого промісу.</li>
                  </ul>
                  <p class="exemplar">
                    // Change value of isSuccess variable to call resolve or reject <br>
                    const isSuccess = true; <br>
                                       <br>
                    const promise = new Promise((resolve, reject) => { <br>
                      setTimeout(() => { <br>
                        if (isSuccess) { <br>
                          resolve("Success! Value passed to resolve function"); <br>
                        } else { <br>
                          reject("Error! Error passed to reject function"); <br>
                        } <br>
                      }, 2000); <br>
                    }); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

             <li>
              <h4 class="section-title__name">Метод then()</h4>
              <p>
                Метод then() приймає два аргументи - callback-функції, які будуть викликані, коли проміс змінить свій стан. Результат промісу, значення або помилку, вони отримають як аргументи.
              </p>
              <ul>
                <li><h3>onResolve(value)</h3> - буде викликана у разі успішного виконання промісу і отримає його результат як аргумент.</li>
                <li><h3>onReject(error)</h3> - буде викликана у разі виконання промісу з помилкою і отримає її як аргумент.</li>
              </ul>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">promise.then(onResolve, onReject)</h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

             <li>
              <h4 class="section-title__name">Метод catch()</h4>
              <p>
                На практиці в методі then() обробляють тільки успішне виконання промісу, а помилку його виконання у спеціальному методі catch() для «відловлювання» помилок. <br>
                Колбек-функція буде викликана у разі виконання промісу з помилкою, і отримає її як аргумент.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

              <li>
              <h4 class="section-title__name">Метод finally()</h4>
              <p>
                Тут буде виконуватися код, який необхідно запустити в будь-якому разі.
              </p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    // Change value of isSuccess variable to call resolve or reject <br>
                    const isSuccess = true; <br>
                                       <br>
                    const promise = new Promise((resolve, reject) => { <br>
                      setTimeout(() => { <br>
                        if (isSuccess) { <br>
                          resolve("Success! Value passed to resolve function"); <br>
                        } else { <br>
                          reject("Error! Error passed to reject function"); <br>
                        } <br>
                      }, 2000); <br>
                    }); <br>
                     <br>
                    promise <br>
                      .then(value => console.log(value)) // "Success! Value passed to resolve function" <br>
                      .catch(error => console.log(error)) // "Error! Error passed to reject function" <br>
                      .finally(() => console.log("Promise settled")); // "Promise settled" <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

              <li>
              <h4 class="section-title__name">Ланцюжки промісів</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Метод then() результатом свого виконання повертає ще один проміс, значенням якого буде те, що поверне його callback-функція onResolve. Це дозволяє будувати асинхронні ланцюжки з промісів. <br>
                    Оскільки метод then() повертає проміс, перед його виконанням може минути деякий час, тому частина ланцюжка, що залишилася, буде чекати. У разі виникнення помилки в будь-якому місці ланцюжка, виконання всіх наступних then() скасовується, а управління передається методу catch().
                  </p>
                  <p class="exemplar">
                    const promise = new Promise((resolve, reject) => { <br>
                      setTimeout(() => { <br>
                        resolve(5); <br>
                      }, 2000); <br>
                    }); <br>
                     <br>
                    promise <br>
                      .then(value => { <br>
                        console.log(value); // 5 <br>
                        return value * 2; <br>
                      }) <br>
                      .then(value => { <br>
                        console.log(value); // 10 <br>
                        return value * 3; <br>
                      }) <br>
                      .then(value => { <br>
                        console.log(value); // 30 <br>
                      }) <br>
                      .catch(error => { <br>
                        console.log(error); <br>
                      }) <br>
                      .finally(() => { <br>
                        console.log("Final task"); <br>
                      }); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

             <li>
              <h4 class="section-title__name">Промісифікація функцій</h4>

              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Промісифікація - це перетворення функції з колбеками таким чином, щоб вона не приймала колбеки, а повертала проміс.
                  </p>
                  <p class="exemplar">
                    const fetchUserFromServer = username => { <br>
                      return new Promise((resolve, reject) => { <br>
                        console.log(`Fetching data for ${username}`); <br>
                       <br>
                        setTimeout(() => { <br>
                          // Change value of isSuccess variable to simulate request status <br>
                          const isSuccess = true; <br>
                         <br>
                          if (isSuccess) {resolve("success value"); <br>
                          } else { reject("error"); } <br>
                        }, 2000); <br>
                      }); <br>
                    }; <br>
                     <br>
                    fetchUserFromServer("Mango") .then(user => console.log(user)).catch(error => console.error(error)); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <h3 class="section-title">Методи класу Promise</h3>
            <li>
              <h4 class="section-title__name">Promise.all() Приймає масив промісів, очікує виконання всіх і повертає проміс.</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Promise.all([promiseA, promiseB]).then(value => console.log(value)).catch(error => console.log(error));
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Promise.race() Повертає перший виконаний або відхилений проміс</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    Promise.race([promiseA, promiseB]).then(value => console.log(value)).catch(error => console.log(error));
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
            <li>
              <h4 class="section-title__name">Promise.resolve() і Promise.reject()</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <h3>Статичні методи для створення промісів, що миттєво успішно виконуються або відхиляються.</h3>
                  <p>
                     Працюють аналогічно new Promise() за винятком можливості вказати затримку, але мають коротший синтаксис. <br>
                     <br>
                  </p>
                  <p>
                    
                      // Fulfilled promise <br>
                      new Promise(resolve => resolve("success value")).then(value => console.log(value));
                    </p>
                    <h3>
                      Promise.resolve("success value").then(value => console.log(value));
                    </h3>
                    <p>
                      // Rejected promise <br>
                      new Promise((resolve, reject) => reject("error")).catch(error =>  console.error(error));
                    </p>
                    <h3>
                      Promise.reject("error").catch(error => console.error(error)); <br>
                      <br>
                    </h3>
                    <p class="exemplar">
                      const makeGreeting = guestName => { <br>
                        if (guestName === "" || guestName === undefined) { <br>
                          return Promise.reject("Guest name must not be empty"); <br>
                        } <br>
                       <br>
                        return Promise.resolve(`Welcome ${guestName}`); <br>
                      }; <br>
                       <br>
                      makeGreeting("Mango").then(greeting => console.log(greeting)).catch(error => console.error(error)); <br>
                    </p>
                  </div>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Взаємодія з бекендом (Запити на сервер) -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Взаємодія з бекендом (Запити на сервер)</h3>
          <h3>Модуль 10_1</h3>
          <p>Перед тим як користувач побачить вміст сайту на екрані, браузер робить запит на сервер, щоб отримати цей вміст.</p>
          <h3>fetch(url, option).then(response => response.json()).then(data => data).catch(error => error).finally()</h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name">Протокол HTTP</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <h3>HyperText Transfer Protocol (протокол передачі гіпертексту)</h3>
                  <p> - широко розповсюджений протокол для передачі веб-ресурсів різних типів: html, css, javascript, зображень, аудіо та відео тощо.</p>
                  <p>Під час обміну через звичайне HTTP-з'єднання всі дані передаються у вигляді тексту і можуть бути прочитані усіма, хто отримав доступ до з'єднання між клієнтом і сервером.</p>
                  <div class="section-box">
                    <img src="./img/js/HTTP.jpg" width="400" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Протокол HTTPS</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <h3>HyperText Transfer Protocol Secure</h3>
                  <p>- це налаштування над протоколом HTTP, в якій всі повідомлення між клієнтом і сервером шифруються з метою підвищення безпеки.</p>
                  <p>З HTTPS дані будуть зашифровані і хакер не зможе їх розшифрувати, тому що для розшифрування необхідний доступ до закритого ключа, який зберігається на сервері.</p>
                  <div class="section-box">
                    <img src="./img/js/HTTPS.jpg" width="400" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">REST API</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <div class="section-box">
                    <img src="./img/js/rest-api.jpg" width="400" alt="" />
                  </div>
                  <h3>API (інтерфейс прикладного програмування)</h3>
                  <p>- набір чітко визначених правил зв'язку між різними програмними компонентами. Інтерфейс описує, що можна попросити програму зробити і що буде в результаті.</p>
                  <h3>REST (representational state transfer)</h3>
                  <p>- стиль бекенд-архітектури, ґрунтується на наборі принципів, які описують, яким чином визначаються і адресуються мережеві ресурси.</p>
                  <h3>REST API</h3>
                  <p>- бекенд побудований за принципом REST. Слугує прошарком між веб-застосунком і базою даних. Має стандартний інтерфейс для звернення до ресурсів. Працює як веб-сайт, ми посилаємо HTTP-запит з клієнта на сервер, а у відповідь, замість HTML-сторінки, отримуємо дані в JSON-форматі.</p>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">HTTP-методи</h4>
              <div class="section-box">
                <div>
                  <div class="section-box">
                    <img src="./img/js/http-metods.jpg" width="500" alt="" />
                  </div>
                  <h5 class="section-title__value">Коди відповідей</h5>
                  <a href="https://uk.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D1%96%D0%B2_%D1%81%D1%82%D0%B0%D0%BD%D1%83_HTTP" target="_blank" rel="noopener noreferrer"></a>
                  <p></p>                  
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">AJAX</h4>
              <h3>AJAX (Asynchronous JavaScript and XML)</h3>
              <p> - метод отримання або відправлення даних з подальшим оновленням інтерфейсу за цими даними, без потреби перезавантаження сторінки.</p>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Fetch API (fetch(url, options))</h5>
                  <p>Інтерфейс, вбудований в браузер, доступний на об'єкті window, який містить набір властивостей і методів для відправлення, отримання та обробки ресурсів від сервера. Метод fetch() надає сучасний інтерфейс для формування запитів до сервера і побудований на промісах.</p>
                  <ul>
                    <li>
                      <h3>url</h3>
                      <p>- шлях до даних на бекенді, які необхідно отримати, створити або змінити. Обов'язковий аргумент.</p>
                    </li>
                    <li>
                      <h3>options</h3>
                      <p>- об'єкт налаштувань запиту: метод (за замовчуванням GET), заголовки, тіло тощо. Необов'язковий аргумент.</p>
                    </li>
                  </ul>
                  <p>Значення промісу, який повертає метод fetch(), - це об'єкт зі службовою інформацією про стан відповіді сервера. Екземпляр класу Response містить різні методи і властивості. Залежно від типу отримуваного контенту, використовуються різні методи для перетворення тіла відповіді у дані.</p>
                  <ul>
                    <li>
                      <h3>json()</h3>
                      <p>- парсить дані в JSON-форматі.</p>
                    </li>
                    <li>
                      <h3>text()</h3>
                      <p>- парсить дані в простому текстовому форматі, наприклад .csv (табличні дані).</p>
                    </li>
                    <li>
                      <h3>blob()</h3>
                      <p>- парсить дані, що описують файл, наприклад, зображення, аудіо або відео.</p>
                    </li>
                  </ul>
                  <p>
                    fetch("https://jsonplaceholder.typicode.com/users") <br>
                      .then(response => { <br>
                        if (!response.ok) { <br>
                          throw new Error(response.status); <br>
                        } <br>
                        return response.json(); <br>
                      }) <br>
                      .then(data => { <br>
                        // Data handling <br>
                      }) <br>
                      .catch(error => { <br>
                        // Error handling <br>
                      }); <br>
                  </p>
                  <h3>В інструментах розробника на вкладці Network відображаються всі HTTP-запити, що виконуються на сторінці.</h3>
                  <p>Вибравши фільтр XHR, залишаться тільки запити до бекенду.</p>
                  <div class="section-box exemplar">
                    <p>
                      HTML <br>
                      < button type="button" class="btn">Fetch users< /button> <br>
                      < ul class="user-list">< /ul> <br>
                    </p>
                    <p>
                      CSS <br>
                      body { <br>
                        margin: 16px; <br>
                        line-height: 1.5; <br>
                        color: #212121; <br>
                        font-family: sans-serif; <br>
                      } <br>
                       <br>
                      p { <br>
                        margin: 0; <br>
                      } <br>
                       <br>
                      .user-list { <br>
                        margin: 0; <br>
                        list-style: none; <br>
                        padding: 24px; <br>
                      } <br>
                       <br>
                      .user-list li:not(:last-child) { <br>
                        margin-bottom: 16px; <br>
                      } <br>
                    </p>
                    <p>
                      JS <br>
                      const fetchUsersBtn = document.querySelector(".btn"); <br>
                      const userList = document.querySelector(".user-list"); <br>
                      <br>
                      fetchUsersBtn.addEventListener("click", () => { <br>
                        fetchUsers() <br>
                          .then((users) => renderUsers(users)) <br>
                          .catch((error) => console.log(error)); <br>
                      }); <br>
                      <br>
                      function fetchUsers() { <br>
                        return fetch("https://jsonplaceholder.typicode.com/users").then( <br>
                          (response) => { <br>
                            if (!response.ok) { <br>
                              throw new Error(response.status); <br>
                            } <br>
                            return response.json(); <br>
                          } <br>
                        ); <br>
                      } <br>
                      <br>
                      function renderUsers(users) { <br>
                        const markup = users <br>
                          .map((user) => { <br>
                            return `< li> <br>
                                < p><b>Name</b>: ${user.name}< /p> <br>
                                < p><b>Email</b>: ${user.email}< /p> <br>
                                < p><b>Company</b>: ${user.company.name}< /p> <br>
                              < /li>`; <br>
                          }) <br>
                          .join(""); <br>
                        userList.insertAdjacentHTML("beforeend", markup); <br>
                      } <br>
                      <br>
                    </p>
                  </div>
                  <h5 class="section-title__value">Параметри рядка запиту</h5>
                  <h3>const url = "https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name";</h3>
                  <p>Параметри запиту дозволяють вказати бекенду додаткові критерії. Наприклад, скільки елементів колекції ми хочемо отримати в запиті, можливо, необхідно додати сортування за якоюсь властивістю об'єкта, обмежити вибірку тощо. Список параметрів запиту, їх назви і можливі значення залежать від бекенду і описані в документації.</p>
                  <p>Символ <span class="selection">?</span> вказує на старт параметрів запиту. Кожен параметр - це пара ім'я=значення. Символ <span class="selection">&</span> використовується для зазначення смислового «І», розділяючи параметри в рядку запиту.</p>
                  <h5 class="section-title__value">Клас URLSearchParams (запис параметрів)</h5>
                  <p>Параметрів може бути багато, і незручно складати з них один довгий рядок як для читабельності, так і для його подальшого редагування. Під час складання рядків параметрів, створюється екземпляр класу URLSearchParams та ініціалізується об'єктом. Результатом буде спеціальний об'єкт (ітератор) з методами, який у рядковому перетворенні повертає результат виклику методу toString() - своє рядкове відображення.</p>
                  <p>
                    const searchParams = new URLSearchParams({ <br>
                      _limit: 5, <br>
                      _sort: "name", <br>
                    }); <br>
                     <br>
                    console.log(searchParams.toString()); // "_limit=5&_sort=name" <br>
                     <br>
                    const url = `https://jsonplaceholder.typicode.com/users?${searchParams}`; <br>
                    console.log(url); // "https://jsonplaceholder.typicode.com/users?_limit=5&_sort=name" <br>
                  </p>
                  <p>
                    На практиці для складання параметрів запиту, як правило, використовують просто літерал об'єкта з властивостями. <br>
                    const option = { <br>
                        _limit: 5, <br>
                        _sort: "name", <br>
                    } <br>
                  </p>
                  <h5 class="section-title__value">HTTP-заголовки Клас new Headers()</h5>
                  <p>Клас Headers дозволяє виконувати різні дії в заголовках HTTP-запиту і відповіді. До цих дій належать діставання, налаштування, додавання і видалення заголовків.</p>
                  <p>
                    const headers = new Headers({ <br>
                      "Content-Type": "application/json", <br>
                      "X-Custom-Header": "custom value", <br>
                    }); <br>
                     <br>
                    headers.append("Content-Type", "text/bash"); <br>
                    headers.append("X-Custom-Header", "custom value"); <br>
                    headers.has("Content-Type"); // true <br>
                    headers.get("Content-Type"); // "text/bash" <br>
                    headers.set("Content-Type", "application/json"); <br>
                    headers.delete("X-Custom-Header"); <br>
                  </p>
                  <p>На практиці для складання заголовків запиту, як правило, використовують просто літерал об'єкта з властивостями. </p>
                  <p>
                    const headers = { <br>
                      "Content-Type": "application/json", <br>
                      "X-Custom-Header": "custom value", <br>
                    }; <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>

            <li>
              <h4 class="section-title__name">Крос-доменні запити</h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p>
                    За замовчуванням HTTP-запит можна робити тільки в рамках поточного сайту. При спробі запиту на інший домен, порт або протокол, тобто виконати крос-доменний запит - браузер видає помилку. Це зроблено з міркувань безпеки і права доступу налаштовуються на бекенді. Якщо бекенд не підтримує крос-доменні запити, фронтенд-розробник нічого не зможе з цим зробити у своєму коді. <br>
                    <br>
                    Ця політика браузерів називається CORS і розшифровується як Cross-Origin Resource Sharing, де Origin - це і є домен, порт або протокол. Дослівний переклад звучить як «спільне використання ресурсів між різними джерелами». <br>
                    <br>
                    На кожному запиті браузер сам додає HTTP-заголовок Origin, де вказує адресу веб-сторінки, яка хоче зробити HTTP-запит. <br>
                    <br>
                    Сервер перевіряє заголовок Origin і, якщо він підтримує крос-доменні запити, додає у відповідь спеціальний HTTP-заголовок Access-Control-Allow-Origin. <br>
                    Значенням цього заголовка буде дозволене джерело (Origin). У нашому випадку це повинен бути один сайт https://my-site.com, якщо бекенд приватний, або спецсимвол *, якщо бекенд публічний - дозволяє робити запити кому завгодно. <br>
                    <br>
                    Тобто браузер - це певний посередник між JavaScript-кодом і бекендом. Він додає кожному запиту заголовок Origin з правильним значенням і перевіряє наявність заголовка Access-Control-Allow-Origin у відповіді. Якщо заголовок є і його значення підходить, виконається оригінальний запит і JavaScript-код отримає його результат, в іншому випадку буде помилка CORS.
                  </p>
                  <P>
                    Тобто з клієнта не можна робити запит на будь який бекенд в мірах безпеки.
                  </P>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Пагінація -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Пагінація</h3>
          <h3>Модуль 10_2 </h3>
          <p>База даних може зберігати колекції, що містять сотні мільйонів записів. Тому повертати всю колекцію на кожен GET-запит - занадто ресурсозатратно. Розмір тіла відповіді буде занадто великий, і час запиту затягнеться на десятки секунд, або навіть хвилини - чим більше даних у відповіді від бекенду, тим довше вона передається мережею.</p>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <div class="section-box">
                    <img src="./img/js/pagination.jpg" width="500" alt="" />
                  </div>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div>
                <!-- Кількість елементів відповіді -->
                <div>
                  <h5 class="section-title__value">Кількість елементів відповіді</h5>
                  <p>Перший параметр визначає кількість елементів у відповіді від бекенду. (він називається per_page) <br>
                  У такому GET-запиті бекенд поверне не всю колекцію з дванадцяти елементів, а тільки перші чотири. </p>
                  <div class="section-box">
                    <img src="./img/js/pagination1.jpg" width="500" alt="" />
                  </div>
                </div>
                <!-- Номер групи елементів -->
                <div>
                  <h5 class="section-title__value">Номер групи елементів</h5>
                  <p>
                    Вказавши бажану кількість елементів у відповіді, ми завжди отримаємо однаковий результат - перші per_page елементів колекції, так звану першу групу або «сторінку». Другий параметр пагінації контролює зміщення всередині колекції - номер групи елементів, яку ми хочемо отримати. Нехай у нашому випадку він називається page.
                    <br>
                    Змінюючи значення параметра page, ми уточнюємо бекенду, яку наступну групу елементів хочемо отримати, і так, доки в колекції не закінчаться елементи.
                  </p>
                  <div class="exemplar section-box">
                    <p>
                      HTML <br>
                      < button type="button" class="btn">Fetch posts< /button> <br>
                      < ul class="posts">< /ul> <br>
                    </p>
                    <p>
                      CSS <br>
                      body { <br>
                        margin: 16px; <br>
                        line-height: 1.5; <br>
                        color: #212121; <br>
                        font-family: sans-serif; <br>
                      } <br>
                       <br>
                      p { <br>
                        margin: 0; <br>
                      } <br>
                       <br>
                      .posts { <br>
                        margin: 0; <br>
                        list-style: none; <br>
                        padding: 24px; <br>
                      } <br>
                       <br>
                      .posts li:not(:last-child) { <br>
                        margin-bottom: 16px; <br>
                      } <br>
                       <br>
                      .post-title { <br>
                        margin-top: 0; <br>
                        margin-bottom: 8px; <br>
                        font-size: 20px; <br>
                        font-weight: 700; <br>
                      } <br>
                       <br>
                      .post-title:first-letter { <br>
                        text-transform: uppercase; <br>
                      } <br>
                       <br>
                      .post-body { <br>
                        margin: 0; <br>
                      } <br>
                    </p>
                    <p>
                      JS <br>
                      const fetchPostsBtn = document.querySelector(".btn"); <br>
                      const postList = document.querySelector(".posts"); <br>
                                           <br>
                      fetchPostsBtn.addEventListener("click", () => { <br>
                        fetchPosts() <br>
                          .then((posts) => renderPosts(posts)) <br>
                          .catch((error) => console.log(error)); <br>
                      }); <br>
                       <br>
                      function fetchPosts() { <br>
                        const params = new URLSearchParams({ <br>
                          _limit: 5, <br>
                          // Change the group number here <br>
                          _page: 3 <br>
                        }); <br>
                    </p>
                  </div>
                  <div class="section-box">
                    <img src="./img/js/pagination2.jpg" width="500" alt="" />
                  </div>
                </div>
                <!-- Прийом «Завантажити ще» -->
                <div>
                  <h5 class="section-title__value">Прийом «Завантажити ще»</h5>
                  <p>
                    Щоб динамічно змінювати номер групи на кожний наступний запит, достатньо оголосити ще одну глобальну змінну, назвемо її page і встановимо початкове значення 1 - перша група елементів. Після кожного успішного запиту, в колбек методу then() будемо збільшувати значення page на одиницю. Складаючи параметри запиту, використовуємо її значення.
                  </p>
                  <div class="exemplar section-box">
                    <p>
                      HTML <br>
                      < button type="button" class="btn">Fetch posts< /button> <br>
                      < ul class="posts">< /ul> <br>
                    </p>
                    <p>
                      CSS <br>
                      body { <br>
                        margin: 16px; <br>
                        line-height: 1.5; <br>
                        color: #212121; <br>
                        font-family: sans-serif; <br>
                      } <br>
                      <br>
                      p { <br>
                        margin: 0; <br>
                      } <br>
                      <br>
                      .posts { <br>
                        margin: 0; <br>
                        list-style: none; <br>
                        margin-bottom: 16px; <br>
                      } <br>
                      <br>
                      .posts li:not(:last-child) { <br>
                        margin-bottom: 16px; <br>
                      } <br>
                      <br>
                      .post-title { <br>
                        margin-top: 0; <br>
                        margin-bottom: 8px; <br>
                        font-size: 20px; <br>
                        font-weight: 700; <br>
                      } <br>
                      <br>
                      .post-title:first-letter { <br>
                        text-transform: uppercase; <br>
                      } <br>
                      <br>
                      .post-body { <br>
                        margin: 0; <br>
                      } <br>
                    </p>
                    <p>
                      JS <br>
                      const fetchPostsBtn = document.querySelector(".btn"); <br>
                      const postList = document.querySelector(".posts"); <br>
                      <br>
                      // Controls the group number <br>
                      let page = 1; <br>
                      // Controls the number of items in the group <br>
                      let perPage = 10; <br>
                                           <br>
                      fetchPostsBtn.addEventListener("click", () => { <br>
                        fetchPosts() <br>
                          .then((posts) => { <br>
                            renderPosts(posts); <br>
                            // Increase the group number <br>
                            page += 1; <br>
                           <br>
                            // Replace button text after first request <br>
                            if (page > 1) { <br>
                              fetchPostsBtn.textContent = "Fetch more posts"; <br>
                            } <br>
                          }) <br>
                          .catch((error) => console.log(error)); <br>
                      }); <br>
                       <br>
                      function fetchPosts() { <br>
                        const params = new URLSearchParams({ <br>
                          _limit: perPage, <br>
                          _page: page <br>
                        }); <br>
                       <br>
                        return fetch(`https://jsonplaceholder.typicode.com/posts?${params}`).then( <br>
                          (response) => { <br>
                            if (!response.ok) { <br>
                              throw new Error(response.status); <br>
                            } <br>
                            return response.json(); <br>
                          } <br>
                        ); <br>
                      } <br>
                       <br>
                      function renderPosts(posts) { <br>
                        const markup = posts <br>
                          .map(({ id, title, body, userId }) => { <br>
                            return `< li> <br>
                                < h2 class="post-title">${title.slice(0, 30)}< /h2> <br>
                                < p><b>Post id</b>: ${id}< /p> <br>
                                < p><b>Author id</b>: ${userId}< /p> <br>
                               < p class="post-body">${body}< /p> <br>
                              < /li>`; <br>
                          }) <br>
                          .join(""); <br>
                        postList.insertAdjacentHTML("beforeend", markup); <br>
                      } <br>
                    </p>
                  </div>
                  <p>
                    Щоб знати, коли закінчаться елементи в колекції і вивести про це повідомлення користувачу, бекенд у кожній відповіді повертає не тільки масив елементів, але й метадані про доступну кількість груп («сторінок»), що залежить від значення параметра per_page, або просто загальну кількість елементів в колекції, у такому разі, обчислення кількості груп лягає на плечі фронтенд розробника. <br>
                    У нашому випадку достатньо розділити загальну кількість елементів в колекції на кількість елементів в одній групі. Це схоже на випадок, коли бекенд повертає не кількість доступних сторінок, а загальну кількість елементів в колекції.
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- CRUD -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">CRUD</h3>
          <h3>Модуль 11_1</h3>
          <div class="section-box">
            <img src="./img/js/crud.jpg" width="400" alt="" />
          </div>
          <p>
            Для взаємодії з ресурсами бекенду використовується чотири операції: створення (create), читання (read), оновлення (update) і видалення (delete). Для кожної з них визначений стандартний HTTP-метод.
          </p>
          <div class="section-box">
            <img src="./img/js/crud-method.jpg" width="400" alt="" />
          </div>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Читання</h5>
                  <p>HTTP-метод GET використовується для отримання існуючих даних. Метод fetch() повинен відправити на сервер GET-запит без тіла. Бекенд, після отримання запиту, обробить його і у відповіді поверне необхідні ресурси.</p>
                  <h3>Отримати весь масив</h3>
                  <p>
                    fetch("https://jsonplaceholder.typicode.com/posts") <br>
                    .then(response => response.json()) <br>
                    .then(posts => console.log(posts)) <br>
                    .catch(error => console.log(error)); <br>
                  </p>
                  <h3>Отримати один елемент по id</h3>
                  <p>
                    // Change this number to fetch different post <br>
                    const postId = 1; <br>
                    <br>
                    fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`) <br>
                      .then(response => response.json()) <br>
                      .then(post => console.log(post)) <br>
                      .catch(error => console.log(error)); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Створення</h5>
                  <p>Метод POST використовується для додавання нового ресурсу. </p>
                  <p>
                    <br>
                    const postToAdd = { <br>
                      author: "Mango", <br>
                      body: "CRUD is awesome", <br>
                    }; <br>
                    <br>
                    const options = { <br>
                      method: "POST", <br>
                      body: JSON.stringify(postToAdd), <br>
                      headers: { <br>
                        "Content-Type": "application/json; charset=UTF-8", <br>
                      }, <br>
                    }; <br>
                    <br>
                    fetch("https://jsonplaceholder.typicode.com/posts", options) <br>
                      .then(response => response.json()) <br>
                      .then(post => console.log(post)) <br>
                      .catch(error => console.log(error)); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Оновлення</h5>
                  <p>
                    Методи PUT і PATCH використовуються для оновлення існуючих даних. <br>
                    <span class="selection">PUT</span> видаляє елемент і замінює його новим, тому можуть втратитись деякі пункти <br>
                    <span class="selection">PATCH</span> шукає в елементі зміни і змінює тільки ті які ми передали в тілі запиту
                  </p>
                  <p>
                    <br>
                    // Change value of id property to update different post <br>
                    const postToUpdate = { <br>
                      id: 1, <br>
                      body: "CRUD is really awesome", <br>
                    }; <br>
                    <br>
                    const options = { <br>
                      method: "PATCH", <br>
                      body: JSON.stringify(postToUpdate), <br>
                      headers: { <br>
                        "Content-Type": "application/json; charset=UTF-8", <br>
                      }, <br>
                    }; <br>
                    <br>
                    fetch(`https://jsonplaceholder.typicode.com/posts/${postToUpdate.id}`, options) <br>
                      .then(response => response.json()) <br>
                      .then(post => console.log(post)) <br>
                      .catch(error => console.log("ERROR" + error)); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Видалення</h5>
                  <p>
                    Метод DELETE використовується для видалення існуючих даних.
                  </p>
                  <p>
                    <br>
                    const postIdToDelete = 1; <br>
                    <br>
                    const options = { <br>
                      method: "DELETE", <br>                     
                    }; <br>
                    <br>
                    fetch(`https://jsonplaceholder.typicode.com/posts/${postIdToDelete}`, options) <br>
                      .then(() => console.log("Post deleted")) <br>
                      .catch(error => console.log("Error:", error)); <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!-- Асинхронні функції (async/await) -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">Асинхронні функції (async/await)</h3>
          <h3> Модуль 11 урок-1</h3>
          <p>
            Робота з бекендом може бути заплутаною - після однієї асинхронної операції необхідно зробити ще один запит на сервер на підставі отриманих даних, і так кілька разів. <br>
            І тому нам неохідно, щоб запити йшли послідовно і кожен з них повернув дані на основі яких буде зроблений слідуючий запит. Тому при створенні декількох запитів у одній функції в нас утворюється ялинкоподібні вкладеності, і такий код є важко читабельний. <br>
            <br>
            Асинхронні функції допомагають позбавиться колбеків і вкладених конструкцій. Водночас, вони відмінно працюють разом із методами then() і catch(), тому що гарантовано повертають проміс.
          </p>
          <div>
            <h3>Асинхронні функції (async/await)</h3>
            <p>- зручний спосіб написання асинхронного коду, який зовні стає схожим на синхронний. В основі синтаксису async/await лежать проміси, тому він не блокує основний потік виконання програми.</p>
          </div>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Синтаксис async/await</h5>
                  <p>
                    Для оголошення асинхронної стрілочної функції, перед списком параметрів додаємо ключове слово <span class="selection">async</span>. Всередині неї можна використовувати оператор <span class="selection">await</span>
                  </p>
                  <p>
                    Будь-яка функція може бути асинхронною, чи то метод об'єкта, класу, колбек, оголошення або інлайн функція. <br>
                    <br>
                    // Function declaration <br>
                    async function foo() { <br>
                      // ... <br>
                    } <br>
                    <br>
                    // Functional expression <br>
                    const foo = async function () { <br>
                      // ... <br>
                    }; <br>
                    <br>
                    // Arrow function <br>
                    const foo = async () => { <br>
                      // ... <br>
                    }; <br>
                    <br>
                    // Object method <br>
                    const user = { <br>
                      async foo() { <br>
                        // ... <br>
                      }, <br>
                    }; <br>
                    <br>
                    // Class method <br>
                    class User { <br>
                      async foo() { <br>
                        // ... <br>
                      } <br>
                    } <br>
                  </p>
                  <p>
                    const fetchUsers = async () => { <br>
                      const response = await fetch("https://jsonplaceholder.typicode.com/users"); <br>
                      const users = await response.json(); <br>
                      return users; <br>
                    }; <br>
                    <br>
                    fetchUsers().then(users => console.log(users)); <br>
                  </p>
                  <p>
                    Коли інтерпретатор зустрічає await, він призупиняє виконання цієї функції (не тільки скрипта) і чекає, доки не виконається проміс праворуч від await. Щойно проміс виконався - виконання функції відновлюється і на рядку нижче нам доступний результат асинхронної операції.
                    <br>
                  </p>
                  <p>
                  <ul>
                    <li>
                      Оператор await можна використовувати тільки у тілі асинхронної (async) функції.
                    </li>
                    <li>
                      Оператор await призупиняє функцію, доки проміс не виконається (fulfilled або rejected).
                    </li>
                    <li>
                      Якщо проміс виконався успішно (fulfilled), оператор await поверне його значення.
                    </li>
                    <li>
                      Якщо проміс був відхилений з помилкою (rejected), оператор await викине помилку.
                    </li>
                    <li>
                      Асинхронна функція завжди повертає проміс, тому будь-яке значення, що повертається, буде його значенням.
                    </li>
                    <li>
                      Якщо не вказати значення, що повертається, повернеться проміс зі значенням undefined.
                    </li>
                  </ul>
                  </p>
                  <p>

                  </p>
                   <h5 class="section-title__value">Обробка помилок</h5>
                  <h4>
                    Якщо результат асинхронної функції (проміс) не використовується у зовнішньому коді, помилки обробляються в тілі функції конструкцією try...catch. 
                  </h4>
                  <p>
                    const fetchUsers = async () => { <br>
                      try { <br>
                        const response = await fetch("https://jsonplaceholder.typicode.com/users"); <br>
                        const users = await response.json(); <br>
                        console.log(users); <br>
                      } catch (error) { <br>
                        console.log(error.message); <br>
                      } <br>
                    }; <br>
                     <br>
                    fetchUsers(); <br>
                  </p>
                  <h4>
                    Якщо результат асинхронної функції (проміс) використовується у зовнішньому (глобальному) коді, тобто за межами інших асинхронних функцій, помилки обробляються колбеком методом catch().
                  </h4>
                  <p>
                    const fetchUsers = async () => { <br>
                      const response = await fetch("https://jsonplaceholder.typicode.com/users"); <br>
                      const users = await response.json(); <br>
                      return users; <br>
                    }; <br>
                     <br>
                    fetchUsers() <br>
                      .then(users => console.log(users)) <br>
                      .catch(error => console.log(error)); <br>
                  </p>
                  <h4>
                    Якщо результат асинхронної функції використовується в іншій асинхронній функції, помилки обробляються конструкцією try...catch.
                  </h4>
                  <p>
                    const fetchUsers = async () => { <br>
                      const response = await fetch("https://jsonplaceholder.typicode.com/users"); <br>
                      const users = await response.json(); <br>
                      return users; <br>
                    }; <br>
                     <br>
                    const doStuff = async () => { <br>
                      try { <br>
                        const users = await fetchUsers(); <br>
                        console.log(users); <br>
                      } catch (error) { <br>
                        console.log(error.message); <br>
                      } <br>
                    }; <br>
                     <br>
                    doStuff(); <br>
                  </p>
                   <h5 class="section-title__value">Паралельні запити</h5>
                  <p>
                    Якщо одночасно необхідно зробити декілька запитів, використовувати синтаксис async/await потрібно дуже обережно. У наступному прикладі будуть виконані три послідовних запити, тому що виконання асинхронної функції призупиняється, коли інтерпретатор зустрічає await. Крім того, парс результатів запитів також буде послідовний, що забере більше часу.
                  </p>
                  <p>
                    const fetchUsers = async () => { <br>
                      const baseUrl = "https://jsonplaceholder.typicode.com"; <br>
                      const firstResponse = await fetch(`${baseUrl}/users/1`); <br>
                      const secondResponse = await fetch(`${baseUrl}/users/2`); <br>
                      const thirdResponse = await fetch(`${baseUrl}/users/3`); <br>
                      <br>
                      const firstUser = await firstResponse.json(); <br>
                      const secondUser = await secondResponse.json(); <br>
                      const thirdUser = await thirdResponse.json(); <br>
                      <br>
                      console.log(firstUser, secondUser, thirdUser); <br>
                    }; <br>
                    <br>
                    fetchUsers(); <br>
                  </p>
                  <p>
                    На вкладці Network добре видно, що запуск кожного наступного запиту очікує, доки завершиться попередній. Тобто вони виконуються послідовно, що забирає більше часу, який дорівнює сумі тривалостей усіх запитів. Це нормально, якщо запити залежать один від одного, тобто наступний використовує результат попереднього.
                  </p>
                  <div class="section-box">
                    <img src="./img/js/async-await1.jpg" width="500" alt="" />
                  </div>
                  <p>
                    <br>
                    У нашому випадку вони повністю незалежні, тому потрібно запустити їх паралельно. Для цього створюється масив промісів, після чого використовується метод Promise.all(), для очікування їх виконання. Масив промісів створюється методами map(), filter() тощо, залежно від завдання.
                  </p>
                  <p>
                    const fetchUsers = async () => { <br>
                      const baseUrl = "https://jsonplaceholder.typicode.com"; <br>
                      const userIds = [1, 2, 3]; <br>
                      <br>
                      // 1. Створюємо масив промісів <br>
                      const arrayOfPromises = userIds.map(async userId => { <br>
                        const response = await fetch(`${baseUrl}/users/${userId}`); <br>
                        return response.json(); <br>
                      }); <br>
                    <br>
                      // 2. Запускаємо усі проміси паралельно і чекаємо на їх завершення <br>
                      const users = await Promise.all(arrayOfPromises); <br>
                      console.log(users); <br>
                    }; <br>
                    <br>
                    fetchUsers(); <br>
                  </p>
                  <p>
                    За такого підходу, запити запускаються паралельно, що економить час очікування їх виконання, який дорівнює тривалості «найповільнішого» з них. Такий прийом підходить тільки у разі, якщо запити не залежать один від одного.
                  </p>
                  <div class="section-box">
                    <img src="./img/js/async-await2.jpg" width="500" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
             <li>
              <h4 class="section-title__name">AXIOS (бібліотека для спрощення HTTP запитів)</h4>
              <ul>
                <li>
                  <a href="https://axios-http.com" target="_blank" rel="noopener noreferrer">AXIOS</a>
                </li>
                <li>
                  <a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">GitHub AXIOS</a>
                </li>
                <li>
                  <a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener noreferrer">npm AXIOS</a>
                </li>
              </ul>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value">Методи екземплярів (запитів)</h5>
                  <ul>
                    <li>
                      <h3>axios.get(url[, config])</h3>
                    </li>
                    <li>
                      <h3>axios.post(url[, data[, config]])</h3>
                    </li>
                    <li>
                      <h3>axios.put(url[, data[, config]])</h3>
                    </li>
                    <li>
                      <h3>axios.patch(url[, data[, config]])</h3>
                    </li>
                    <li>
                      <h3>axios.delete(url[, config])</h3>
                    </li>
                    <li></li>
                    <li>
                      <h3>axios.request(config)</h3>
                    </li>
                    <li>
                      <h3>axios.head(url[, config])</h3>
                    </li>
                    <li>
                      <h3>axios.options(url[, config])</h3>
                    </li>
                    <li>
                      <h3>axios.getUri([config])</h3>
                    </li>
                  </ul>
                  <h5 class="section-title__value">Використання</h5>
                  <span class="selection">
                    З використанням AXIOS не потрібно використовувати метод respons.json() ( два then() ) а тільки один, тому, що він поверне вже розшифрований проміс і ми до виклику функції додаємо тільки .then(data => data).catch(error => error).finally()
                  </span>
                  <h3>ВАРІАНТ 1 (Викликати окремим методом) </h3>
                  <p>
                    function users() { <br>
                      return axios.get(URL).then(data => console.log(data.users)).catch(error => console.log(error)).finally() <br>
                    } <br>
                  </p>
                  <p class="exemplar">
                    async function getUser() { <br>
                      try { <br>
                        const response = await axios.get('/user?ID=12345'); <br>
                        console.log(response); <br>
                      } catch (error) {console.error(error); <br>
                    }} <br>
                  </p>
                  <h3>ВАРІАНТ 2 (Передавати об'єкт)</h3>
                  <div class="section-box">
                    <p>
                      axios({ <br>
                        method: 'post', <br>
                        url: '/user/12345', <br>
                        data: { <br>
                          firstName: 'Fred', <br>
                          lastName: 'Flintstone' <br>
                        } <br>
                      }); <br>
                    </p>
                    <p class="exemplar">
                      axios({ <br>
                        method: 'get', <br>
                        url: 'http://bit.ly/2mTM3nY', <br>
                        responseType: 'stream' <br>
                      }) <br>
                        .then(function (response) { <br>
                          response.data.pipe(fs.createWriteStream('ada_lovelace.jpg')) <br>
                        }); <br>
                    </p>
                  </div>
                  <span class="selection">З AXIOS можемо передавати тіло (body) з данними без використання перетворення в рядок (body: JSON.stringify(tskObj)), і не потрібно вказувати в heders Content-type: "aplication/json"  він це зробить сам під капотом</span>
                  <p>
                    function saveTask(taskObj) { <br>
                      <br>
                      // БУЛО ТАК !!! <br>
                      // const options = { <br>
                      //  method: "POST", <br>
                      //  body: JSON.stringify(taskObj), <br>
                      //  headers: {'Content-Type': 'application/json }, <br>
                      // }; <br>
                      // return fetch(URL, taskObj).catch(console.log); <br>
                      <br>
                      // СТАЛО так !!! <br>
                      return axios.post(URL, taskObj).catch(console.log); <br>
                    } <br>
                  </p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>

      <!--  -->
      <div class="section">
        <div class="container">
          <h3 class="section-title">title</h3>
          <h3> </h3>
          <ul>
            <li><a href="" target="_blank"></a></li>
          </ul>
          <ul>
            <li>
              <h4 class="section-title__name"></h4>
              <div class="section-box">
                <div>
                  <h5 class="section-title__value"></h5>
                  <p></p>
                  <div class="section-box">
                    <img src="" width="0" alt="" />
                  </div>
                </div>
                <div class="section-icon">
                  <img src="" width="0" alt="" />
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </main>
    <footer class="footer"></footer>

    <script src="./main.js" type="module"></script>
  </body>
</html>
